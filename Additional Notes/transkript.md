---
CSE206-Week01-Ch1-L1-Introduction

Okay. Okay. So, uh yeah, we say that the instruction sets like x86, x64 and D64 or others uh are actually related to the computer architecture not directness to computer organization. So please I mean when you read your textbook you will already you will very easily understand that which of the weeks which chapters are related to computer organization and which are related to the computer architecture. It's very easy to make this distinction but for now if I ask you which weeks are related to com organization and which weeks are related to contract structure probably you have no idea but when you when we come to some somehow on week eight probably you will have better understanding of what a contra organization means. Uh this this year I also uh add some few more chapters because I know that from digital design you were quite clever students so I decided to add more chapters to the uh syllabus. So We will add the we will also cover the uh risk based computers reduce instruction set computers and the instruction level parallelism because you you will also have a parallel uh computing course which is also given by me in fourth year but it's an selective course but here maybe we can make a quick introduction to instruction level parallelism to see how computers speed up how they perform super linear speed up, super circular speed ups. So, uh it's also important. So, I add this new chapters to the syllabus as well. And another reason is that I already know that you had some assembly language experience. I mean, I'm expecting that. So, in the last two weeks, we will also cover the assembly language. But this may change again. The the last two week uh may be um covered by the instruction. level parallelism more or I mean we can arrange one week there as I can say this is the theoretical uh syllabus in reality um many other things may happen I mean I didn't check the public holiday this for example let me make a quick uh case do you have any or due to the Ramadan maybe we may some uh off weeks I I I don't know uh if if there is we and update this syllabus. Okay, any question regarding that? If not, uh I'm going to show you the academic calendar uh of our university. So, we are uh somewhere here where the courses begin in 27th of February. So till the end of the week we have the uh ad drop. Um so the lectures will finalized on 9th of June and then we have the exams etc. So uh our last uh lecture will be on 6th of June uh So this is the academic calendar. So if you need you can have a look at this one. Okay. So what's the main um idea behind the computer organization course uh is to understand the simple storage program computer. How a simple store program computer can run. What's a simple storage program computer? Uh a computer that can execute some stored applications through its internal uh utilities and these are the CPU bus memory uh the instruction sets the machine codes the assembly language and all these topics when they come together uh we have this stored program concept technically it's known as the one new architecture uh maybe I can give you a quick assignment about what's a one new architecture what what's a princon ar ure what's a hard architecture uh but mainly we have a stored program concept I mean there's a uh application stored in some medium in either hard disk or SSD or in some ROM RAM some some place uh and also there's an execution unit and also there's an instruction set so the program is written through these uh using this instruction set so that the computer CP can understand the program programs logic uh and executes its parts. Uh in in in the scope of this course, we will also cover the floating point number representation which is also important. I mean uh in digital design you already see how the numbers are represented in engineering notation in tools complement or in radics complements etc. But technically uh you should also know how these numbers are represented in um computer systems especially floating point numbers it's very important there's an IT 754 standard for that we will also get into detail uh so that using a same uh address space how can we store very huge numbers and very small numbers at the same time. So we will learn this uh we will have a look at the hardware organization of simple uh processors how these bus memory CPU are placed to make a basic storage program computer uh there's very good um video about the one of the oldest computers programmable computers that is the PDP 11 there's also PDP uh 7 and 11 yeah 11 and you can easily um program this device in way uh using simple interface. I will also show you some videos about that so that you will understand how the systems evolved. I mean now you are using X code and very enhanced integrated development environments but uh at one point uh the development was not like that. I in the beginning there was no integrated development environment even there was no keyboard. I mean uh in the first computers the the programmers are programming the computers without using keyboard or mouse they're directly using some switch to write a program. So we will also have a look at those simple ideas and then we will see how it's evolved how it's developed and today's computers are generated. We will also have a look at the address translation mechanisms the uh physical memory, the virtual memory, the translation systems also. Um what are the roles of these uh different processors? You know, we have many proour and pro family right now. Uh these proour families has some common features. Why they are sharing those common features? Why some of the families are different than others? Why they support different uh instruction sets. We will cover that. Uh also you will have uh some understanding of uh the basic short program concept through the seconds of machine instructions. Regarding that I'm planning to give you one assignment about uh you will write your own uh simulator for a CPU uh so that a given code I mean any given code code that is written through your instruction set can be executed in your simulator. So you will do one assignment regarding that to better understand what's a CPU is. Um also I mean in order to understand the behaviors of or the running principles of a CPA you should also understand the SML language and the machine language. We will do some uh examples about that. And um again we said that the digital design the number systems and the arithmetic systems are also uh will be covered in the lecture. So we will also focus on that. Um regarding the flo floating point numbers and integer numbers we will also cover the algorithms that is operated on these uh structures like like uh how the substraction is performed on a circuit. I mean this is not the uh way that we used in digital design. I mean in digital design we simply I try to simply show you the uh simplistic approach to perform an addition through some digital circuits. I mean the halfer the full header stuff you know uh since we don't have the substructor we are using the two complement adding and uh performing a subtraction through that. But in reality, I mean in real systems uh the for the floating point addition and subtraction are very complex operation due to the floating point positions. So we will also cover those algorithms that uh can perform these um technically basic operations but you will see that actually it's very complex operations. That's why uh it's very difficult for a computer to perform floating point arithmetic operation and that's one of the speed measurement units in computer systems I mean the uh number of floating point operation per second technically it's called as the flop uh mega flop for example floating operations per second for example so uh this is very difficult operation we will cover how its algorithm works uh other than that uh the data path the control design of the processors will be covered how these data pet and the bus are uh placed uh nearby the CPU. Uh other than that we will focus on the cache structures. As I said before caching is very important. Uh I we will have several weeks for the direct cache mapping the associative mapping set associative mapping all these topics will be covered. Okay. So These are the topics that we are going to make on 15th weeks. Um and we can uh start by the first lecture now. So as we said before our um textbook is the computer organization and architecture. Uh it's the 10th edition from William Stalling. The first chapter is about the basic concepts and the evolution of computers. Um in the uh in the class of uh computers technically we called computers as the micro computers because they have its own uh memory unit, storage unit, input output units, processing units uh etc. uh so uh when we look at from this perspective computers and microcomputers are quite similar devices but when it comes to computer organization and uh computer architecture they are uh very close as well. I mean even in the textbooks that we have some common textbooks on separate textbooks but are quite similar to each other. Uh when the technology evolves, when there's a new technology came out, uh it just not only influence the um organization of the computer, it also uh makes some change uh in the architecture. I mean for example, when you introduce an DDR6 RAM on computer systems. This is not just an organizational change. It's also an architectural change. I mean in order to support such an architecture, you should also need some uh more complex motherboard that can support this DDR6 uh RAMs etc. So uh but what's the main difference between computer and organization and computer architecture is But I always give the same example. Uh when you when you are a programmer, you are very close to computer architecture. What it means? For example, in your uh in your computer when you write a Java application when you define an integer a variable This variable is defined in the way that we use the instruction set. Which means uh when you say int a it means that for a computer system from the computer architecture perspective this will be a 64bit variable. Okay, so it's more programming related concept. However, when you look at the same problem through the computer organization part, when you define an int a an integer a variable, then how this a variable is stored on your memory. Is it a DDR3 or is it a DDR4 or it's an theorem or it's a Rome or some other place. So this perspective defines the main difference between the uh computer organization and computer architecture. In computer architecture we are very close to the programmatical concepts. So uh for a computer architecture actually it's an abstracted layer how the computer is organized. For example uh when you write your Java applications Do you really think about uh which kind of RAM is used on this computer? No, you don't. It can be DDR3 or DDR4 or something else. As a programmer, you don't care about that because there is an abstracted layer. That abstraction layer simply defines the difference between the computer organization and computer architecture. As a programmer, you deal more about when you define an inter What will be the capacity? Is it 32-bit integer? It's a 64-bit integer. What's the size of this variable? What's the size of a float? What's the size of a double? What's the size of a floating point number? So, these are the topics related to the computer architecture. When you focus on the computer organization, you will, as the name says, it's the organization of computer. How your RAM is placed, how where it's placed to the north bridge, to the south bridge, uh or to uh the some USB controller you have a right controller and others I mean the hardware related part is more related to the computer organization and software related part is more related to the uh computer architecture. So uh from this perspective our textbook examines both to computer organization and computer architecture. So uh but the more I mean the the majority of the topics are related to the from the side of the computer organization I mean in our lectures. So uh we will uh teach both of the uh topics Okay. So, uh in the meantime, let's uh give a break uh and we will start by 20 11. Okay.


Just a quick reminder for you. I'm getting the attendance records. Please inform your friends that attendance will also takes place in your grading. So be careful about that. So this week we will continue as I remember last time I talk about the is structure the institute of advanced studies the basic computer system structure we talk about that and I ask you to have a look at the book part that contains this section because today we are going to we try to understand the basics of this is computer since it's the main organizational it contains the main organizational parts of a today's computer even today computer. So in computer we have the central processing unit in the central processing unit is this complete dash lines part so it is all these part is the central processing unit inside the central processing unit we have the arithmetic logic unit on the top side and in the bottom side we have the program control unit the the main aim of the arithmetic logic unit is to perform the arithmetic and logic operations through those primitive level operations adders decoders encoders multiplex et they all here we also have the accumulator and multiplierent to perform these arithmetic and logic operations we have very important register here called the MBR register which stands for the master boot master sorry memory buffer register and the memory buffer register from IO devices or from main memory or from um from uh yeah that's all actually so it's the input and output mechanism of the CPU actually other than that on the bottom side we have the program control unit and here the one of the most important part is the PC program counter register which controls the execution of the next instruction so the address of the next instruction is stored in program counter register It can also be put in the memory. We also have the memory address register to address a given location in a computer this location can be an address in the main memory or it can be an address which defines the IO equipment. So this is the address defining system and here two part is especially the first one the IBR instruction buffer register is a specific register that is used in the structure we don't have in modern computer systems instead we use the pipeline instead the IBR is the instruction buffer register it temporarily stores the right hand side instruction of a given couple of instructions if you remember in is computer we have two instruction in per word so there is a left instruction and right instruction as you can see here we have a left instruction IBR register later on operation code is transferred instruction register to perform some control operations so this is basic definition so we in computer it's a decimal computer and it has 40 bits in it if you have a number then we have this representation where we have other instruction of application equally 20 bits per instruction in 20 bits we have eight bits of operation code shortly we say that this is an op code and 12 bits of addressing this addressing is used to address one of those bits because as you can see the addressing here starts from 0 one to up 495 if 1 kilo stand for 10 to power 10 so this is equal to 4 kil say it's 12 bits you know in let me write it here I think you remember those things from the digital design but one K is 2 power 10 then 2 kil is equal to power 11 then 4 kilo is equal to 2 to power 12 as you can see this 12 defines this 4k bytes as you can see it's 45 starting from zero. So this 12 bits actually these 12 bits ok that's why we have 12 12 bits here Kw96 storage locations in this machine technically these are called individual words and each of these words is capable of storing 40 binary digits or 40 bits each. So the word size of this machine is 40 bits and every instruction gets 20 bits in its capacity are eight codes or operation codes which means that we can define to power e different operations on this machine I mean think that the first operation can beer to or another one right ok one of them can be this and there are plent of options and the last one can be this one So in between you can define to the power eight different operations on this machine. As you can see if you want to perform more operations if you want to support more instructions for the programmers then you should use more operation code part. I mean eight but if eight is not enough then you should use bit but in that case if you don't change the organization or the architecture then the address will be reduced by up are limitations available to bit to 64 bit system as well I mean there was there was a limitation between the 32 bit systems that we can define to power 32 different bytes for the computer which technically equal to 4 gigabytes of memory and as you can see today computers even your mobile phones has at this 4 gab of memory. So if you want to support 6 gab, 8 gab, 16 gab and more memories you need to have the next one. Not to power 33 but instead developers use to power bit or we are using 64 bit CPUs to support very very large. I mean 64 bit is really large enough to support enough amount of uh memory. So Yeah, we we explain this part last week already and I ask you to have a look at this section. As you can see this behavior is this is a flow chart representing how an is computer operation takes place. In the beginning we simply check whether the next instruction is in the buffer register IBR buffer register in the beginning no. So we simply put the program counter value to the memory address register to have a look at what's inside this memory address value. So using the memory we access the memory address registers location and we read the content to the memory buffer register then left instruction required initially we can say that the left instruction is required because we are executing the first instruction in the couple in the in the words. So the the right part as you can see this is I mean if you think that this is the word this is the address zero this is address 39 and this is the middle which which discriminates the left part and right part and this will be 19 and this will be 20 bits right so as you can see in I mean since we read the content of the memory to memory buffer register think that this is the content of the memory buffer register then from 20 to 39 I mean the right hand side instruction is transferred to a temporal location called IBR instruction buffer register. So this part is now in the IBR and then the content of the MBR's first e bits when this is the first from 0 to se this is the first which is the ope of the left most left instruction is transfer to the instruction register and the remaining 12 bits from to memory address register then every single here every single pad here defines a different CPU instruction which is defined in this table I mean each of these rows actually must be present each of these rows must be present in this vertical options I mean according to the type of the value actually we we define time to time we have this diamond shape which is the decision point sometimes according to the accumulators value sometimes according to the content of some registers some of the pats are ch but as you can see here we we generate we perform the execution and after the execution we go back to the fetch cycle this is technically called fetch decode execute cycle this is very important decode and execute this part is part is the fetch part where we bring some content from the from the main memory and then we have the decode part in the decode part we try to understand what's this instruction what this opode does according to this definitions at these descriptions as you can see each of these instructions has some despt operations. Then after decode it if operation going to add this value and result will be stored to this one according to this description. So we executed finally and I mean after you deced you executed. This is the execution cycle this part and this one continues until your application simply hals or stops. Ok. So as you can see This is the 20 almost 20 I think instruction in this is instruction set. As you can see we are not using complete to power eight different combinations as an operation codes. Instead we have different category of instruction types. For example, this is the first category for data transfer. We are transferring data from memory to some accumulator or from accumulator to memory or we are loading some um how can I say absolute values etc are different loading options available there is an unconditional branch branching is changing the way that a serial application executes so it's simply a jump operation we can jump to a specific location in the application so this is as you can see the technique the symbolic representation is the jump but as the name says it's unconditional conditional means without any condition without taking care of any other operation we just jump directly in modern modern programming language this is equal to the go to statement just go to that line go to that label that's all another group is conditional branch conditional branch is quite similar to the unconditional branch however in conditional case as the name says there there is some condition i mean in order to jump some conditions must be tru other othermetic group of instructions as can see these are the add sub multiply divide left shift and right shift operations and the last one is the address modification operations. Depending on the complexity of the CPU these address modifications can vary a lot in this case we just have the store instru instructions ok I mean this address why this is important I mean last one is important because in the address instructions simply allows our address to be competed in the arithmetic logic unit and then these competed addresses can be inserted into instructions add location so this will address computation so kind of addressing flexibility because we can easily calculate some address or we can iterate over this address to for example if you want to access like an array like access you know in arrays we access through the indices and if you increment the index then you can access array value etc. Ok so let's start the one the second gener these were the first generation somewhere from 1940s to 1950s and then the second generation actually here the actual speed up came out with the invention of the Transistors. Transistors are smaller instead of the vacuum tubes. They are smaller, they are cheaper, they dissipate less heat than the traditional vacuum tube. They don't need to get warm. You don't have to wait for that. Not like a car. So, it's made up from silicon. So, since as you know that in today, we are we are still using the transistors. Of course, not the first generation transistors but Still the trans are the main structure of our computers. Its invention is starting in 1947 but it's not fully utilized. It's not used very well in the computer industry in late 1950s. Ok. In this table you see the typical speed I mean say operation per 200000 million and as speed this operational speed increased almost 50% every year up to year 2000 and yeah up to year 2000 almost the speed of computers incremented up to 50% But then this increment somehow slow due to the physical limitations and now we have instead of higher high number of frequencies we are using multicore computers having multiple CPU cores in the second generation computers uh compared to the previous level they have 50% performance increase and again IBM 1790 series are good example for the second generation computers these computers are simply have the CPU some multiplexer memory through the data channel they can access many different kind of peripheral devices one I mean this is good but later on actually for us for computer engineers the most important one is the third generation I think because in third generation computers now we will be able to program the computer. I mean you know the main idea behind the computer is creating general programs. I mean technically they are called at general purpose computers you can program at any topic using some environment but nowadays you know you are using X code you are using visual studio you are using GT notebook et there are plenty of different media exist to develop applications to debug applications to write applications to compile applications you have plenty of different compilers plenty of different environments it's it's possible now but when you go back when you go back the early days when you have very um very very first computer platform then systems generated think studio visual studio is also an application Xcode is also application even the notepad is itself it's an application that it's code must be written in some other platform but when you think this um when you go back There's a problem I mean at some point you will realize that there's some missing technology out there and this missing technology is actually a very difficult technology. I mean in the early days of computers the programming was very very difficult. So today I'm going to show you the one of the third one of the most important third generation uh computer called PDP8. It's a DE system. visual on screen. It's the PDP8 later on this PDP8 the one of the first and famous programming language the C programming languages later on developed on the next generation of this computer. That's why PDP8 is very important. In PDP8 the integrated circuits are now invented in 196 where our electronic equipments now composed of very large and discrete compans. These are the transistors, resistors, capacitors and other electronic components. These discrete components were manufactured separately and packaged in their own containers using some soldering, some wires together like circuit boards. and then installed in computers. Actually, if we compare the second generation computers contained around 10,000 transistors but now hundreds of thousands of uh transistors is manufactured in this Turk generation uh computers. So that that's called the integrated circuit. like to before breakesenting how computer works today of PDP machine exist you can buy it can program it like the original one so let me open the YouTube Um yes this one. Hey everybody. Ok let me share my screen. sound. Ok. No. So it's it's run. We will have a look at run. I believe I just spent a good hour plus recording some videos about this PDP8 replica that I put together and I had the microphone off the whole time. So before starting let me explain some fields here. Uh As you can see, this is a computer. There is no dedicated screen. This is the screen. Just some LEDs or like light bulbs. This is an optal machine. So everything is based on eight as you can see and every group here is three bits representing the eight different combination. Um there are some here field I mean corresponding leftm switch these are physical switch on the bottom side by the way having different colors each of them has different color the leftmost part is the data field then we have the instruction field and then this 12 bit as you can see this 12 bit here 1 two 3 4 5 6 7 8 9 10 11 12 corresponds to the program counter this is the memory address register is the memory buffer register is the accumulator from arithmetic logic unit and this is the multiplier quant again from arithmetic logic unit on the right side you have some common these are the instructions well or frequently used instructions like the start for example start is to start an application executable start here if press it the application will start so it's similar to the enter I mean today's enter capability is same as the start one load deposit examination examination is for debugging applications load and deposit is to load and store the data from and to the memory continue simply for debugging purpose stop simply stops the application and these are instruction execution start f8 f10 debugging press line by line debugging the same thing available here with the examination you can examine the content of the memory according to what you ask from the memory address what you put in the memory address register you can find the memory content in the memory buffer register. So previously I watch this video the guy is making two different programs. The first one is very easy. The first one is just a single instruction application simply the application will start and in the next instruction it will hold. In the second application it will write an application that increments the value by five times then stops or halts. So let's try to understand how it works. Again, I do want to keep this interesting. I hope that uh people will find it interesting. I think this is really cool. And uh basically the the one I'm going to redo here and actually post will be uh just a quick tour of the thing and um a little introduction to PDP assembly language or PDPA assembly language and um you know maybe you can learn a few instructions or two. I apologize for drinking my tea while I'm doing this but I have to multitask at this point. It's getting late. So let's go uh quick tour the front panel here. As you can see, there are lights and switches. Computers of old uh were awesome. They had lights and switches. People, you know, how could you trust that the machine is working if you can't see its internal state? And so to that end over here, you can see which class of addresses executing, what phase it's in, whether the machine's running or stopped. Um, you've got the accumulator. Of course, you want to know what's in your accumulator at all times. Um, you get the program counter so you can know where it's executing and uh you can see memory uh address and contents and other stuff which I'm not going to get into now. Um, most of all because I don't know what it is yet. I haven't learned everything about this machine. And then down here, you have uh all of your exciting toggle switches. So, on the left side is where you actually enter the uh the data and then on the right side are some of the controls for it. You might notice that these are grouped uh in groups of three and that is because they are they represent octal. So when I talk about addresses and things when I talk about All the numbers I'm talking about, I will be using octal notation. Um, three bits. You can enter any number up from 0 to S. Um, and you don't have that annoying hexadecimal to have to worry about what you do with the letters and things. So, stick to three bits. Now, the left two we're going to ignore completely. Those correspond to the data field and instruction field. We're not going to use those. They're confusing. They just make things difficult. It's a kind of bank switching scheme to access more than 4K words of memory. 4K words of memory. This is a 12 bit mach 12 bit word this is similar to the is computer if you remember I mean in in that machine we also have the 12 bits and 496 words I mean on that machine it's 40 bits each but on this one it's um and that is why there are in fact 12 bits here four groups of three. So we're going to concern ourselves with this four groups of three here. Um and so uh first thing I will do over here on the uction on the controls is I will press the stop key. When I press that, it stops the computer. You can see the light stop blinking. It freezes uh where it was. I can then press continue to resume execution. Stop, continue, stop, continue. Isn't that great? Uh so let's stop the machine. And now um I will uh let go ahead and and show you how to enter uh a program. So as I said, there uh are 4,096 uh memory addresses to simplify things a bit that we could we could use. So we can put our program anywhere we want in memory. I'm going to choose to put the program at location 10 one optal uh which of course in decimal would be eight uh and in binary would be 100. Ok so the first thing we do is we put the address that we want. to start entering instructions at uh on these tag switches. So up is zero, down is one. So we want to enter address oneer optal and so essentially of these four uh groups 10 ok so I'm just going a little bit slowly here because I will be will be using addressing a lot and it's kind of thing to get used to evet 8 sayısı biliyorsun Türkçe devam edeyim son kısmı biliyorsunuz 8 sayısı 1 0 şeklinde olduğu için buradaki eee renkli kısımdan en sağdaki seçilmiş durumda. Değerleri de 0 şeklinde one iner divides allal use. So press load load transfers of these toggle switches up to this line here that has the program counter Gördüğünüz gibi buradaki bütün sıfırlar ve sadece şuradaki 1 sayısı buraya ışığa yansımış oldu. Geri kalan kısımlar program counterda 0 olarak geldi. Bunu da load komutuyla yapmış. Aslında şu noktada yapılan işlem şu arkadaşlar. Program countera 8 nolu adres verilmiş oldu. Yani bu aslında Çok high level bir böyle ilişkilendirme yapacak olursak bu sizin işte programınızı bir IDde yazmak için bir satırın başına gelmeniz anlamına geli. O satıra bir şey yazacaksınız. Cursory'ı işaretçiyi o satıra bir şekilde ya mouse'a tıkladınız. Oraya bir yazı yazacaksınız ya da işte enter'e bastınız. Oraya geleceksiniz. Programımızın ilk kodunu yazmak için memory'den bir adres alıyoruz. Bu adres de 8. adres. Hod arkadaşlar dediğim gibi ilk örnek sadece program çalışacak ve ilk instructionı programı durdurma instruction olan hal instruction olacak ve program bitecek. Tek instructionlık bir program. Eee bu halt instruction'a ait operation codda 7402 şeklinde eee belirtmiş. Dolayısıyla bu 7402'yu şuradaki program counter'a bir şekilde e 7 sayısını e 4 sayısını yani burada e 3ünü işaretleyecek. Burada ilk baştaki beyazı işaretleyecek. 1 0 şeklinde. Diğerinde 0 1 0 şeklinde işaretleyecek. Diğerinde de eee 0 pardon pardon burası 0 olacak. En son kısım 0 1 0 olacak şeklinde işaretleyecek. Bu şekilde de 7402 yani halt komutunu eee buradan bilmiş olduk. Tabii bunu yazabilmek için bu cihaza ait PDP'e PDP 8'e ait eee instruction CPU instructionlarının o tablosunu da bilmemiz gerekiyor. Nasıl is computer'da böyle bir tablomuz varsa işte 20 instruction vardı. Eee her instruction'ın belli bir op kodu var ve açıklaması var. Burada da işte hangisinin ne olduğunu belirten bir kitapçıkla eee bu programlama işlemi gerçekleştir. Zero 7402 and now we press deposit and deposit will take whatever is to on these switches and store it at the address that the program counter is set to here so we're going to put a 7402 at location by pressing deposit there are couple of things arkadaşlar burada depozit komutu kullanıldığında yani memory bir kayıt işlemi gerçekleştiğinde eee ne yapıldı ona bakalım. Eee bir defa eee memory buffer'ımız yani az önce şurada switch'lerle belirtilmiş olan işte 7 4 bakın şurada 7 4 0 ve 2 sayıları memory buffer register'a aktarılmış oldu. Memory adresimiz az bir önceki işlemde belirtmiş olduğumuz 8 numaralı yani 100 numaralı adresi olmuş oldu. Program counterumuz da bize yardımcı ol olması açısından ne demiştik? Otocrement bir değerdir demiştik. I computerde de böyleydi. Otoement olarak 8 sayısından 1 yani 9 sayısına geçiş yapmış oldu. Of course halt stops now Uygulamayı çalıştırmak için tekrardan 8 numaralı adrese bakın 100 adresi program counteruna girdi. Biliyorsunuz program counter bir sonraki çalışacak instructionın adresini adresini söylüyor. 8 numaralı adresteki programı çalıştırır demek oluyor bu. Dolayısıyla program counterda 8 varken eğer eee load adresi yapar yani şuradaki load adresi yaptığımız zaman switch'ten 8 sayısını aldı. Program counter'a yerleştirdi. Ardından start tuşuna bastığımızda da Bakın program çalıştığında otomatik olarak 8 no'lu adres 9 nolu adrese de geldi. Yani 8 çalıştı, 9 çalıştı ama 9 çalıştığında halt komut olduğu için orada durmuş oldu ve uygulama çalıştı ve bitti. Bakın load dediğinde otomatik olarak bu load memory adresimiz 8'i gösterdiği için 8'den load yapıp start yapıldığında execute ediyor. Dolayısıyla program counter 9'a geliyor. Her load start yaptığında tocodes are told uscut something instruction umt instruction stops it running. So halt so that's our simplest possible program. Now let's Let's do something more interesting. How about we uh increment the accumulator? So we'll uh make a two instruction program. Increment the accumulator uh maybe even five times and then halt. We'll make a six instruction program. So uh one is the address we want to enter this at again. Same as before. So we're going to reset the program counter to one load. And now we're going to start accumulator accumulatordakium değerini yani şu aşağı kısımdaki biliyorsunuz aritmetik logic yönetimi bir parçası. Oradaki değeri 5 defa artıran instruction'ı kull yani daha doğrusu 1 artıran struction'ı 5 defa yazacağız. Bu yani a = 0 a + a + a + şeklinde bir ifadenin pdp8 karşılığı. Eee increment accumulator e operation kodu da burada 7 1 şeklinde Bakın sürekli depozit edildiğinde biliyorsunuz program counter her bir basıldığında programcıya kolaylık yapması açısından yani instruction'a girdiğiniz zaman bir sonraki satıra geçiyor. Bir enter gibi davranıyor demiştik. Bir sonraki satıra geçiyor ve bir sonraki satıra da eee bu oto yani bütün satırlara daha doğrusu eee oto increment komutu girmiş oluyor. Beş defa depozit yaptığınız zaman 5 defa akümülatördeki değeri İkrement increment increment inkrement inkrement yap eee demek oluyor. Bu da eee başlangıçtaki 0 değerini akümatördeki başlangıçtaki 0 değerini 5 defa artırmış olacak. Eee eğer program çalışıp bittiğinde de zaten akümülatördeki değerin eee artmış olduğunu son instructionda durdurma instruction stop load şu an yine 8 adrese yani programın başlangıcına memory adres 8'de yer alan content bakın memory buffer içerisine gelmiş oldu. Bu da 71 şeklinde bir OP kod aslında biliyorsunuz 7001'i az önce açıklamıştı. Bu oto increment komutumuz aslında 8. adreste de 9, 10, 11 ve 12. adreste bu komuttan eee bulunmakta.
Yani exam butonuyla buradaki examination butonuyla eee memory adresin göstermiş olduğu contenti memory buffer registerda görebilir. değişmiyor çünkü hep en son alt komutumuz var. I start what happen didul start 0 değeri 5 defa artırıldığında accumulatordaki 5 sonuç oldu. Tabii bu eee hızlı bir şekilde gerçekleştiği için orada incrementi görmedik yani. Eğer bunu tekbilecektik accumulator zer increment increment increment halt and seeing now at this points. We can go back to the beginning load toggle the single instruction toggle which means now when I press start instruction start buton bastığınızda sadece bir instruction çalışıp stop edecek. Daha doğu pause edecek aslında. Dolayısıyla ilk increment çalıştığında accumulatorda bir değeri oluştu. I don't know iful thing counter so we executed at program counter to be showing 11, but it in fact shows one, two, but memory address shows one. So, I think what happens here is it's actually halting after it has fetched the next instruction and it's it's already sort of preloaded program counter with where it will be after the next instruction even though. So, it's kind of like one step ahead. Aslında burada sanırım anlatan kişinin program counterla ilgili teknik da kafası karışmış. Çünkü program counter adı üzerinde next instruction to execute şeklinde bir yapısı var. Yani o an eee çalıştırılacak olan instruction yani bir sonraki çalıştırılacak instruction adresini gösterdiği için aslında doğru adresi gösteriyor. Herhangi bir problem yok burada. If Burada sayılar and continu program wells. How about we go back to the beginning again load and this time we will do a very simple two instruction program increment accumulator. Jump to the begin. Eee, bu şeyin linkini ben size şöyle paylaşmış olum arkadaşlar. Hani, eee, merak edenler geri kalan kısmını da, eee, şurada chat kısmından paylaşalım. Bununla ilgili başka örnekler de bulabilirsiniz. Eee, yani ilk bilgisayarlarda programlama aktiviteleri bu şekilde gerçekleştirilmekte. Yani, eee, bu katlı sistemlerden biraz daha hallice switch'ler üzerinden her bir, eee, instructionın memory adres yani, eee, storage program e computer diyoruz ya arkadaşlar. Yani storage program dediğimiz şey işte bu her bir instruction'ın memory eee, instruction bazında store edildiği sonra işte başlangıç adresi baz alınarak program countera o adresi verilerek satır satır eee ya da struction instruction çalıştırıldığı durum eee Bu işte günümüzdeki bilgisayarlarında aslında çalışma mantığı. Tabii artık klavyelerimiz, mouse'umuz, dokunmatik ekranlarımız vesaireyle ve ID dediğimiz işte çok daha gelişmiş eee uygulamalar vasıtasıyla eee çalıştırılabilir uygulamalarımızı yazıyoruz. Şimdi isterseniz eee ne yapalım? Yarım saate geçtik çoktan değil mi? 45 dakika olmuş. Evet. Neyse video bizi biraz Böyledik. PDP 8 eee PDP 8 dediğimiz makine aslında ilk programlanabilir eee bilgisayarlardan. Eee daha sonrasında biliyorsunuz bu model üzerinde C programlama dili geliştirilmiş oldu. Eee bu da PDP 8'e ait bir hafıza modülünün içeriği görülmekte. Şimdi eee temel bilgisayar elementlerine bakacak olursak burada eee işte gate dediğimiz ve memory sell dediğimiz bir yapı var. Bunu eee dijital dizayndan hatırlayacak olursanız eee sequential eee circuitler içerisinde hem gate'ler hem de memory seller vardı. Gate'lerin özelliği bir inputunuz ve bir output'unuz var ve ekstradan bunu bir activate edebildiğiniz bir eee kısım var. Daha doğrusu enable dediğimiz bir kısmınız vardı. Eee memory kısmı login memory kısmında ise eee artık bir hafıza birimimiz gelen bir inputu okuyabilir ya da eee bu inputu dışarıya eee yani read olarak dışarıya verebilir. WR modunda da içerisinde saklayabilir bir yapıya sahipti. Eee şimdi bu yapı bize integrated circuitların oluşmasını sağlıyor. Integrated circuitlar içerisinde bizim neyimiz var? İşte aslında teknik açıdan bakacak olursak wafer dediğim bir yapı var. Eee bu woffer aslında silikondan oluşan bir mekanizma. Eee bir materyal içerisinde eee milimetre²are mertebesinde küçük eee birtım işte hücreler bulunmakta. Bu hücrelerin içerisinde çipreleriniz yer alıyor. Çiplerin içerisinde gate'ler eee bu e gate işte eee birleşecek daha doğrusu bu gate'lerde aslında pek çiplerden oluşmakta. Şimdi eee bu yapı işte eee uzun yıllar boyunca eee bu şekilde kullanıldı. Eee işte Intel'in de eee kurucusu oldu. Eee eee isim şu an tam aklıma gelmiyor ama eee hadi bana hatırlatın arkadaşlar. Bir an aklımdan gitti. Mur Gordon Mur. Evet. Eee, MUR yasasının sahibi. Eee, aynı zamanda İntel'in kurucu ortaklarından. Eee, Mur yasası dediğimiz şey nedir peki? Mur yasası eee, işte 1940'lardan işte ilk eee, bu transistörle başlayan serüvenden itibaren, second generation computerlerden itibaren günümüze kadar eee, bir işlemci içerisine yerleştirilen transistör miktarının her yıl eee ikiye katlanacağını öngören bir yasa aslında bu. Eee 2000'li yılların başlarına kadar doğru bir şekilde evet çalıştı ama ardından eee bunun bir de eee işlemci hızları ile ilgili olanı var yine MU yasasının. O artık eee geçerli değil. Eee daha önce işte daha çok transistör yerleştirildikçe hız da yine aynı oranda artmaktaydı ama günümüzde daha çok transistör sadece MT 1'den fazla da çekirdek için eee bir artırma sebebiyet veriyor. Hız konusunda birtım limitlerimiz bulunmakta. Eee evet bundan bahsettik. Eee 1960'lara gelildiğinde IBM firması, IBM'de Business Machines'in kısaltılması bu arada arkadaşlar IBM firması IBM 360 sistem modelini tanıtıyor. Eee bu Bu aslında ilk family eee prosesör sistemi yani artık eee benzer mimariye sahip olan eee bilgisayarın ticari olarak üretilip satıldığı eee modeller. Şimdi bir family'den kastımız ne? Eee family'den kastımız benzer ya da identical instruction sete sahip olması. Şimdi mesela günümüzdeki işlemcilere biz eee aynı aileden eee olmasını söylediğim izde neyden bahsediyoruz? İşte eee jenerasyondan bahsediyoruz mesela işte 10. jenerasyon işlemci. Şimdi bu 10 jenerasyon işlemcilerinin ortak özelliği ne? Aynı ya da benzer struction sete sahip olmalı. Tabii günümüzde bütün instruction setler 64 bit ama eee kendi içerisinde de işte atıyorum bir anakart işte aynı jenerasyon, aynı family içerisindeki eee işlemciyi desteklemekte. Sizin o family, o aile içerisinden başka bir işlemciye de o anakartınız destek verebilir. Eğer işlemciyi değiştirmek isterseniz bu tarz özellikler eee yani mimari ve organizasyon özellikleri eee benzerlikler gösteriyor bir aile içerisinde. Eee dolayısıyla benzer işletim sistemleri eee bu donanım üzerinde çalışabiliyor. Birbirine yakın eee işlemci hızları var. Tabii burada mesela şu da önemli. Atıyorum günümüzdeki bir 4 GHz işlemci ile bundan 10 sene önceki 4 GHz işlemci arasında tabii ki bir fark olacak. Bunun sebebi aynı family ait olmamaları. Yani 1ci jenerasyon 4 GHz işlemci ile 10 jenerasyon 4 GHz işlemci arasında tabii ki dağlar kadar fark olacak. Dolayısıyla eee aynı family içerisinde eee işte 4 GHz de 3,5 GHz zaten o hız farkını çok fazla biz fark etmiyoruz ama bunlar birbirine yakın hızlar aslında ama jenerasyon değiştiğinde bu hız farklarını daha ciddi bir şekilde hissediyoruz. Çünkü jenerasyon değiştiği zaman işlemcinin alt birimleriyle ilgili özellikleri de değişiyor. İşte keş miktarı değişiyor. Bas hızı değişiyor. Pilsasi Express'teki lane destekleri değişiyor vesaire. Tüm bunlarda bu overall quality dediğimiz, overall speed dediğimiz eee tümleşik hızı etkileyen faktörler. Bir de tabii eee bir aile içerisinde yine yani aynı aile içerisinden bahsedecek olursak e aeroport sayısı da giderek eee artmakta. Eee memory kapasitesi artmakta. Eee tabii bu artışlar beraberinde eee costu da eee artırmakta. PDP'te bu nasıldı diye bakacak olursak PDP bu probleme çözüm olarak işte BAS structur'ını devreye koyuyor ki günümüzde halen BAS structureı kullanılmakta. Yavaş yavaş artık son jenerasyon la birlikte bu BAS structurından yavaş yavaş vazgeçilmeye başlandı bu arada. Çünkü BAS mimarisi eee ortak bir yolun perifheral device tarafından kullanıl ını sağlıyor. Yani sizin biro modülünüz var, işte hafızanız var, işlemciniz var, farklı işte controllerlarınız var. Bunlar arasındaki iletişim eee bir common bass üzerinden genel bir işte data işte bu mimarilerde bu adres bas, databas, control bas şeklinde farklı bas türleri var. Bunlar üzerinden sağlanmaktaydı. Ama günümüzde artık bu ortak kullanımın getirmiş olduğu birtım işte botleneck dediğimiz dar boğazlar var. Eee bu dar boğazlar ne? Kimidi? Yani bu zaman içerisinde bu Basa bağlı olan birtım cihazların teknolojileri diğerlerine göre daha hızlı ya da daha yavaş gelişti. Bu da eee onların aynı bas üzerine bağlandıklarında, onların aynı baz üzerine bağlandıklarında eee aynı bas üzerine bağlandıklarında performanslarında sorunlar yaşanmasına yani sebep verebiliyor. İşte daha fazla veri iletişimini gerektiren daha fazla eee bandwid ihtiyac olan birtım modüller eee bu durumda o bası yeterince verimli bir şekilde kullanamıyorlar. Bu bunun için de işte eee doğrudan bağlantı dediğimiz günümüzde eee bu cihazların eee hatta CPU core'larının birbirine doğrudan bağlanması eee söz konusu. İşte kimi zaman Thunderboltisiyle kimi zaman eee Unict Padlerle yani iki eee cihaz arasında dedicate edilmiş lane dediğimiz o yapılar sayesinde, kablolamalar sayesinde doğrudan bağlantılar ile artık iletişim sağlanmakta. Bu da eee verinin çok daha hızlı bir şekilde bir noktadan başka bir noktaya iletilmesini sağlıyor. Tabii eski sistemlerde günümüze kadar gelen sistemlerde bas mimarisi çok yaygın bir şekilde eee kullanıldı. Halen de dediğim gibi halen de kullanılıyor. Fakat muhtemelen önümüzdeki 10 yıl içerisinde artık bas mimarisi yavaş yavaş eee yerini eee dedicated hatlara bırakmış olacak. Zaten günümüzde Biliyorsunuz işlemciler artık eee GPU'ları da kendi yanlarına çeker. Eskiden GPU da eee işte bridge'ler üzerinden, VAS üzerinden bağlanan bir eee device'tı. Ama günümüzde artık biliyorsunuz işlemciler eee kendi içlerinde kendi eee GPU'larıyla beraber gelmekler. Kendi GPU'larına doğrudan eee bağlantı hatları bulunmakta. Bunların hepsi artık bu performansın daha da ileriye götürülmesi için organizasyon eee değişiklikleri Aslında sonraki jenerasyonlara bakarsak sonraki jenerasyonda artık tabii bu aşırı hızın birden artması, transitör sayıların çok fazla artmasıyla birlikte işte large scale, large scale, ultra large scale derken artık isimlendirme de kalmadı. Eee burada hızlı bir işte bu semiconductor hafızalarının hızı gelişimi, transistör sayılarının boyutlarının giderek küçültülmesi, nanosale'de bu işlemlerin gerçekleştirilmesi derken eee Burada artık eee herhangi bir isimlendirme de kullanılmıyor. Eee artık son jenerasyon diyebiliriz. Günümüzdeki işlemcilere birçok jenerasyon geçti. Eee ama bunlar içerisinde bazı hani mihk taşı dediğimiz çok önemli olan gelişmeler var. Örneğin eee mesela burada görselde görmüş olduğunuz işlemci ıntel firmasının geliştirmiş olduğu ilk işlemci. Inıntel 4004 işlemcisi 4000 lik bir eee prosesör sadece 4 bitlik eee sayılar üzerinde eee çarpma işlemini ve toplama işlemini yapabilen bir işlemci. Bu intelin ilk işlemcisi. Bakın 4 bit dediğim şey 16'ya kadar olan sayılarda işlem yapabilir demek. Oldukça kapasitesi sınırlı. Fakat tabii 1970'lerdeki ilk işlemci bu. Daha sonra işte e yine 800le 8 bit olanı 1974'te de 8080'le artık daha fazla sayıda eee transistöre sahip olan versiyonu gelişiyor. Tabii buradaki isimlendirmeye dikkat edecek olursan işte 4004, 8008 daha sonra 8080 ve ardından aslında 1900 eee 78'di. Ben öyle hatırlıyorum benim doğum tarihim olduğu için 1978'de 8086 işlemciyi üretecek ıntel ve bu 8086 belki günümüzde çok fazla sayıda halen duyuyorsunuzdur 8086'yı. Çünkü daha sonraki bütün jenerasyonlar tarafından ortak olarak kabul edilen bir instruction sete sahip olacak bu 8086 işlemci. Evet. Şimdi 8086 işlemcinin eee bir diğer özelliği de artık 16 bitlik bir bass bit'e sahip olması yani işlemci wordlerinin 16 bit uzunluğunda olması. Eee 16 bitlik uzunluk günümüzde bile halen birtakım simülantörler üzerinden yine çalıştırılabilir. Günümüz işlemcileri 8086ction setini artık eee hani bu Bu arada 8086 x86 olarak bilinen değişruction seti yani aynı şeyden bahsediyoruz. Eee günümüzde 32 bit olan işlemciler halen bunu desteklemekteler. Eee ama eee 32 bitin net karşılığı 80 300 86 ya da eee direkt 386 işlemciler olarak da geçmekte. Onlar aslında 32 bit. Eee bu 8086 serisi 808'de işte 8 bite düşmesine rağmen daha sonra 82 186'lar vardı. Benim öğrenciliğim zamanında 80286'lar yine 16 bitlik işlemcilerdi. Eee ardından işte 386'lar geldiğinde işte 32 bitlik eee single ve double eee precision işlemleri yapabilen 386 makineleri geldi. Sonra işte evet burada gösteriyor zaten. 286'lar 16 bitlik, 386'lar eee 32 bitlik seri. Ama bunun dediğim gibi SX ve DX eee serileri var. DX'lar double olanlar onlar 32 bitlik kapasiteye sahip. Standart olanlar da 16 bitlik. Aslında 80286'nın biraz gelişmiş versiyonuydu 386x'ler. Eee ardından ise eee 89 yılında 486'lar geldi. Bu arada eee 586 olarak bilinen seri ise Pentium ismiyle yeniden adlandırıldı. Daha sonra yani 486'dan sonra 486'lar zaten artık 32 bit. Yani 486'dan sonra artık 16 bit kal. kalmadı. Eee, 486. Tabii 32 bit olunca dikkat ederseniz yani 32 bit'in sınırı olan addressible memory kısmı 4 GB'a çıkıyor. Burada dikkat ederseniz 16 bitte bu 16 MB la'la sınırlı. Yani aslında buradaki sayılar direkt birbirinden üretilebilen sayılar. Bu da eee 4 GB'lık bir sınıf var. Eee, bunun dışında eee yine 486 SX'ler de artık eee single olanları da 32 bit'e çıkmış oluyor 91'de. Ve 586 dediğimiz 686 786 diye bir dönem devam eden Pentium serileri. Burada artık Pentium serisi ile birlikte arkadaşlar aslında bilgisayar işlemcileri üzerine eee soğutma mekanizmaları gelmeye başladı. Yani burada Pentium serisiyle beraber 9395'lerle birlikte artık bu 60 MHz'lik hız işlemcinin ısınmasına yol açıyordu. Çünkü bundan önceki serilerde bu işlemcilerin hiçbirinin üzerinde herhangi bir fan soğutma mekanizması da öyle bir şey bulunmamakta. Eee çünkü yani bu hız oldukça 6 MHz, 16 MHz, 25 MHz. Bunlar oldukça düşük hızlar. Eee, düşük hızlarda çalıştığı için, düşük frekanslarda çalıştığı için de eee, herhangi bir ısı oluşumu eee, bulunmamaktaydı. Ama birden işte 16 MHz'ten 60 MHz'e işlem cihazları ve 166 MHz'e kadar turbo loklarında çıktığı zaman eee, ısınma ortaya çıktığı için artık işlemcilerle birlikte, box işlemcilerle birlikte eee, fanlar da eee, beraberinde gelmeye başladı. Artık bundan sonra arasındaki seviyelerin hepsinde eee soğutucuyla beraber eee işlemçiler geldi. Burada eee ilk önemli eee atılımlardan bir tanesi de bu Pentium Pro serisidir arkadaşlar. Burada eee 64 bit'e bir geçiş var. Bakın 1995 yılında yani 64 bit çok eee yeni bir teknoloji değil. 1995 yılında Pentium Pro serileriyle 64 bit desteği gelmişti. No 64 GB'lık bir Aslında daha fazla da olabilir ama 64 GB'lık bir eee addressible memory sahipti bu. Ve daha da önemlisi L1 ve L2 CAS olarak adlandığımız işte daha sonraki haftalarda göreceğiz. Eee ön belleklerimiz artık eee büyük boyutlarda yani 512 KB ve 1 MB'lık CASŞ 1995 yılı için eee oldukça eee güçlü hafıza birimleri. Eee ardından zaten eee işte bu 512'ler standart olmaya başlayacak ve artık megab'lar mertebesine yavaş yavaş geçiş sağlanacak. İşte 2000'li yıllara geldiğimizde Pentium 3 ve 4 serileriyle işlem e ilk Pentium 4'lerle birlikte GHz işlemciler ortaya çıkıyor 2000'li yıllarda. Eee tabii burada eee casş miktarımız da yavaş yavaş da 2006'da yine bir eee atlama var arkadaşlar. Burada family yine değişiyor. Yani Pentium serisinden core to dediğimiz Artık şuradaki şu hızdaki limitasyon nedeniyle artık çift çekirdekli işlemcilere geçiş başlıyor. Çift çekirdekli işlemcilerle birlikte her bir çekirdek başına düşen keş miktarı artmakta ve ardından eee işte bu bir sonraki family gelerek hem Cers bazında hız artışı hem trans sayısında hız artışı hem cashş sayısında hız artışı vesaire gibi. sonuçlar doğuruyor. Şimdi burada eee tüm bu yapılar içerisinde 8086'nın ya da X86'nın özel bir eee yeri var. Çünkü dediğim gibi eee neredeyse bir decade boyunca yani çok uzun bir süre boyunca desteklenen backward compatib açısından desteklenen bir instruction set. Eee yani şöyle bir özet geçecek olursak da işte eee burada 80386 ile 32 bitlik makinelar geliyor. Eee 80 586'larda da 64 bitlik makineler bize tanıtılmış oluyor. Eee bir de bunların dışında arkadaşlar bunlar bizim hani general purpose computer tarafındaki, eee durumlar. Bir de embeded sistemler biraz daha dedicated eee elektronik cihazlar. Yani işte kamera gibi. İşte burada görsellerde gördüğünüz hesap makinesi, cep telefonu, çamaşır makinesi, fotoğraf makinesi, mikralga fırın, bulaş makinesi tüm bu tarz belli bir amaca hizmet eden eee elektronik ürünler embed sistemleri olarak geçmekte. Yani bu bu sistemlerin içerisine bilgisayar koyamazsınız arkadaşlar. Çünkü üretim maliyetlerini aşırı yükselteceği için bunlara elektronik kartlar işte type the coul dediğimiz eee sistemler bunlar eee elektronik kartlar yerleştirerek sadece istenilen fonksiyonu yapma özelliği getiriliyor. Bunun dışında hani bir general purpose dediğimiz o genel amaçla kullanıma yönelik özellikleri bulunuyor. Her ne kadar günümüzde artık eee çamaşır makineleri de internete bağlanıp size mesajlar gönderebilse de hani genel amaçlı olanlarından eee bahsedelim. Yani sadece çamaşır makinesi olarak kullanan bir alet içerisinde sadece bir embededit eee kart var. Bu embedited kart içerisinde de sadece çamaşır makinesinin fonksiyonlarını getirecek birtım özellikler bulunmakta. Yani genel olarak bir eee embet sistemden bahsedecek olursak bir işlemci etrafında yine bir mikrocontroller gibi yani bir kendine ait bir hafızası olan, kendine ait bir mantık kısmı olan, bir input output sistemi olan ve genellikle analogdan dijitale ve dijitalden de analoğa dönüşüm sağlayan çünkü bu eee aletlerin muhtemelen birtım sensör okumaları ve yazma ihtiyaçları bulunacak. Bunları sağlayan yapılardan oluşan eee bir eee organizasyona sahip embededit sistemler. Şimdi arkadaşlar eee evet 3 dakika kalmış slaytları hız Hızlıca bitirebileceğiz gibi. 66 slayt var. 57'deyiz bu arada. Hızlıca bitirip eee bu introduction kısmını bugün bitirmek istiyorum. Yarın yeni konuya geçmiş olmamız gerekiyor. Şimdi bir de IoT dediğimiz de bir tane dersimiz var. Böyle internet of thinks eee kavramı var. Internet of things dediğimiz şey ise eee yani information technology, operational technology bunların birleştirilmiş hali. Eee internet of things de sizin birtım cihazlarınız eee internet üzerinden eee belli merkezlerle iletişime geçip birtım işlemleri yapabiliyorlar. Birtım kontrolleri yapabiliyorlar. Bunlar aslında embed sistem gibi de düşünebiliriz. Eee yapmış olduğu işlem işte tek bir lamba bile kendi başına IOT cihazı olabilir. İşte o lamba sizin uzaktan kontrolünüze izin veriyorsa ya da okuduğu birtım verileri size gönderebiliyorsa bu sizin için bir IOT eee cihazdır. Eee IOT cihazların kendine ait bir programlama teknikleri vesaireleri oluyor. Onu anti dersinde daha detaylı bir şekilde görürsünüz. Embedit kısmında eee az önce bahsetmiştik. Yani bir eee bizim işte prosesörümüz var. Bu prosesöre bağlı şurada görmüş olduğ aslında şu ifadenin şu figürün biraz daha değişiği şu figür. Eee yani bir mikrocontrollera benziyor. Microcontroller nesi vardır? İşte kendi sadece bir işlemci değil bu. RAM, ROM, approm timer işte portlar, converterlar bütün bunların eee bütün halinde olduğu ve işte bacakları vasıtasıyla da input output işlemlerini gerçekleştirdiği yapı bir mikrokontroller yapısı. Benzer durumda yani çok farklı işlemci türleri var arkadaşlar burada hani eee işte mikrokontrol içerisindeki işlemci de olabilir. İşte bu e X86 mimarisine uygun bir işlemci de olabilir. Ya da işte risk eee mimarisi dediğimiz reduced instruction set computer yani instruction seti daha simplify edilmiş daha daha basitleştirilmiş instructionların olduğu. Örneğin ARM buna bir örnek accorn risk machine olarak geçiyor. Eee işte mesela ARM ürünlerinde işte en bilinenleri işte cortexir belki hani cep telefonu vesaire aldığınız zaman yardımcı işlemcilerin genelde işte cortex işlemciler olduğunu görürsünüz. Eee genellikle cep telefonu gibi eee mobil cihazlarda eee ARM işlemciler oldukça yaygın şekilde kullanılmakta. ARM yine risk tabanlı bir işlemci. Eee, yani mikro e mikroprosesör ve mikrocontroller beraber beraber düşünebilirsiniz burada. Eee, bu accon risk machine eee ve aslında oldukça da performanslı bir işlemcidir. Yani düşündüğünüz zaman eee, yani karşı tarafındaki general purpose CPU'larla karşılaştırdığınız zaman yani complex instruction set complex disk olanlarla karşılaştırdığınızda hani reduced olmuş olması daha kırpılmış. olmuş olması onun daha eee az eee performansı olduğunu göstermiyor. Yani bugün cep telefonlarımızın işlemci güçlerine baktığınız zaman yine GHz mertebelerinde oldukça güçlü işlemciler. Hatta çoğu laptoptan daha güçlü eee mobil eee cep telefonlarımız bulunmakta. Eee dolayısıyla risk işlemciler aslında eee hafife alınacak basit işlemciler değil. Oldukça güçlü ve özellikle güç tüketimi açısından son derece başarılı eee işlemciler. ARM ARM işlemcileri bu arada yine e işte Apple'ın ürünlerinde de işte iPod'larda, iPhone'larda vesaire onlarda da yine biliyorsunuz cortex şeklinde eee bulunan işlemciler. Yani o e mobil tarafta ARM işlemciler oldukça eee popüler bir işlemci grubu. Eee evet burada bir tane cortex işlemcinin, eee genel görüntüsünü görüyorsunuz arkadaşlar. Bunların içeriğine vesaire girmeyeceğim. Sadece bugün şöyle bir eee geri kalan slaytlara şöyle bakayım. Eee ne var? Cloud competing. Evet. Cloud computing. Yine şimdi cloud computing içerisinde birçok farklı seviye var arkadaşlar. Yani cloud computing'i networking amaçlı kullanabilirsiniz, storage amaçlı kullanabilirsiniz, bir servis sağlamak amaçlı kullanabilirsiniz. Bir altyapı oluşturmak amaçlı kullanabilirsiniz. Eee cl Computing'in çok farklı dediğim gibi, eee, kullanım amaçları var. Eee, şimdi normal bir uygulama geliştirdiğiniz zaman geleneksel mimaride işte eee, networkinginizi ayarlamanız gerekiyor. Sunucu donanımınızı, işte kapasitesini vesairesini ayarlamanız gerekiyor. İşletim sistemini, veri tabanını bağlantılarınızı, veri tabanınızın işte konfigürasyonunu yapmanız gerekiyor. Bir program yazmışsanız işte run time'ını, compilerlarını, uygulama framework'ünü ve de uygulamaları kurmanız gerekiyor. Yani geleneksel eee IT mimarisinde eee yapmanız gereken bütün işlemler bunlar. Ama eee cloud computing devreye girdiği zaman işte eee infrastructure as a service eee platform as ve software aslinde farklı türler var. Yani siz eee mesela software as a service'e bir tane eee örnek verelim. İşte Google Docums. Mesela siz bir Word docümanını bir browser içeris açıp editleyebiliyorsunuz. Bunun için eee işte Microsoft'un Office productlarını ya da Microsoft Word'ü bilgisayarınıza kurmanız gerekmiyor. Dolayısıyla eee burada e mesela networking'le uğraşmadınız, storage'le bunu kaydetmeyle uğraşmıyorsunuz. Çünkü bulut üzerinde sizin kendi hesabınıza kaydediliyor. Donanımla vesaire uğraşmıyorsunuz. İşletim sisteminden bağımsız, uygulamadan, compilerlardan, her şeyden bağımsız bir yapınız var. Sadece browsera sahip olmanız. Yani o ürünü kullanmak için ister Linux'te bir browser için hangi browser olduğu da çok önemli değil. İster Windows platformunda browser açın, ister Safari'de açın fark etmiyor. Size bu software cloud computing üzerinden sağlanmış oluyor. Bu sistemde SASA yani software as a service deniyor. Bir kısmı ise e platform ya da infrastructure. E infrastructure olduğu zaman sadece işte işletim sistemi ve virtual machine size sağlanıyor. Örneğin siz bir eee internet sitesini eee işte eee sunmak istiyorsunuz. Bir internet sitesi hazırlayacaksınız. Tabii eee CS tarafından eee yani bu CSP dediğim şey clut service vardı. Bulut servis sağlayıcısı tarafından size bir eee virtual sanal bir makine veriliyor. Bu sanal makinenin bir işletim sistemi var. Size onfly bu hazırlanmış oluyor. Siz isterseniz bunun üzerine ister MSSQL serverı kurarsınız, ister MySQL serverı kurarsınız, PostQ serverı kurarsınız. Geri kalan kısım client tarafından bakın geri kalan installation'lar client tarafından gerçekliyor. Bu infrastructure as a service dediğimiz yapı. Bir Bir de platform as a service var ki size platformun tamamını veriyor. Yani siz bir web diyorsunuz ki ben işte PHP ile bir web sitesi hazırladım. MyosquL'ile bunu kullanacağım. Ben böyle bir eee platform istiyorum. Eee hani web siteniz hazır, PHP kodlarınız hazır, işte database bağlantıız vesaire hazır ama bunun koşacağı bir platforma ihtiyacımız var. Bu durumda da PAS'e eee geçiş yapmanız gerekiyor. Burada artık size işletim sistemi, sanal makineniz işte SQL Servus konfigüre edilmiş bir şekilde ya da kullanacaksanız işte e işte PHP için compiler vesaire her şey eee platform üzerinde mevcut. Siz sadece kendi applicationınızı yani client tarafından yapılması gereken şey sadece o web sitenize o dosyaları koymak ve bağlantıları düzgün bir şekilde sağlamak olacak. Yani bulut sistemleri günümüzde oldukça popüler. Birçok firma yani bulutun en büyük avantajı biliyorsunuz eee decentralized bir yapıyı centralized bir yapıya dönüştürmesi yani merkezileştirmesi. Eee atıyorum mesela daha önceki Daha önceki teknolojilerde işte atıyorum eee Microsoft bir Office ürününde bir hata olduğu zaman eee bununla ilgili bir fix yayınlar. İşte bütün dünyadaki bilgisayarlar bir şekilde zamanı geldiğince regionına göre, bölgesine göre o fixi, o update'i farklı zamanlarda alırlar ve güncellemeler yaparlar. Kendi bilgisayarlarında güncellemeler gerçekleşir. Tabii çok farklı sistemler olduğu için kimi zaman bu güncellemeler farklı problemlere yol açar vesaire. Ama böyle bir süreç yıllardır kullandığımız güncel teknolojisi eee böyle bir işte ota update dediğimiz yapı aslında eee on the air yani bir şekilde eee otomatik olarak bu update'ler gerçekleşiyor ama biraz problemli bir update mekanizması bu. Eee cloud computing'de ise eee merkezi bir yapı olduğu için işte Google Clouds'u düşünün. Şimdi Google Documans'ı düşünün. Eğer Google eee o Google Documans uygulamasında bir hata olduğunu fark ederse merkezi bir şekilde uygulamasını günceller ve browseren bağlanan herkes bu yeni güncel halini kullanmış ol. Yani kimsenin yeni bir şeyi install etmesine, update etmesine, güncellemesine ya da bunun peşinden koşmasına gerek kalmıyor. Merkezi bir şekilde eee yönetilebiliyor. Bu cloud continuin aslında en büyük eee avantajı eee diyebiliriz. Sanırım bu kadardı arkadaşlar. Şöyle bakayım. Evet. E şimdi yarın e geri kalan kısımdan devam ederiz. Chapter 2 ile. Böylelikle yine onak olduk. Bakalım. bu operasyona bakıyorduk. Eee, B2 eee 50 B 2 58 şeklinde eee, decode edilen bir instruction. Bu B instruction'ı B op koduna hemen şuradan bakacak olursak E B kodu RXY formatında bir operanda varmış. Diyor ki, "Jump to the instruction in the memory sell XY register Evet. Yani yapmış olduğu işlem eğer R2 registerı içerisindeki değer R0 burada belirtilmemiş ama standart olarak ona bakıyor. Default olarak R0 register içerisindeki değere eşitse program counter değerini 58 ile update et. Başka bir deyişle yani high level bir programlama dilinde bunun karşılığı şu arkadaşlar. If R2 eşittir R0 registerıysa bu durumda eee program counter registerınaaki 58'i ata. Aksi halde e program counter zaten bu instruction'ı çalıştırdığı için bir sonraki instruction'la çalışmasına devam edecek. Yani burada program counter'a bir müdahale var. Bu arada program countera normalde biz müdahale edemiyoruz arkadaşlar. Program counter'a eee Bu şekilde uygulama içerisinde bir müdahale var. Yani siz bir programı debug ederken elinizle eee reg yani register değerlerini işte Vis Stud da görebilirsiniz ama eee orada eee diğer general purpose registerlara istediğiniz gibi müdahale edebilirken program registerla müdahale edemezsiniz. Hakkınızda bulunsun. Şimdi eee bunun memorideki gösterimine bakacak olursak eee şimdi burada tabii eee her bir Hücre 1 byt'lık bir veriyi saklamış. Nibell'ar şeklinde. 1 5 6C yani burada aslında 1 5 6 C. Burada bigendiğin eee bir gösterim tarzı var. Yani 10 önce 1 5 eee daha sonra da 6 pardon şurası da CC kısmı yapılmış. Sonra 16 eee 6D instruction'ı var. Ardından 506 instruction'ı var. Ardından 30e instruction'ı var. 36E şeklinde instruction var. Ardından da zaten halt komutumuz C00. Bu tarz gösterim arkadaşlar eee Bigendin gösterimi. Bigendin gösteriminde endiinin temel olarak iki farklı türü var. Bir eee big endian bir de littlean dediğimiz eee tür endi olarak da geçiyor. Eee burada E bigendini kullandığımız zaman önce high order byte'ı memoryde saklıyoruz. Eee little ending olduğunda önde önce low order byte'ı memoryde saklıyoruz. Yani işte bu 15 6C gibi bir rakamımız varsa önce 15 sonra 6C'yi kaydetmişsek bu weekendin önde önce 6C ardından 15'i kaydetmişsek bu da e littleğine karşılık gelmekte. Farklı programlama dilleri, farklı donanımlar, farklı NDN standartları desteklemekte default olarak ve bu dolayısıyla bu tarz cihazların ya da uygulamaların birbirleriyle iletişimi sırasında eee endiyenizm türlerinin eee sabitlenmesi, standarda dönüştürülmesi ya da işte convert edilmesi gerekmekte. İşte motorala işlemcilerinkisi ayrı, ıntel işlemcilerinkisi ayrı vesaire eee farklı endenizme sahipler. Eee evet şimdi, eee perform the fetch step of the machine cycle. Fetch instruction işte ne yapıyoruz? İşte bigendiğim formatta da o 15 6C var. Bunu bakın 15 6C şeklinde instruction registera yerleştirmiş oluyoruz. Program counterumuzdaki değer A0. Bu nedenle A0 adresinden veri alıyoruz ama dikkat edin A0 adresinde sadece 15 var. Biz burada eee buradaki 2 byt'lık kısmı alacağımız için eee altındaki 6c olacak. Başka bir ifadeyle bu instructionı aldıktan sonra program counter değerimiz A1'i değil A2'yi göstermeli. Eğer A1 gösterirse hata olur. H bakın bu bir sonraki işlemde A2'yi göstermiş durumda. Bu durumda 16 6D şeklinde eee değer de yine instruction register içerisine eee yüklenmiş olacak bu işlem yapıldıktan sonra. Evet. Yani bu bu slaytı da göstermek istemiştim aslında. Farklı yıllarda eee hazırladığım slaytlarda farklılıklar olabiliyor. Kimi zaman eee değişiklikleri böyle farklı görseller kullanabilir. Örneğin işte ilk işte transistörün eee invent edilmiş ilk transistörün eee görüntüsü bu şekilde. Bunun dışında şöyle bir bakalım. Ekstra bunlardan bahsetmiştik. Mur yasasından bahsettik. Eee işlemciler, bunların gelişimleri ha genel olarak eee dev eee bit per second cinsinden hızları organization. Evet prosesör trendleri. Bir bunu sözel olarak bahsetmiştim ama görsel olarak belki biraz daha net görmüş olacaksınız. Eee dikkat ederseniz yani şu siyah olan gösterim şu siyah noktaları takip edersek şurada onu Azer Pointer'a göstereyim. Yani şuradaki siyah kısma dikkat ederseniz bakın 2000'li yıllara kadar number of logical cores başlığında eee 10 üzeri 0 yani sadece bir korlu işlemci var. Tek başına tek koru bulunan işlemciler var. Ve 2000 işte 200425'lerde işte Cortodio serileri çıktığı zamana karşılık geliyor aslında. O dönemden sonra artık eee giderek liner bir şekilde artan bir eee core yapısı var. Yani bir çekirdek işleminde birden fazla core kullanılmaya başlıyor 2004'lerden sonra. Eee tüketimlere baktığınız zaman aslında eee bu Cor sayısının artırılmasının aslında tüketimi de bir şekilde balans ettiği ve bir şekilde durdurduğu görülmekte. Yani eee bu core sayısının artmadığı süreçte tek işlemcili eee tek işlemci korunun bulunduğu dönemlerde eee işlemcilerin her yeni nesil işlemcinin bir öncekinden eee daha fazla güç tükettiğini görürken dikkat ederseniz artık Multicore'a geçildikten sonra artık buradaki güç tüketiminin bir miktar artış gösterse de yani 10 yıl yıllık bir süreçte aslında yatayda kaldığını görüyoruz. Bu da aslında hani multicore mimarilerin işte birbirine yakın eee bağlarından eee enerji tüketimlerinin azaltması eeeının sağlandığını görüyoruz. Aslında burada yeşil eee grafiğe bakacak olursak da aslında o da yine benzer durumda. Bakın frekans bilgisini MHz cinsinden frekans bilgisi yani aslında GHz'ler mertebesine 2000'li yıllarda bir şekilde ulaşıyoruz ama ardından işte eee 10 üzeri 3 ile 10 üzeri 4 arasında aki şu aşamada bir şekilde eee işlemci frekanslarının artık daha fazla artamadığını görüyoruz. Onun yerine dediğim gibi eee mantıksal corlar bu dönemde artıyor. Frekans bir şekilde sabit ama core sayımız artıyor. Daha fazla core'la aynı frekansa sahip oluyoruz. Eee single thread performansı. Eee thread dediğimiz şey bir eee bilgisayarın bir uygulamayı çalıştırması. Eee single thread performansı eskiden bir tık daha başarılıyken artık bu MT core sistemlerle bu başarı yine artmakla birlikte bir miktar aslında eee artış hızında azalmaya da sebebiyet veriyor doğal olarak. Eee fakat kullanılan transistör sayısına bakacak olursak MU yasası bir şekilde transitör sayısı açısından halen eee eski eee değerini korumakta. Dikkat ederseniz burada bir regresyon yapmış olsaydık bu şekilde bir doğru elde etmiş olacaktık. Bunun da sebebi tabii logic corlar arttığı sürece transistör sayısı da tabii doğal olarak art mış oluyor. Orada herhangi bir değişikliğe gidilmiyor. Eee burada en dikkat çekici kısım arkadaşlar yani güç tüketiminin artık eee sınırlandırılmış olması. Eee frekansımızın artık belli bir sınırda takılmış olması ama core sayımızın artıyor olması şeklinde özetleyebiliriz. Eee 86'lardan bahsetmiştik. Şöyle bakıyorum farklı bir şey göstermiş miyim diye. Eee spek kısmı var. a* da yasamız var. Amdal yasası arkadaşlar eee bir bunu ben birçok dersimde gösteriyorum. Amdal yasası bir uygulamanın ne kadar hızlandırılabileceğini eee gösteriyor. Eee farklı formüasyonları var ama benim en çok sevdiğim 1/ s + p/ n şeklinde ifade edilen e yani speed up formülü bu aslında ve speed up küçük eşit ol s dersek Speed. Speed diyelim buna. Speed küçük olmalı. 1/ stay kastımız burada eee uygulamanın seri olarak çalıştığı kısım. P'den kastımız burada uygulamanın paralel olarak çalıştığı kısım. N ise eee sistemimizdeki core ya da işlemci sayısı. Şimdi burada eee s ve p arasındaki ilişki şöyle eee p yerine aslında ben 1 - s de yazabilirim. P = 1 - s olabilir. Ya da p ile s'nin toplamı 1 olacak. Yani uygulamanın paralel çalıştığı eee zaman ile seri çalıştığı zaman ihtimalleri toplamı 1 olması gerekiyor. Yani bir uygulamanın %80'i seri çalışıyorsa %20'si de paralel çalışıyor. Bunu böyle düşünebilirsiniz. Şimdi normal şartlar altında speedup dediğimiz değer yani eee speedup bu arada speedup'tan neden bahsediyorum? Speedup bir uygulamayı eee tek işlemcili bir bilgisayarda çalıştırıyorken bunu çok işlemcili ya da mult core bir sisteme taşıdığınız eee ne kadar hızlandırabilirsinizin cevabını bulmaya çalışıyor. Eee burada da standart koşullar altında speedup değeri bir yani yine 1/s/ p/n şeklindeyse işte şurası 0 eee atıyorum eee ne diyelim tamamı seri çalışan bir uygulama için paralel kısmı 0 olacak. 1/ 1 + 0/ 1 şeklinde bir şey olacak bu. Bunun cevabı da 1 olacak. Yani normal şartlarda biz eee 1 gibi bir durumunuz var. Eğer bir uygulamanın diyelim ki eee %80'i seri %20'si paralel çalışsın ve bir tane de işlemcimiz olsun. Şimdi buna bakacak olursak yine sp değeri 1/ 08 + 0 2 olacak. Yani küçük eşittir speedup değeri. Bu da ne oluyor? 1/1 yine 1 değerinden yani bir tane işlemcininiz varsa speed adınız. Bu aslında bizim baseline diye kabul ettiğimiz yani temel eee yani karşılaştırmalarda eee hani günümüz de artık pek fazla kullanılmıyor ama eee nasıl diyelim? Eee eskiden CD yazmak için işte CD yazıcıların üzerinde hız bilgisi olurdu. İşte eee 16X, 24x, 32X, 52X gibi birtım bir x çarpanlar olurdu. Bu da aslında normal standart CD, standart CD yazım hızının ik katında daha fazla hızlı yazabilirsiniz gibi bir anlam vardı orada. Oradaki işte o standart hız gibi. Burada da speed up değerimiz var. Eee bu speedup değeri normal şartlar altında 1. Ama diyelim ki mesela eee diyelim ki bir uygulamanın %80'i yani seri kısmı %80 olsun. Yine paralel kısmı da %20. Bu hesaplamayı yaparken öğrenciler nedense bunu 8 ya da 20 gibi direk alıp sonra eee akım böyle aklımın almadığı birtım spilaf değerlerine ulaşıyorlar. Dikkat etmek lazım. Bunlar ihtimal. Dolayısıyla 1/s kısmında şuraya 08 alıyoruz. Diyelim ki bu siz bu uygulamayı paralel bir sisteme taşıdınız ve eee paralel işlemci kısmında da iki tane çekirdek var ya da iki tane CPU var. Bu durumda eee seriye bakın zaten bulaşmıyorsunuz. Yani paralel işlemcinin seri herhangi bir ekstrası katkısı yok ama paralel kısım olan 02'lik kısmı 2'ye bölebiliyor. Eee, at best diyelim. Eee, dolayısıyla bu da 1/ eee, 08 + 01'den 1/09 gibi bir değere karşılık geliyor. Yani 9/10. O da şeyden 10/9'a karşılık gelecek. Yani 1 küsür eee 1 mi? Öyle o tarz bir eee, hızlanmaya karşılık geliyor. Eee, ya da şöyle soralım. Eee, işte burada eee, maksimum ne kadar hızlandırabiliriz? Bu uygulamayı hani diyelim ki iki tane değil de 20.000 tane işlemcimiz var. Hatta sonsuz tane işlemcimiz var dersek maksimum bunu ne kadar hızlandırabileceğimizi sonsuz dersek burası biliyorsunuz limit n sonsuza giderken bu kısım 0 olacak. Dolayısıyla cevabımız bu durumda 1/s yani 1/08 niyi sonuç alırız. Yani o da 10/8 125 mi olur? Öyle bir şey karşılık geliyor. Yani eee bir uygulamanın paralel işlemci kullanarak ya da işte 6 işlemci kullanarak ne kadar hızlanabileceğini AMDAL yasası sayesinde bulabiliyoruz. Eğer ki uygulamamız bunun tam tersi bir yapıya sahip olsaydı mesela 1/ seri kısım 0 eee atıyorum 0,5 olsun. Paralel kısım da 0,5 olsun ve sizin eee 5 tane işlemciniz olsun. Bu durumda 1/ 0,6 gibi eee bir sonuç elde etmiş olacak ya da 10/6 gibi bir sonuç elde etmiş olacak. Bu da kaç çıkıyorsa Yani bir uygulamayı bu kadar hızlandırabiliyoruz. Bu sonsuz işlemcimiz olsa 1/05'e kadar hızlanır bu. O da eee en fazla iki kat hızlanır gibi bir sonuç elde ediyoruz. Yani istediğiniz kadar işlemciniz olsun. Eee sizin uygulamanızın bazı bağımlı olduğu işte dependency diyoruz. Bunlara da bağımlı olduğu eee veriler yüzünden eee uygulamanın daha hızlı çalışması engellenmiş oluyor. Bu da AMDAL yasası. Elim. Şimdi arkadaşlar şunu kapattık. Eee, asıl bu haftanın konusu komuter sistem nerede? Ona geçeceğim. Evet. Şimdi eee Kom eee komponentlerinden bahsetmiştik. Komutür komponentleri nelerdir? İşte genel olarak bir Wonum arkitecture baktığımız zaman 3 tane anahtar eee komponent bulunmakta. Eee bir memory alanımız var. Burada data ve instructionlar saklanıyor. Yani bizim programlarımız burada saklanıyor. Eee ve bu memoryin içeri eee deki herhangi bir adrese bizim erişim hakkımız var. Yani bu memory içerisindeki herhangi bir lokasyondan biz veriyi erişebiliyoruz. Bir de eee bizim çalışmamız sequential bir şekilde sıralı bir şekilde oluşuyor. Ekstrem bir unconditional jump branch vesaire bir şey olmadığı sürece seri bir çalışma. Zaten bunu biliyorsunuz tüm uygulamalarınızda debug ederken görüyorsunuz. Yukarıdan aşağı bir çalışma mantığınız var. Bunun sadece değiştiği durumlar neler? İşte for döngüleri, while döngüleri ya da işte if, as yapıları. eee ya da gold statement dilde varsa o tarz durumlarda eee bu seri çalışma değişiyor. Eee donanımda artık software programından bahsetmiyoruz da hardwared eee programlardan bahsediyoruz. Burada eee istenilen sonucu elde etmek için birtım kablolamalar üzerinden birtım kablolar üzerinden aslında işlem yapılıyor. Yani integrated circuitlar aslında yine bir software gibi çalışıyor ama eee kodumuzu bir şekilde hardware üzer yazmış oluyoruz. Şimdi bir probleme eee donanım ve yazılım açısından eee yaklaştığımız zaman şimdi software kısmında eee neyimiz var? Bir işte sıralı bir eee kodumuz var. Yani sıralı bir şekilde çalışacağını düşündüğümüz eee bir instructionlarımız var. Bu instructionlar bir instruction interpreter tarafından, yorumlayıcı tarafından eee okunuyorlar, işitiliyorlar ve birtım kontrol sinyalleri elde ediliyor. Bu kontrol sinyalleri eee sayesinde eee verilerimiz bilgisayarın içerisinde bir noktadan bir noktaya eee seyahat edebiliyorlar. Çünkü bu kontrol sinyalleri işte databas'ın eee bir eee o sırada belli bir işlem için dedicate olmasını sağlıyor. Eee ve bu sayede işte eee veriniz memory'den eee aritmetik logic unit içerisindeki işte eee memory buffer register'a gidiyor. Oradan da işte aritmetik logic unit içerisinde aritmetik bir işlem gerçekleştiriyor ve sonuçlar elde ediliyor. Donanımda ise eee donanımda daha çok sadece bizim datamız var. İput olarak datamız var. Geri kalan bütün her şey yani bu aritmetik işlemler, logik işlemler hepsi hardware tarafından programlanmış durumda. Yani bir donanım olarak orada mevcut. Yine sonucu elde ediyoruz. Şimdi bu iki yapıyı karşılaştırdığımız zaman tabii ki de hardware eee olanı çok daha hızlı çalışacak. Çünkü herhangi bir eee ekstra decod için zaman harcamıyor direkt olarak. veriyi alıp çalıştırıp sonuç elde ediyor. Eee donanım kısmında ise işte birtım interpreter dediğimiz eee durumlar var. Buradaki instructionları bizim decode edip anlayıp execute edip sonuçları bir şekilde toparlamamız gerekiyor. Dolayısıyla yazılımda çözüm üretmek mutlaka eee bir miktar daha eee zor aslında. Şimdi eee bu komponentlerde eee buradan bahsettik aslında software eee kısmından yani sarılı bir şekilde instructionlarımız var. Eee, donanım bir şekilde eee, bu instructionları decode ettikten sonra eee, birtım kontrol sinyalleri üretiyor ve, eee, yeni bir program yazmak için sadece structionların, eee, sırasını ya da yapısını, mantığını değiştirmemiz gerekiyor. Yani yazılımı değiştirmemiz gerekiyor bu sistemde. Daha çok general purpose bir sistem bu. Eee, donanımla bunu yaptığımız zaman ise rewiing dediğimiz kablolamanın tüm o elektronik dizayn değişmesi gerekiyor. Dolayısıyla çok daha fazla yük var orada. Eee, ayak komponentlerinin başında CPU eee, gelmekte. Bu temel olarak bir bilgisayar içerisindeki işte structionları yorumlayan kısımımız. Eee, bir de işte aritmetik logic unit, eee, modüllerimiz bulunmakta. Aritmetik logjik eee, unit dediğimiz kısımda eee, biz ne yapmaya çalışıyoruz aslında? Eee, işte aritmetik işlemler tanımlı birtım eee matematik işlemlerinin, logik işlemlerin yapılmasını gerçekleştiriyoruz. Şimdi eee burada daha önce bahsetmiştik. İşte memory address register, memory buffer register, io address register ve i buffer registerlarımız var. Üst tarafta memory ile işlem, alt taraftakiler ise i device'ları ile işlem yapıldığında veriyi kullanıyoruz. Ama her ikisinde de aslında asıl destination'ımız bizim memory buffer register. Bir görsel üzerinden açıklayacak olursak yani CPU tarafında program counter, instruction register, memory address register, memory buffer register, IO address register ve IO buffer register. Bir de execution unitimiz var. Yeşil bölgeli alandan bahsediyorum. IO modüllerinin de kendi içerisinde bufferları bulunmakta. Eee, main memory içerisinde bulunan datalar sistem bı üzerinden ya CPU tarafına ya da modül tarafına bir şekilde gidip gelebiliyorlar. Dikkat ederseniz OKlar eee her iki yön geçerli. Eee burada bir uygulamayı çalıştırmak için ne demiştik bizim? Fetch decode ve Execute cycle'ımız vardı. İşte uygulama başlayınca önce fetch işlemi gerçekleşiyor. Ya mutlaka bizim uygulamamızın structionını e ya hard disk'tten yüklememiz lazım ya ROM'dan yüklememiz lazım ya da e memoryden yüklememiz lazım. Hard disk'tten yüklüyorsak hard disk'tten register içerisine direkt olarak yükleyemiyorsunuz. Hard disk'tten önce memory ardından register içerisinde yükleme işlemi gerçekleştiriliyor. E bilgi zaten memory içerisindeyse direkt olarak e registera yerleştirilebiliyor. Burada eee ilk aşamada eee patch aşaması yani getirme kısmında eee program counterun göstermiş olduğu lokasyondaki bilgi instruction register içerisine aktarılıyor ve e prosesör burada bu register içerisindeki değeri interpret ediyor. Bu interpret işlemini yapabilmek için tabii öncelikle bir onu bir decode edip ne olduğunu anlaması lazım. Hangi operasyon kodlarından oluştuğunu bulması lazım. Eee burada farklı action kategorilerimiz var. instructionlar için bir tanesi eee prosesör ile memory arasındaki eee instructionlar. Burada eee veri prosesörle memori arasında gidip geriye load ve store instructionları örneğin eee prosesörle memory arasında eee veri transferi gerçekleştiriyor. Prosesörle IO device arasında eee ise işte directo dediğimiz bir yapı üzerinden bir veri transferi gerçekleştirilebiliyor. Fakat burada yine memoryin bir kullanımı söz konusu. E bu tabii kullanılan IO device'ın bufferının yeteneğine de bağlı. Kimi IO device'larda buffer bulunmayabiliyor. Bu durumda memory direkt olarak kullanılıyor. Kimilerin ise kendi iç bufferları var. Örneğin hard disk'tten bahsediyorsak hard diskin kendi içerisinde kendi bufferı bulunmakta. Günümüzde işte 1 TB'lık bir disk aldığınız zaman 32 ya da 64 MB'lık bir buffera da sahip olmuş oluyorsunuz aslında ekstra. Eee bir de data processing eee actionları ya da instructionları var. Bunlar eee eee veri üzerinde aritmetik işlemler gerçekleştiriyorlar. Eee kontrol olanları ise eee birtım işte basların eee veri yollarının eee sahipliğinin ya da veri yolunun kullanım hakkının kimde olduğunun eee belirlenmesi için oluşturulan sinyaller. 16 bitlik bir eee örnek burada var arkadaşlar. 16 bitlik bir sistemde operasyon kodu. İşte burada eee 4 bitlik bir operasyon kodu tanımlanmış. Geri kalan eee 12 kısım adres için kullanılmış. Bu instruction formatı. Eee, bir veri sayı formatında ise yine bir sign bit 1 bitlik sign bit kullanılmış. Geri kalan 15 bit ise magnitud için kullanılmış. Şimdi eee bakın bu sayfada aslında çok basit. Yine basit bir sistemden bahsediliyor. Partial list ofcods denmiş. En aşağı kısımda dikkat ederseniz şurada 3 tane instruction'a sahip. Bir bir hypotetical machine yani bu eee sanal bir makine bizim hayal ürünü bir makineden, eee, bahsediyoruz. Ve 3 tane instructionı var. Dedik ki operation kodlar 0 la 3 arasında yani 4 bitlik. Dolayısıyla 4 bitlik operasyon kodlarını görüyorsunuz. 1 nolu kod load AC from memory. Memory'den akumulatör içerisine eee, bir veri yükleme. 2 numaralı kod AC'deki değerin memory yükleme. Tam tersi. 5 numaralı operasyonda eee, AC'nin değerini oradaki değerle toplama. Eee, büyük ihtimal sonuçta yine AC'ye aktarılıyor. Hemen şuradan bakalım. Yani 1, 2 ve 5 nolu structionlarımız var. Şimdi şuradaki örnekte eee bir uygulamanın nasıl çalıştığını görmeye çalışalım. Şimdi bakın eee her bir şu eee dikdörtgen alanı kendi içerisinde değerlendireceğiz. İlk aşama step 1'de bakıyoruz. Program counter içerisinde 300 değeri var. Şimdi memojinin bir Memory'nin eee gösterimi var. Dikkat ederseniz memoryin şurada memory belirtilmiş. 300 301 302 eee ardından devam ediyor. İşte 940 941'in de adresleri vesaire diye bu şekilde devam etmiş. Yani memory içeriği bize görünür durumda. Ve eee step 1de biz program counterdaki değer 300'ü gösterdiği için 300'deki değeri load etmemiz lazım. Onun içerisinde de 1 40 değeri var. Şimdi 1 9 40 değerini bizim eee Önce fç etmemiz lazım. FCH nereye fch ediyoruz? İşte 1940'ı dikkat ederseniz burada instruction register içerisine fech ettik. Buradaki operation cod nedir? 1 numara operasyon. Şimdi 1 numara operasyon neydi? Load AC from memory. Demek ki memory'nin 940 numaralı adresinden eee bilgiyi alıp akümatör içerisine koymamız gerekiyor. Bakın şu an akulatörün içerisi boş. 940 içerisinde hangi değer var? 003. Demek ki bir sonraki aşamada bakın buradaki 003 değeri akumulatör içerisine yerleşmiş oluyor. Tabii otomatik olarak bir sonraki aşamada dikkat ederseniz program counter da auto increment olduğu için 1 arttı. Diğerinde bu 2 artacaktı ama burada bakın tek bir instruction olduğu için memory sellerinde 1 artıyor. 301'e geldik. Şimdi 301'deki instruction'ı fetch yapacağız. Yine fetch decode execute cycle'ı çalıştırıyoruz. 5941 e bizim instruction register içerisine geldi. 5941'deki operasyon kodumuz 5 nolu operasyon add from memory. Eee, dolayısıyla AC'nin içerisine şu an 3 vardı AC'de bir önceki işlemde dikkat ederseniz AC'nin içerisine memorydeki memory'nin 941 lokasyonundaki veriyi ekliyoruz. Dolayısıyla bu ekleme işlemini add işlemi olduğu için 3'e 2 sayısı eklenmiş oldu. Sonuç 5. Yine akumulatör içerisinde bakın burada güncelleme işlemi gerçekleşiyor. Program counter yine 1 arttı ve 302 oldu. Ardından 302 lokasyonuna geldiğimiz zaman 302 lokasyonunda 2941 değeri var. Onu yine instruction register içerisine aktarıyoruz. Eee 2 nolu işlem. 2 nolu işlem şuradan bakıyoruz. Store AC to memory. Yani akümulatörün içerisindeki bu 5 değerinin memory lokasyonu 941'e kayıt edilmesi. Dolayısıyla bu 5 değeri memoryin 941 lokasyonuna kayıt ediliyor ve sonuç artık 2nin şurada 2 varken artık 2'nin üstüne 5 yazılmış oluyor. Bu bir programın basit bir şekilde nasıl çalıştığının eee gösterilmesi arkadaşlar. Bakın 3 tane sadece tane struction'la bir toplama işlemini bir programla nasıl yapabileceğimizi göstermiş olduk. Eee evet şimdi instruction cycle state diyagramımıza bakacak olursak yani daha önce sadece fode, biraz daha alt eee eee seviyelerde alt aşamalarda bulunmakta. Şimdi şurada instruction fetch'ile eee başlayacak olursak eee fetchten sonraki kısım decode ama burada işte instruction operation decoding yapıyoruz. E bu bu instruction add ise şunu yap, store isa şunu yap, load ise bunu yap gibi. Eee o kısmı önce bir eee decode ediyoruz. Bunu yaptıktan sonra bu decode işleminde ortaya çıkan operation kodun operantları bazı alınarak birtım işlemler yapılır. Çünkü kimi zaman operant dediğimiz kısımda immediate bir value dediğimiz direkt olarak bir sayı var. Mesela register 5'e 26 yükle dedik. Yani memoryin 26. adresine gidip oradaki veriyi yükle demedik. Memory'nin 5 numaralı registera 26 diye bir sayı yükle. Sayı olan 26'yı yükle. Bu immediate adresing yöntem. Yani direkt olarak sayıyı biz elden veriyoruz. Böyle bir durumda adres calculation bul maacak. Fakat gidip işte memory'nin 26. adresindeki değeri yükle dediğimiz zaman bu durumda eee memory gidip oradan işte operant işlemi yapılması gerekiyor. Ya da işte bu a = b + c bir işlemse b ve c değişkenlerinin artık bir şekilde memoriden getirilmesi lazım. Burada tabii option şurada belirtilen eee operasyon koduna göre bir veya daha fazla operant olabilir. Çünkü eee OP kodların yanında bulunan operantların sayısı değişebiliyor. Kimi Eee, kimi operationlar var ki, kimi opcodlar var ki sadece bir tane parametreye ihtiyaç duyuyorlar. Kimi opcodlar var ki iki parametreye ihtiyaç duyuyorlar. Kimileri 3 parametreye ihtiyaç duyuyorlar gibi gibi. Eee, dolayısıyla burada eee, opcod türüne göre bir operant hesaplaması yapılıyor. Eğer ihtiyaç varsa operant fetch işlemi gerçekleştiriliyor. Veri hazırlanıyor. Veri hazırlandıktan sonra operandın tekrardan bir adresi, eğer bir store işlemi varsa destination olarak bunun bir adresi hesaplanıyor ve artık kaç tane store işlemi yapılacaksa bu store işlemi gerçekleştiriliyor. Eee eğer bu bir aray benzeri eee birbirine benzer işte homojen yapıdaki hücrelerden oluşmuşsa bu döngü eee şuradan devam ederken tekrardan yeni adres calculationla işte bir iteration dediğimiz yapıya dönüşüyor. Eğer bu işlem bitmişse de instruction execution complete olmuştur. Bir sonraki instruction'ı getirmek için işte instructionın adresi hesaplanıyor vesaire. Program counter'a bakılarak eee fetch instructionıyla eee bu işlem devam ediyor. Şimdi bu süreç yani sadece f decode execute dedik ama fetch decode ve execute eee kısımları eee giderek daha karmaşık hali ulaşabiliyor. Gerçek sistemleri düşünmeye başladığımızda. Yani mesela bunlar içerisine interupları da dahil ettiğimizde bir de eee farklı interrupt türlerinde bu fly code execute cycle'ın nasıl davrandığını yeniden o figürü, flowchart'ı e belirtmemiz gerekiyor. Şimdi interup dediğimiz şey ne? Bu arada interuplar eee bir işlemcinin normal çalışması sırasında normal çalışmasını durduran ve eee buna eee bir eee farklı bir eee uygulamanın devreye girmesini sağlayan yapıya biz interupt diyoruz. Türkçe karşılığı kesme eee bir yerde karşınıza çıkarsa kesme olarak adlandırıyorlar. Eskiden eee interaplar oldukça yani işletim sistemleri açısından oldukça büyük problemlere yol açıyordu. Yani bu interapların yönetimi otomatik değildi eski zamanlarda. Dolayısıyla siz yeni bir ekran kartı aldığınız zaman ekran kartı ya da bir ethernet adaptörü, ethernet kartı aldığınız zaman eee onun kullanmış olduğu interınaptğiyle işte ses kartının genellikle çok sık başımıza gelen bir olaydı bu. Ses kartının interupt değerleri birbiriyle çakışıyor. Dolayısıyla ses kartı bir interap oluşturduğunda ya da internet kartı interap oluşturduğunda bunlar birbirleriyle çakıştığı için bu kartları düzgün bir şekilde kullanamıyorduk. Eee bir anda internetiniz kopuyordu ya da bir anda ses gidiyordu. Eee çünkü bunların yönetimi manuel olarak kullanıcıdaydı ya da default olarak işte 3 noolu interup'ı SS kartı kullanıyor. 4 nolu ının işte Ethernet kartı kullanıyor ama her zaman bu şekilde olmuyordu ve kimi üreticiler farklı interupları standart kabul ettikleri anda bu bir probleme yol açıyordu. Günümüz işletim sistemlerinde bu problem çözüldü. Artık otomatik olarak bu interup kanalları eee belirleniyor. Dolayısıyla bir şekilde çakışma olduğunda işletim sistemi otomatik olarak eee başka bir interıap kanalı üzerinden interupları yönetmeye devam ediyor. Eee bu farklı interap türlerimiz işte program eee interapları, program çalışırken oluşan interaptır. Bununla aslında karşılaşmışsınızdır interaplarda. İşte diyelim ki sıfıra bölünme hatası ile ilavada bir kod yazdınız. Sıfıra bölünme hatası verdi. Diyelim ki hani eee, exceptionları kullanmadınız. Eee, yani throw eee, catch bloğunu kullanmadınız. Eee, o işlemi yaparken. Dolayısıyla o sırada bir hatalı aritmetik işlem yapıldığında onunla ilgili işte aritmetik overflow, division by zero gibi, eee, birtım hata mesajlarını uygulamada görüorsunuz. Yani uygulamanın içerisinde buna dair bir kod yoktur ama eee, işlemci sizde e buna dair bir uyarı mesajı görmeyi zorlar. Eee, bir diğer tür e interup Bu arada e bu program eee interuptlarının eee soft interup kısmı da var. Yani siz eee mesela troll yaparak eee bir exception gönderebiliyorsunuz. İşte bir eee bu aslında eee interup oluşturma için yani programın normal akışını durdurup yeni bir akış yaratmak için bir istek aslında. Hani beklenmediğiniz işte bir dosyayı açıp devam etmeniz gerekiyor ama dosyayı açmak istediğiniz o dosya yok ya da onun dosyaya erişim hakkını çab bir şekilde işte file not found, io exception çıkıyor orada. File not found gibisinden bir şeyle. Çünkü o dosya açılmadan biz daha sonraki işlemlerin hiçbir eee anlamı yok. O dosy okunmadığı takdirde dolayısıyla bir interup oluşturmamız gerekiyor. Kimi zaman programcı kendi isteğiyle intended bir şekilde eee exception oluşturuyor. Kimi zaman ise programın çalışması sırasında bu exception oluşuyor. Eğer genellikle işte io network vesaire tarzı bir takım fonksiyonlar kullanıyorsanız zaten günümüzde programlama dilleri, bu trch benzeri blogları eee kullanmanızı eee zorluyorlar sizi. Yani bu sayede eee bir hata oluştuğunda işletim sistemi yerine öncelikle siz bu hatayı yakalamış oluyorsunuz ve yani proper nasıl davranmanız gerekiyorsa o duruma göre eee işte sıfıra bölünme hatası varsa işte ne yapacaksınız? Eee onu yeni ya yeniden verinin girilmesini isteyeceksiniz sıfırdan farklı bir şekilde gibi birtım çözümleri eee uygulamaya sunabiliriz. Eğer bu interaptları kendimiz yakalayabilirsek, timer interaptları eee bu zaten sıklıkla eee işlemci içerisinde oluşan bir interaptörü. Eee yani bunu scheduler gibi düşünmeyin. Çok daha sık aralıklarla oluşan bir interup. IO interupları io controllerlar tarafından oluşturuyor. Yani IO Controllera verilmiş bir görev varsa bu görev tamamlandığında işlemciyi uyarmak için eee bir terapi oluşturarak istenilen verinin hazır olduğunu söylüyor. IO eee controllerları örneğin eee mesela işlemci direct memory access tekniğinde eee diyor ki işte bana şu dosyayı al. Hard diskin ayı kontrolörüne söylüyor bunu. Yani hard diskin de aslında kendi içinde bir işlemcisi var. E buna coprosesör de diyoruz biz. Eee ona diyor ki bana şu dosyayı al ve gidip memory'nin 3F7DA adresine eee yükle eee Şimdi hard disk'tten bir verinin yüklenmesi işlemi CPU'nun görevi değil. Dolayısıyla CPU o sırada başka işlemlerle execute işlemleriyle devam edebiliyor. Bu sırada hard disk işte artık eee belki o sırada uyuyor, kendini uyandırıyor. Belli bir dönme hızına ulaşıyor diskler. Eğer standart ve hard diske. Ve ardından o dosyaya erişim sağlanıyor. Dosya okunup eee kontrolün bufferlarına yerleşiyor. Ardından o bufferdan memory'nin CPU'nun kendisine söylemiş olduğu adresine bu veri, dosyanın içeriği kopyalanıyor. Bu kopyalama işlemi bittikten sonra a controller bir interup oluşturuyor. Diyor ki eee bana verilen görevi tamamladım. Aradığınız dosya içeriği ilgili bana verdiğiniz adres de mevcut şeklinde bir interup oluşturuyor. CPU de o sırada artık hangi işlemi yapıyorsa o işlemi bırakıp eee memoryda istemiş olduğu bir dosyaya artık sahip. Onları istiyorsa registerlarına aktarıyor ve yapması gereken işlemine devam devam ediyor. Bir diğer interact türü de hardware failerları. Bunlar genelde işte donanımda herhangi bir işte power failer olsun ya da işte bir parity errorleri olsun bu tarz errorlerin ya da işte hard diskinizde ya da bir CD DVD okumak istediğinizde bunu daha sıklıkla karşılaşıyoruz. Eee ilgili lokasyondaki veriyi okuyamıyoruz. Yani şimdi bu bunun için eee donanımın birtım retryı var. İşte 200 defa örneğin hard disk belli bir lokasyondan belli bir veriyi okumak çalışır. Okuyamadığı takdirde artık işitim sistemine intakap göndererek eee ayı eror oluştu. Kullanıcıya bunu bildir şeklinde bir eee noktaya gider ama o ana kadar kendi başına çözmeye çalışır. Y donanım genellikle bu tarz problemleri işte parit error oluşmuşsa örneğin network'ten bir şey indiriyorsunuz. İndirdiğiniz pakette eee işte CRC check yapıldığı zaman bir hata var. Yani paketin eee security bilgisiyle sizin eee size gelen paketin security bilgisini hesapladığınızdaki değer birbiriyle aynı olmadığında demek ki internette bunu download ederken eksik ya da eee problemli bir şekilde indirildi. Yeniden bunun indirilmesi sağlanıyor. Ama bunun için size bir soru sorulmuyor. Siz sadece bunu çoğu zaman eee işte kötü internet bağlantısı olduğu durumda download hızının yavaşlaması şeklinde görüorsunuz. Halbuki aynı paket tekrar tekrar gönderiliyor belki de. Çünkü eee paket gelirken birtım bozulmalar ucuyor ve bu bozulma birtım güvenlik noktalarından geçemediği için paketin otomatik olarak sizden habersizce tekrar an gönderilmesi vesairesi ile eee arka planda birtım işler yapılıyor. Eee bu da bize yavaşlama şeklinde. Çünkü beklediğimiz paket geliyor ama hatalı geliyor. Geliyor ama hatalı geliyor. Ve bu sıklıkla olmaya başladığında özellikle bağlantının kötü olduğu noktalarda veriyi alsanız dahi almış olduğunuz veri bozuk olduğu için bunun tekrardan indirilmesi gibi zaman kaybedici eee problemlerin nedeni olabiliyor. Şimdi bu program, timer, io, hardware failer gibi gruplar Eee, genel olarak bizim eee genel olarak bizim eee problem ler karşısında işte oluşan interaptlarımızın eee olduğu durumlar. Şimdi bu slayda bugün geçmeyelim arkadaşlar. Program flow kontrolü burada eee aslında üç farklı sistem gösteriliyor. Bir sistemde eğer interuplar olmazsa en soldaki örnek bu. Eee interuplar olduğunda şu short io işlemleri olursa yani kısa süreli io işlemlerinin olduğu bir sistemde interapların kullanılması nasıl bir sonuç doğurur? Bir de en sağdaki sunum ise eee interaplarla birlikte uzun io işlemleri gerçekleştiğinde nasıl durum oluşur? İsterseniz bunu siz de bir kitaptan haftaya bakmış olun çünkü biraz karışık bir konu bu. Eee sadece tabii bu arada şunu söylemek lazım. Günümüzde no interap bir sistem de yok açıkçası. Hani bu sol taraftaki ihtimal artık yok. O çok önceleri 30-40 yıl öncesinde belki kullan an bilgisayarlardaki durum soldaki. Çünkü her şeyden CPU sorumlu orada. Dolayısıyla bir yazıcı bir şey yazdırdığı zaman şöyle bir şey düşünün. Yazıda bir şey yazdırırken ekranda mouse'un hareket etmediğini düşünün. Eee o yazıcı işlemi bitene kadar eee siz eee yazdırma işlemi yapıp bitene kadar ekranda hiçbir şey yapamıyorsunuz. Mouse'u bile oynatamıyorsunuz. Böyle bir sistem düşün. Yani interup'ın olmadığı dünya böyle bir dünya. Eee geçmiş dönemde eee yani bundan 20 yıl önce bu gerçekten bir problemdi. Ama günümüzde interuplar birçok alanda çok yaygın bir şekilde kullanıldığı için eee biz aynı anda birden fazla işi de gerçekleştirebiliyoruz. Yani bu sadece işte birden fazla işlemcimiz, Mthore bilgisayarlarımız vesaire olduğu için değil interrap yapısı kullanılabildiği için. Yani işlemci o sırada yaptığı işi bırakıp öncelikli olarak gelen bu interrap işlemini gerçekleştirebildiği için biz e daha rahat, daha eee akıcı bir şekilde bilgisayarları kullanabiliyoruz. Burada keselim arkadaşlar. E haftaya kaldığımız yerden devam ederiz.





NotebookLM yanlış bilgiler gösterebilir. Bu nedenle, verdiği yanıtları doğrulayın. Okay. Uh the Okay. So uh the program flow control uh mainly implemented in three different way. Uh the uh the left one the no interrupt case is one uh way of program flow control. However, uh these systems are not uh used anymore. Uh in this uh no interrupt case, uh the user program here uh technically um starts and it has uh three sections uh numbered by this one, two and three. These three sections are the instruction execution p I mean these are the CPU instructions. Uh I mean in these sections we are think Okay. Okay. So, um this is a CPU burst. This is an IO burst. This is a CPU burst. IO burst. CPU burst. IO burst. So, our applications are run in this manner. First, we execute some CPU instructions. Then, at some point, we will have an still an instruction, but uh the type is an IO. instruction, input output instruction. For example, your application first runs. So these are the CPU instructions. Then you ask some information from the keyboard. So the the user has to enter some value. So this is an IO part. Then uh the entered information is processed. So this is again a CPU burst. Then maybe you print something to the output another say another uh IO burst etc. So in this um toggle based operations Uh here uh we have the CPU burst then IO burst. But in case of no inter uh assume that this right operation is a uh this right operation is a print operation. So you go to the IO device and perform an IO program. You initialize the program then uh I mean in in the meantime in this period uh the IO device prepares itself. If this is a printer maybe it warms up etc. uh layouts its physical uh parts and then actual IO command takes place. The print command the print operation continues and it ends and this takes this amount of time. Then you go back to this position again where you left where you issue the right comment and then you continue your CPU operations. If another IO operation another right comment is there then the same anything I mean you go here you do necessary steps you finish your IO job and you come back to the location that you left and you continue your executions what's the disadvantaging Okay. So another say uh when you perform an I operation it's the CPU who is responsible for this. As you can imagine this is not a good way of dealing with IO operations because when you when you compare the speed of IO operation and the speed of the CPU uh CPU is very fast. So you use um very fast component to perform very uh low speed uh operations. That's why it's that's why it's not uh very useful. Uh so these no interrupt systems are not popular uh and they're not used. Instead we have uh the interrupt systems I mean in our computers we have the interrupts in the last let's say in the last uh 25 years let's say 25 to 13 years uh our uh computers has this facility. Uh when you have the interrupts, uh the advantage is that now when an interrupt occurs or when an IO operation is going to take place, the CPU is now uh Okay. Okay. So, uh when when you have the interrupts uh now the IO devices uh has also a CPU a person you know in races that there are some co-pilot right it's a secondary pilot which uh helps the primary pilot to and it gives some instructions turn left turn right about the distances etc the same thing available here now in in case of interrups uh with short I mean the main difference between this one and that one is the short and long uh weight I8 operations another say when the print operation is short when the print operation takes long time what happens the these two scenario uh represents these two uh different case uh so here the same scenario we execute some CP instructions and there's an IO instruction executed here another say. Okay. Uh we came to here uh and then we programmed the IO device. Uh so now the co-processor knows what to do. I mean the main CPU tells to the CPU of the printer that print this information for me and when you complete your job uh send me an acknowledge. So as you can see you program uh the IO device here and immediately it goes back to the position where it left here. So it continues the section two. Here we have the section two. It's a complete section but now this is not a complete section. You see there is a cross here. in the middle of its CPU executions it receive an interrupt. This interrupt means that uh the the operation that you are asked is uh is going to be finalized. So the interrupt handler is executed. Interrupt handlers are just functions. Mainly when you install a new um new uh device to your computer, uh you also install a driver. These drivers also has these interrupt handlers. So whenever a specific error or um dysfunctionality uh occurs uh the device driver knows what to do in such cases. So these are the interrupt handlers. Also the operating system has its own interrupt uh tables uh where each entry represents a different error. For example uh the most obvious example is division by zero and for division by zero it's not a problem for the I operation or something. I mean these interrupts are not only occur when you perform the I operation they may occur when there is an error uh happens inside the computer system like the division by zero so in in that case also an interrupt is interrupt is occurred so if you don't implement the try catch blocks or some uh in your application if you don't use that kind of facilities to handle Okay. Handled by the interrupt handler. So when the interrupt occurs, we go to the interrupt handler. The interrupt is somehow resolved. And then we go back and we continue our operation. And if there's another right, we again do the same step with the same cycle happens. And when the interup occurs, um then we perform the interrupt handling process. So uh when you have these blocks as you can see, we stop our current execution and we handle the nec we take care of the necessary operations and we go back to the CPU executions. As you can see now uh the CPU is not that much idle because here in this period of time the CPU is going to be in idle case. So I mean if you if you if you measure in terms of time then you should measure all these length of line not those two but these vertical ones must be uh summed up to find out the total time. when the final interrupt handler is executed here. So much more responsive uh case available when you have interrupts. Uh the the same thing is valid when you have an interrupt with long I8. What's the difference between the short and long IO8 is that in um short IO comments uh the uh interrupt is handled uh before the second IO comment take place as you can see this is the first IO comment and the first IO comments interrupt occurs somewhere here then the second IO comment occurs but in long case in long IO operations we have the first uh IO operation here but as you can see the we operate our instructions and the second IO operations also takes place but as you can see the after the first IO oper The second I preparation came out takes place. Okay. So uh shortly if we uh revise again when uh when we use the interrupts the processor can be engaged in executing other instructions while there is an IO operation is in progress. Uh so the flow of control uh if if you have a look at the pro flow of control uh when you reach a point uh which makes the system call in a form of a right call here. Then this right call uh the IO program is invoked and you call the IO functionality uh which only consists of some preparation code that uh prepares the actual IO comment. Uh after this uh preparation comments have been executed the control uh immediately returns to the user program. Uh in the meanwhile the external device is still using uh and accepting the data from the computer memory and printing it. So it's um Okay. Uh so uh when when when there's interrupt request signal is provided to the process uh processor the processor simply responds uh by uh suspending the operation of the current execution. I mean current program is suspended. It's the case uh when when you when you uh see here uh the current operation is uh suspended. And the uh program service or the interrupt handler of this particular IO device which is known as the interrupt handler uh is uh executed. Uh and this device is somehow searched and uh whenever you see these cases uh an interrupt handler uh sequence is started. So uh this is the case with the interrupts. I mean without the interrupts uh it will be very difficult to execute our applications especially the um IO related applications. So uh if you have a look at from the point of view of the user program uh an interrupt simply it's a interruption of the normal sequence of execution. The traditional sequential execution is stopped and the user program um by the way the the user program doesn't have any space ial code for these interrupts by the way I mean when when you compile our applications the our the our instructions in our application doesn't involve any uh interrupt code that's why this is um a dynamic behavior I mean in in our normal execution if there was no interrupt occurred here then it will continue like that but this is a dynamic issue at any time uh any interrupt with related with the program can occurred and when it occurs then uh it's the processor's responsibility or the processor and the operating systems responsibility to suspend the execution of that special codes. Instead, we have the uh special codes uh here. Uh so whenever the operation here takes place, uh we resume from the next location. I mean when you interrupt here, we continue with the next instruction in the user program. So this is the execution of the uh program when there is an interrupt. So we are uh this this facility again this facility has to be provided by the processor and the operating system in combination. So if we have a look at our fetch decode execute cycle uh this is the instruction cycle with the uh interrupts enabled. So uh So here what can we say? Uh in an instruction cycle we start here. We simply fetch the next instruction from the main memory. Here there are When you understand the operation code and when you bring those um uh operants we can perform the exec execute step. At this point uh there are two different possibility because in computer systems we we have um right to disable interups or enable inters if interrupts are disabled then this is a regular I mean this is a regular fetch the code to execute cycle but if the interrupts are enabled then during the execution of the instruction there might be uh some interrupts occurs so we will check uh for the existence of an interrupt if there's an interrupt then we process this interrupt and the interrupt cycle begins. In interrupt cycle, uh simply I mean this is the interrupt handler. It's a function. So what's the interrupt cycle? Then in interrupt cycle, we execute this interrupt handler function. The instructions in the interrupt handler function is executed. Uh so when you execute Okay. Uh as you can see easily uh it's very clear that I mean when when you look at this picture it's very clear that uh the operation takes place on the right side. I mean this part this section this section is an extra overhead I mean it creates an extra overhead because uh in our regular case without interrupt case or when the interrupt is disabled we don't have this so as you can see this is an extra each time when you when you execute an instruction and when you fetch a instruction decode it execute it then you perform a check operation so this is always uh brings an x extra overhead. Uh but we should not think that this is it makes the it slow down the system uh due to the its efficiency actually it's a better uh thing because uh it provides a better uh responsiveness to our application and it gives the CPU more time to deal with so uh I mean in order to understand that uh with a better presentation in this figure the user program code segments are shaded in green. So these green parts are are the user uh programs code segments. The yeah I mean the CP CPU instructions of the user application are in uh green. Uh the IO programs code segments are represented in gray. I mean these uh gray values gray parts are the IO programs code segment. uh and the black sections uh is as you can read it here uh this is the IO operation time and during this time the process processor simply waits it doesn't perform any operation I mean um as you can see without in the without interrupts case I mean when there's no interrupt our user application the operation takes place when you have without interrupts but we have two black blocks here that the CPU doesn't do anything when you have the interrupts again you start uh you start uh your program execution your application your user application executes here then a write operation takes place so you program the IO device and then you come back to your uh original application to continue with your second case but this time it's 2 A and it has another part 2B uh because the part number five uh when the inter handing finished takes place and you continue your instruction executions in the meantime the I operation here uh is executed with the IO device processor so the old I operation takes place here. Okay. So, uh this one uh assumes that the uh operation time for the IO operation is very short. So when you have very short IO operation uh you will have very uh good load on the CPU execution times because there is no black area here. But when it comes to when it comes to uh IO operation with long uh weight case so a long uh time required IO operations uh even if you have the interrupts you will have some waiting times because here as you can see the program execute the one on the left is again compared to this is the without interrupt case this is interrupt with long IO8 case so here we have uh the program execution lines and the IO operation starts here we program the IO processor we continue to the section two in our application but in during The section two uh the uh first I operation here and it occurs somewhere here. There is this amount of time is wasted in even if you have the inter apps because uh this device cannot perform two IO operation at the same time. The first operation has to be finished and then the second I operation. Think that think that it's a printer. I mean the first print out uh is finished and then the second print out has to be finished. So uh we have to wait uh before we start programming of the next operation for this device. So this is a simple example that uh still uh even if with the long IO weight operations uh the interrupts are uh more efficient than the systems that doesn't have uh interrupts. So if we re uh rewrite the uh instruction cycle state diagram where you have the fetch decode execute in combination with the apps then we will have this kind of figure. Uh so uh we begin with the instruction. Okay, we decode the uh operation to find out which operation it is. We find the earth them. Um, okay. Then Evet arkadaşlar, geçen hafta MÜEK toplantıları nedeniyle dersleri yapamadık. Biraz eee planın gerisinde kaldık ama yetiştirebiliriz. Bu hafta en son interplarda kaldık diye hatırlıyorum. Interplardan devam edeceğiz. Şimdi interuplardaki yapıda dedik ki işte klasik fetch decode execute cycle'ımızda eee araya bir de interup kısmını koyduğumuz zaman yani interuplarımız olduğunda şöyle göstereyim interuplarımız olduğu zaman bir de eee instruction execution'dan sonra interupt kontrolü yapılmakta. Bu tıp ki sizin işte uygulamalarınızı debug ederken işte e satır satır debug ettiğinizde her bir o state bir statement çalıştıktan sonra nasıl duruyorsa stop komutuyla eee benzer şekilde burada da bir e instruction execute edildikten sonra eee bir interuplar eğer enable edilmişse eee bir interap oluşup oluşmadığının kontrolü yapılıyor. Buna göre eğer var ise de bu işte interup service procedure dediğimiz işte ya da interup service routin dediğimiz o fonksiyonun devreye girerek bu interup ile ilgili eee düzeltme işlemlerinin ya da gerekli işlemlerinin yapılması sağlanıyor. Buna da interup cycle diyoruz. Bu interap cycle içerisinde de kendi içerisinde execute fetch vesaire bu tarz yapılar bulunmakta. Çünkü interup dediğimiz şey de aslında bir bilgisayar programı ya da bir fonksiyonu. Eee bu nedenle bizim eee bu şöyle heim bir şekilde bu fonksiyonları çalıştırmamız gerekiyor. Eee dolayısıyla kendi içerisinde de bunun aslında bir e fash execute cycle'ı tabii ki bulunacak ama genel anlamda yapı bu şekilde. Bir de interupt'ların disable edildiği durum var. Interuplar disable edildiğinde de eee interpol olsa dahi programınız buna bir eee aksiyon almıyor. Buna karşı bir eee işlem gerçekleştirmiyor. Bunları hemen geçelim. Eee bunlardan geçen hafta bahsetmiştik. Daha fazla zaman kaybetmeyelim. Şimdi bir de nested interupt dediğimiz eee durum var. Yani eee normal şartlar altında iki farklı eee yani aynı anda ya da belirli bir zaman içerisinde birden fazla interap oluştuğu zaman bunların eee hangi prosedüre göre, hangi protokole göre işine in tanımı var. Eee, iki farklı türümüz var. Biri sequential inter processing, diğeri ise nested interessing. Sequential'da burada görselde de gördüğünüz gibi belli bir noktada oluşan farklı interuplar sıralı bir şekilde yani önce interupt xınapt y handle ediliyor. Ama burada sequentialda eee aynı anda olmaları durumda kim öncelikli olacak? Burada priority durumları da var. Hani kim bazı interap türleri, kategorileri ayrılmış durumda ya da onların meta bilgileri bulunmakta. eee bu bilgiler üzerinden eee aynı anda oluşmaları eee halinde kimin öncelikli olduğu da tanımlanmış oluyor. Bu şekilde bir sequential interpr processing yapılabiliyor. Bir diğer durum ise bu interup processing aşamasında yani biz dedik ki işte bu interpender bir fonksiyon. Bunun da kendi bir program kodu var. Bu program kodunun çalışması sırasında başka bir hata oluşabilir. Bu da mümkün. Bu durumda nested dediğimiz içe geçmiş interuplardan bahsediyoruz. Yani interpender x çalışırken interpend ır y devreye girebiliyor. Örneğin buradaki örnekte birden fazla interaptın oluştuğu bir durum var. Ama burada ise priority dediğimiz yani öncelik durumu da eee söz konusu. Yani birtım eee device kategorileri ya da birtım driver kategorileri kendi içerisinde önceliğe sahip. Şimdi buradaki öncelikte eee en öncelikli communication olarak alın. Şu rengi değiştirelim. En önemlisi eee communication daha sonra disk ardından da printer şeklinde bir tanımlama yapılmış. Eee burada T10 anında printer bir interup gönderiyor. T15 anında communication, T20 anında da disk bir interup gönderiyor. Şimdi bunların çalışması nasıl olacak ona bakalım. Şimdi kullanıcı programı T0 anında çalışmaya başladı ve çalışmaya giderken T10 anında printer eee interup gerçekleşiyor. Dikkat ederseniz printer eee en düşük e seviyeli interap yani üst düzey bir interup değil o şekilde diyelim. Ama eee T10A'nın başka herhangi bir interup olmadığı için tabii ki de öncelikle printerın e interupt service rutini çalıştırıyor. Yani printer'la ilgili bir hata oluşuyor o 10 saniyede ve printer da bununla ilgili işte interup'ı devreye sokuyor. Şimdi eee bu işlem devam ederken şimdi dedik ki gerçi burada eee 1 2 3 3 4 5 6 7 8 zaman gösterilmiş. Yani görselde aslında bir hata var. Bu çubuğun buradan değil de biraz daha yukarıdan başlaması lazım. Diyelim ki işte eee 15 birim zamanda da rengi değiştirelim. 15 birim zamanda da communication la ilgili bir problem oluşuyor. Fakat şimdi buradaki sorun şu. Eee yaklaşık aslında 15 birim zaman şuralara bir yere denk gelmesi lazım. Burada şurası gösterilmiş. Sorun değil. Eee Şimdi printerın interfers rutini çalışırken communication interuptı oluştu. Yani dikkat ederseniz communication en önemli interaptörü. Dolayısıyla önceliği var. Bu da şu demek. Mevcut printer interup servis rutinin kesilmesi, interap'a tabi communication service rutinin çalıştırılması demek. Bunun ne kadar sürdüğünü bilmiyoruz. Fakat 20 birim zamanda yine başka bir renge geçelim. 20 birim zamanda halen eee communication interp service rutini devam ederken eee disk interupı oluşuyor. Fakat disk interup oluştuğunda eee mevcutta communication interupı devrede olduğu için bakın burada herhangi bir kesilme yani muhtemelen şurada bir yerde diske ait bir interap oluşuyor. Fakat e öncelik olarak disk communication'dan öncelikli olmadığı için eee communication interapının bitmesi bekleniyor. Yani 25 birim zamanda kaçta bittiği çok da şey değil. Hani bittiğinde burada 25 olarak gösterilmiş bazı bir değer eee Bittikten hemen sonra ise disk eee interın service rutini başlıyor. Dikkat ederseniz döndüğü noktada aslında printer interup servis rutini var. Fakat diskin interup'ı printerdan daha öncelikli olduğu için hemen eee diskin interupı çalıştırılıyor. 35 saniyede de tekrardan geri dönüş yapılıyor. Burada eee genellikle biliyorsunuz stack veri yapısı kullanılmakta. Hani eee push ve pop işlemleriyle siteğe yapılan push ve pop işlemleriyle işte bir yere giderken işte örneğin şurada ben bu satırdayım. Bu satırdan buraya doğru gitmeden önce şurada devam edeceğim noktayı S'ye atıyorum ki bu hani Hanzer Greteld'deki bu şey gibi eee ekmek atmak gibi yere döndüğümde eee o noktadayı sıralı bir şekilde en son ne koymuşsam işte onları geriye doğru almış oluyorum. Şimdi eee bilgisayarlarda bir de bizim eee fonksiyonumuz bulunmakta. Bu interuplar dışında eee bunlar içerisinde en önemlisi DMA dediğimiz direct memory access. Çünkü eee DMA sayesinde biz IO operasyonları sırasında eee işlemin eee IO prosesörü tarafından yapılmasını programlayıp kendi işimize geri dönebiliyoruz. Bu çok önemli. Bunu yaptığımız zaman eee işlemci IO işleminin detayıyla uğraşmamış oluyor, ilgilenmemiş oluyor. Eee şimdi communication modül açısından bakacak olursak ana modüllerimiz işte CPU'muz var, IO modülümüz var, bir de memoryiz var ve bunların input ve outputları var. Hani bunları böyle kendinizde çıkartabilirsiniz. Yani bir memoryin input nedir? İşte read komutu, kontrol sinyalleri, bir adres bilgisi ki nereden okuyacağını bileceksiniz ya da bir veri yazılacaksa bir data baskı bilgisi bakın burada bulunmakta. Çıktı olarak da eee bir data üretiyor memory. Kendi içerisinde de birden kadar bir eee sell yapısı bulunmakta. Aya modüllerinde ise input output modüllerinde ise farklı sayıda portlar bulunuyor. Bu device'ın türüne göre değişmekte ama genellikle işte read control sinyalini yine kabul etmekte. Yine adres bilgisi bulunuyor. Internal ve external data buna gelebiliyor. Internallar bu modül içerisinde externallar dışarıdan gelen bilgiler aynı şekilde dışarıya da bu datayı sunabiliyor. Bir de eee işte bu DMA'ye destek vermek adına birtım interaps oluşturabiliyor. CPU'ya gelince CPU bu her ikisine de işte veri üretebilir. Yani data çıktısı var. Kontrol sinyalleri üretiyor. Yani diğerlerindeki şu ret sinyalleri vesaire bunlar aslında kontrol sinyallerimiz. Eee adres bilgisi üretebilir. Bakın buradaki bu IO modülünün ya da memory'nin kullanmış olduğu adresler CPU tarafından generate edilmiş oluyor. Eee input olarak da CPU işte ne alacak? Bir program kodu alacak. CPU instructionları alacak. Eee ve programla ilgili birtım verileri, datayı alacak. Bir de bu şeyden gelen io modüllerinden gelen bu interupları, DMA destekli interupları input olarak alacak. Bu e komputer modülünün genel olarak yapısı bu şekilde. Bunlar kendi arasında yinatif bir şekilde yani kombinasyonel bir şekilde işlem yapabiliyorlar. İşte memoryden prosesöre, prosesörden memory, iodan prosesöre, prosesörden io vesaire gibi işlemler bulunmakta. Bütün bu işlemlerde ortak olan yapı interconnection yapısı yani eee belli bir noktadan başka bir noktaya virin transferi. Bu transfer işlemi sırasında eee genel yani uzun yıllardır databas adını verdiğimiz bir eee veri yolu, türkçesi veri yolu kullanılmakta. Databas aslında kendi içerisinde eee lane dediğim işte eee yollardan oluşuyor kendi içerisinde eee kablolardan oluşuyor. oluşmakta. Bu kablo sayısı arttıkça sizin birim zamanda gönderebileceğiniz eee veri miktarı da ya işte buna bandwid diyoruz. Eee artmakta. Ne kadar geniş bir eee yani bunu otoyol gibi düşünebilirsiniz. Ne kadar çok sizin orada şeritiniz varsa eee o kadar çok araca aynı anda özellikle aynı anda hizmet ederken, eee daha rahat olursunuz. Eee burada o yüzden hani 32, 64, 128 vesaire gibi leng sayıları önemli. Daha yüksek sayı daha eee yüksek kapasite anlamına gelmekte. Dolayısıyla yani teknik olarak da databas'tan bahsederken buna aslında with diyoruz aslında. Bandwid de denilebilir ama with olarak geçiyor databas'ta. Eee yani bütün sistem performansını etkileyen e özellik ama çok uzun yıllardır yani bilgisayar organizasyonunda databas eee çok eee nasıl diyelim? Eee yaygın bir şekilde temel iletişim yöntemi olarak kurulur. Yani bir modülden başka bir yere, CPU'ye, memoryye, ı modüle vesaire iletişim yapmak istiyorsak databas üzerinden eee bu veriyi yani verileri databas üzerinden taşıyoruz. Tabii yani bu databas aslında bas mimarisinin sadece bir tanesi. Bunun gibi işte mesela adres basımız var, kontrol basımız var. Hani işte memoriye bir şey eee yazacağız ya da okuyacağız. Hangi adresten yazıp okuyacağımızı bu adres basa koymuş olduğumuz veri üzerinden gerçekleştiriyoruz. Ne yazacağımızı ise databas'a koyduğumuz veri üzerinden eee gerçekleştiriyoruz. Eee ne zaman yazacağımız ya da yazıp yazmayacağımız ya da okuyup okumayacağımızı da kontrol bas üzerindeki sinyal üzerinden alıyoruz. Yani bunların hepsinin belli bir kullanım amacı var. Yani oradaki veriler kimi zaman işte bir adres olarak kullanıyor. Kimi zaman data, kimi zaman instruction taşıyorlar vesaire. Şimdi databas bunlardan bir tanesi ama günümüzde artık databas giderek yerini eee daha farklı mimarilere bırakmaya da başladı. Yani özellikle son eee son 10 yılda gelişen teknoloji eee çok uzun zamandır eee bizim yaygın olarak kullandığımız bu bas mimarisini artık elimine etmeye çalışıyor. Çünkü bas mimarisi belki bu sene mi göreceksiniz? Emiliman Computer Networkında de görürsünüz. Yani BAS mimarisi Computer Network'ün de bir konusu aslında. BAS arkitecture. Eee en önemli avantajı bas mimarisinin eee scalable olması. Yani siz bir bas mimarisine yeni bir io modülünü ya da Yine bir IO device'ını çok rahat bir şekilde eklersiniz. Çünkü bu tıpkı eee bir otobanınız var sizin ve eee bir tali yol ile otobana bir bağlantı yapmanız kadar kolaydır. Dolayısıyla 5 tane device'ı da yeni ay modülünü de ekleyebilirsiniz. 50 tane yeni ay modülünü de bu basa ekleyebilirsiniz. Bununla ilgili hiçbir sıkıntı yaşamazsınız. Çünkü bas mimarisinin eee temelinde zaten ölçeklenebilirlik yatmakta ve aynı zamanda da ekspresif yani eee bu kadar yeni yeni aletleri buraya bağ amak için. Ya bu şu demek yani anakartınıza birtım işte atıyorum eee 3 tane PCL slotu yerine 5 tane PCL slotu koysanız eee bu size çok fazla külfetli bir şey olmayacak demek bas data standart bas mimarisini kullandığınızda. Ama tabii dezavantajları da yok değil yani. Eee o kadar çok device'ı tek bir basa bağladığınız zaman İstanbul gibi bir yeri bir tek eee yolla bağlamış gibi oluyorsunuz. Yani o bütün device interuplar oluşturacaklar. İşte veri transfer etmek isteyecekler. İşte benzer durum adres bası için, kontrol bası için de geçerli. Eee yani bu fazla sayıdaki device'ın fazla sayıdaki birim zamanda oluşan fazla sayıdaki istekleri eee o baz eee yolları üzerinde birtım trafiğe neden olacak ki bu da işte bilgisayarda bizim tıkanma, yavaşlama, bodak vesaire diye adlandırdığımız durum. Dosya günümüz mimarilerinde eee veri bazı yerini daha çok eee işte eee son 5-6 yılda işte mesela QPI Quickpad Interconnect diye bir tek konje geliştirdiler. Artık işte eee dedicated line'lar var. Yani e bir modülden başka bir yani bir bilgisayar kasası içerisinde diyelim. Bir eee modülünüzden başka bir modüle artık bu genel data basını, adres basını, kontrol basını değil de eee size dedicate edilmiş. Sadece sizin kullanabildiğiniz bir yani bisiklet yolu gibi düşünebilirsiniz bunu ama bu tabii yüksek kapasiteli diye düşünün ve sadece siz gidiyorsunuz o yolda. Size ayrılmış bir yol. Böyle düşünün. Dolayısıyla eee bu Quickpad, interconnect gibi doğrudan bağlantılı yapılar eee hızın da hız probleminin de bir şekilde çözülmesini sağlıyor. Tabii bu comptexın interconnect diye her modül için yapmış olmak demek eee yani her modül için ayrı ayrı e pad'ler oluşturmak demek. Yani eskisi gibi bu general bir data oluşturup her modülü oraya bağlamak yerine aslında her modül oraya bağlanmıyor. Yani onu demek de doğru değil. Eski mimaride hani biraz bu işlerle uğraşmışsanız eee şeydir hani bir eee North Bridge ve South Bridge şeklinde iki tane bridimiz vardı eskiden. Artık neredeyse her şey South Bridge gibi davranmaya başladı. Şimdi North Bridge'te eee yani kuzey köprüsü dediğimiz anakart üzerindeki kuzey köprüsü dediğimiz yapıda eee daha çok bilgisayarın eee eee daha hızlı yani frekansı yüksek, veri transfer hızı yüksek, işlem gücü yüksek komponentlerinin bağlı olduğu işte PCI PCI'ın değil de PCI Express'in bağlı olduğu nokta ya da sizin DDR RAM'lerinizin bağlı olduğu nokta, CPU'nun işte front side Bass üzerinden bağlı olduğu nokta kuzey köprüsüydü. Güney köprüsü ise işte bilgisayarın daha yavaş komponentlerinin daha eee veri hızı düşük. İşte klavyedir, mouse'tur, USB'dir. eee gibi hani eee işte Ethernet kartıdır eee gibi birtım eee burada şey de mesela ekran kartı da Kuzey köpürtedir vesaire. Güneyde daha yavaş olanlar var. Onlar bir hub üzerinden genellikle birleştirilerek eee yani oradaki hız çok daha çok mühim değil aslında. Hani genel performansı etkileyecek düzeyde değil. Asıl performansı etkileyecek düzeyde olanlar Kuzey Köprüsündeydi. Fakat günümüzde artık Kuzey Köprüsü'nün içerisinde de yani artık CPU'lar da eee kendi başlarına bir hub gibi davranıyor. Yani kendi içerilerinde işte eski yapıda CPU ile eee GPU arasında Kuzey köprüsü bulunmaktaydı. Yani eee ekran kartından gelen görüntüyle CPU arasında Kuzey Köprüsü bir geçiş noktasıydı. Bir corner point gibi davranıyordu. Ama günümüzde artık biliyorsunuz işlemciler kendi içerisinde GPU'larını barındırıyorlar. Dolayısıyla hani özel ayrı bir hat kullanımı eee CPU'nun kendi içerisinde var. Eee anakart üzeri Kuzey köprü üzerinden herhangi bir iletişim sağlanmıyor. Tabii external bir ekran kartınız varsa yine Kuzey Köprüsü üzerinden sağlanacak demek bu. Şimdi bu yapı neyi sağlıyor? Hani mümkün olduğunca eee hem enerji tüketiminin azaltılması hem performansın artırılması eee bu takım eee işte birtım scalable dediğimiz ölçek kinebir problemlerinin çözülmesi için eee artık bu Kuzey Köprüsü yapısı yavaş yavaş eee ortadan eee kalkıyor. İşte buna da işte Quickpad Interconnect gibi birtım teknolojilerde destek veriyor. İşte bir taraftan Thunderbolt'la, bir taraftan Quick Padterconnect'le, bir taraftan işte bu köprülerin yavaş yavaş kaldırılmasıyla eee işte PCI Express'in yeni versiyonlarının çıkmasıyla vesaire eee teknoloji yavaş yavaş işte yüksek performansın standart hale geldiği bir ortama doğru gitmekte. Yani geçmiş yıllarda bunun tabii bir evolüsyonu oldu. işte eee işte Quickpad Intel Connect'e gelene kadar işte databas'larımız vardı. Eee hatta işte az önce de alışkanlık söyledim. Mesela front side bus'ımız vardı ya da işte bu frontside Bass aslında şey diye söylüyorum. Ben hep örnekleri Intel üzerinden veriyorum ama işte şeyinde eee AMD firmasında EV6'sı vardı benzer şekilde. Yani eee memory ile nasıl diyelim? Memory ile CPU arasındaki iletişimi sağlayan ilk o Kuzey Köprüsü tarafından iletişim sağlayan kısımda bir front side bas bulunmakta. O da bir bas türü aslında. Yani burada genel olarak diyoruz ya databas, adres bas, kontrol bas. Onun yerine EV6 BAS ya da işte FSB bas şeklinde de baslar mevcutta. Ama eee sanırım 2020'lerde hani yakın zamanda diye hatırlıyorum 2020'lerde artık ıntel ve AMD firması da yavaş yavaş bu eee bu baz türlerini ortadan kaldırmaya yönelik işte Quick Patın Interel Conneki vesaire eee getirip ilk defa işte kuzey köprülerini kaldırmaya yönelik bir takım çalışmalara başladılar. Onları eğer merak ediyorsanız hani araştırın okuyun. Gerçekten ilginç bilgiler var. Teknoloji çok hızlı değişiyor. Hani benim eee öğrenci olduğum dönemde mesela ISABASlar vardı. Isabas'lar eee oldukça görsel olarak bilgisayarın yarısını kapsayan bir slot şeklinde bir eee bas türüydü. Oraya işte ether kartınızı ya da ekran kartınızı ya da ses kart kartınızı anakartlar üzerinde ses kartı olmadığı için işte o tarz kartları takabiliyordunuz. Eee bu ISA kartlar eee zamanla PCI kartlara yerini bıraktı. Yani o geçiş dönemini çok bunu şöyle hatırlıyorum. Yani bir dönem o ISE kartların rengi bu arada siyahtı. Standart siyah renkli uzun slotlar şeklindeydi. Anakartların üzerinde e uzun uzun siyah çubuklar şeklinde işte bu kart noktaları yavaş yavaş yeni nesil kartlar geldikçe o isaların sayısı azalıp PCI e slotlarının sayısı artmaya başladı. PCIı'lar belli bir noktadan sonra artık eee dominant oldu ve işte ISA slotları devreden kalktı. Günümüzde ISA slotlu bir anakart bulamazsınız. Eee PCI'lar da işte yavaş yavaş PCI Express'le yer değiştirdiler. Bir ara işte ekran kartlarında AGP Accelerated Graphic Force diye bir eee slot yine oluştu. Ama o da yani PCII Express'in gücüne ya da yeni versiyonlarına eee başı tutamadığı için günümüzde o da kullanılmıyor artık. Eee günümüzde biliyorsunuz PCI Express üzerinden eee hızlı bir şekilde veri transferi sağlanabiliyor. Çünkü PCI Express'in de en önemli özelliği işte bu veri transferini farklı eee fiziksel portlar üzerinden eee farklı hızlarda gerçekleştirebilmesi eee ve yüksek derece veri transfer hızına sahip olması en önemli özelliği. Şimdi databas'tan bahsettik. Eee, ya bu bahsettiğim şeylerle ilgili slaytlarım da olacaktı ama belki erken konuşmuştu olabilir slaytlarım var diye hatırlarım. Neyse olmazsa internetten gösteririz. Bir diğeri ah bahsettiğimiz gibi işte adres bas ve kontrol bas. Adres bas da işte destination adres ya da eee okumak istediğimiz verinin adresi bulunmakta. Kontrol bas üzerinde de kontrol sinyalleri bu bassları kimin kontrol edeceği, bassaki verinin hazır olup olmadığı ile ikili gibi birtım bilgiler bulunmakta. Genel gösterim bu şekilde ama dediğim gibi artık bu mimari yavaş yavaş ortadan kalkıyor. Çünkü gerçekten evet ölçeklenir bir mimari ama günümüzde işte daha önce de bahsettik. Yani bu farklı bunları farklı teknolojiler olarak görürsek CPU, memory, io bunların zaman içerisindeki gelişimleri birbirinden farklı hızlarda. Evet. Yeni teknoloji IO device'ları çıktı. Yeni teknoloji memoryler çıktı. İşte DDR DDR 2 3 4 5 6 gidiyor. CPU'lar keza öyle. Ama bunların eee birbirleriyle oranını ölçmeye kalkarsanız çok da böyle bir oran bulunmamakta. Bu nedenle de bu aralarındaki iletişim türleri de eee STEM performansı açısından bir sıkıntıya yarışıyor. Mesela çok uzun yıllar biz eee yani SSD'nizin olmadığını düşünün arkadaşlar. Şöyle bir şey. SSD'nizin olmadığı bir dönemde işlemci hızını siz ne kadar artırırsanız artırın yani bilgisayar açılış hızını çok fazla etkileyemiyordunuz. Yani orada işte 2 GHz bir işlemciden 3 GHz bir işlemciye geçseniz dahi bu size geçireceği ekstra 1 saniye, 2 saniye ya da benzer bir süre olacaktı. Ama orada asıl gelişmesi gereken kısım yani asıl problem yaratan kısım standart işte fiziksel hard disk teknolojisiydi. İşte SSD teknolojisi geldiğinde oradaki o eee açılan ara bir miktar kapanmış oldu. Ama dediğim gibi bu teknolojilerde böyle eee dengesiz bir geliş var ve işte mesela ekran kartı teknolojisi dersek ekran kartı CPU'nun da çok ötesinde bir teknoloji. Gerek frekans işte atıyorum 2000'li yıllarda 256 bit 512 bitlik ekran kartları bulunmaktaydı ki günümüzde keza çok daha üstün bulunmakta. Yani eee o açıdan baktığımız zaman bunları böyle eee yani komutür organizasyonu açısından bütün olarak tutabilmek için eee gerçekten bu yapıların eee birbirleriyle çok uyumlu olması gerekiyor. Eee, belli standartları desteklenmesi gerekiyor. Yani günümüzde birçok standart oturmuş durumda ama ben hatırlıyorum mesela eee, işte anakartınız var, SATA portunuz var, SATA destekli bir eee hard diskiniz var ama anakartınız hard diskini hiçbir şekilde görmüyor aslında. Gerçekten satayı desteklememiş, protokolüne uygun yapmamışlar. Belli hard disklerde çalışabilen anakartlar vesaire. Mesela günümüzde bunu düşünemezsiniz. Günümüzde birçok şey standart bir şekilde çalışıyor. Eee, yani bir hard disk aldığınızda eee anakartınızda bu uyumlu olacak mı olmayacak mı gibi bir sorunuz ya da böyle bir düşünceniz bile olmaz herhalde. Ama geçmiş zaman öyle değildi. Geçmişte eee bu tarz problemler çok sıklıkla karşılaşılmaktaydı. İşte aldığınız ethernet kartlarının işte kullandığı PCI Express ya da PCII slotlarının uyumluluğu vesaire bunlar eskiden çok daha önemliydi. Günümüzde bunlar artık e gerek yazılımla gerek işte yeni teknolojiye çözülmüş durum. Evet. Bu geleneksel bas mimarisi eee ve high performans bas mimarisi dediğimiz yapı. Eee aradaki fark ne diyecek olursanız işte eee high performansı olana eee yani şeyde de öyle. Her ikisinde de main memory yine bir sistem bas üzerinden eee bağlı. Ama eee burada prosesör eee lokal bas üzerinden bir keşe bağlı direkt olarak. Ardından main memory bağlı High Performance Architecture'da günümüz mimarisinde ise yani bu High Performance arkitecture bu arada tam günümüz mimarisi de değil arkadaşlar bu slaytlar bir miktar eski yani bir 56 yıllık slayt olduğu için eee şimdi eee günümüzde prosesör ile cash arasında bir local bus bulunmamakta. Prosesörle cash arasında artık daha doğrusu prosesör core ile eee cashler kendi cashleri arasında eee direkt olarak eee quick pad interconnect yapısı bulunmakta. Yani doğrusal olarak çekilmiş hatlar bulunmakta. E dolayısıyla bu yapıda biraz eee eski kalmış oluyor. Eee bass dizaynda eee gerçok da üstünde durmamak lazım artık ama bass dizignda eee dedicated basslar ve multipleited basslar olarak ikiye eee ayrılıyor. Dedicated olan adı üzerinde eee özel yani belli bir işlemin için ayrılmış olan BAS eee grubu. Multiplexed olanlar ise genel amaçlı olarak işte aynı basın eee farklı multiplexing yöntemlerine göre. Şimdi e dijital dizayndan belki hatırlarsınız multiplex diye bir yapı bir yapımız vardı. Eee MOX diye gösteriyorduk. Selectorlar vasıtasıyla belli bir operasyonu seçiyorduk. Şimdi eee buradaki multiplexed yapıda ise eee genel olarak iki farklı eee multiplex özelliği kullanılmakta. Bir tanesi eee frekan division multiplexing dediğimiz eee frekans bölmeli multiplex işlemi. Bir tanesi de TDM dediğimiz time division multiplex yöntemi. Yani eee zaman bölmeli multiplex. İkisi arasındaki fark ne? Eee frekan division multiplex'inde siz aynı veri yolu üzerinden eee farklı veri gruplarını farklı frekanslarda gönderiyorsunuz. Mesela bir tane bakır kablonuz var diyelim. Eee, bu kablo üzerinden farklı bir frekansta, yüksek ve düşük frekansta eee, veriyi gönderebiliyorsunuz. Bu sayede veriler birbirleriyle karışmamış oluyorlar. Bu bir tanesi. Eee, ama daha sıklıkla kullanılanı bu bahsetmiş olduğum frekan division multiplex'in aslında daha çok kablosuz iletişimde bir miktar daha fazla. Yani birini 5 GHz'ten veriyi gönderiyorsunuz, birine 2,5 2 GHz'ten gönderiyorsunuz. Birine 3'ten gönderiyorsunuz vesaire gibi. O aslında biraz da kablosun işi. Kablolarda ise time division multiplexing dominant olmakta. Time division multiplexe de adı üzerinde belli bir zaman diliminde eee farklı verilerinin farklı parçaları. Yani ü tane kuyruk var diyelim. 3 tane ü sıra insan birikmiş diyelim. Eee birim zamanda her sıradan bir kişiyi gönderiyorsunuz. Belli bir bir kişilik bir dar geçitten eee her sıradan bir kişiyi gönderiyorsunuz. Bu time division multiplex'in bu sayede eee belli bir Aslında bütün sıralarda belli bir ilerlemeyi eee katetmiş oluyorsunuz. Çünkü aksi takdirde eee multiplexing yapmazsanız eee bir sıra bitmeden diğer sıraya geçemeyeceksiniz. Bu da performans açısından özellikle eee responsif eee yapılar açısından yani uygulamaların e çalışabilirliği açısından eee dezavantaj oluşturacak bir durum. Bunu engellemek için de işte bu time division multiplex dediğimiz yöntem kullanılıyor. Eee burada önemli olarak bahsedeceğimiz işte bu in konusunda işte senkron, asenkron yapıları olabilir vesaire. Eee dediğim gibi bunun üzerinde çok da fazla durmak istemiyorum. Sadece burada önemli olan, sizin bilmeniz gereken eee bu işte eee synchrono işlemler ve asnchrono işlemlerde eee retri cycle'ları nasıl gerçekleşiyor ona bakalım. Ondan sonra da bir arı veririz. Şimdi şöyle diyelim. Şimdi burada bir clock sinyalimiz var. Clock sinyalimiz işte rise ediyor, fall ediyor. Şek şeklinde T1, T2, T3 zaman dilimlerimiz oluşuyor. Statüs sinyalimiz bulunmakta. Adres satırlarımız bulunmakta. Şimdi eee burada şu eee gri tonlamalı olarak gördüğünüz alanlar içerisindeki veriler artık stable değerler. Yani valid değerler. Bu şu demek. Eee mesela e adres satırına bir adres yerleştiriyorsunuz ama belli bir süre sonra o adres geçerli bir adres formuna dönüşmüş oluyor. Yani bir şeyler anında olmuyor. Belli bir süre geçmesi gerekiyor. Şimdi eee örneğin read cycle'ına bakacak olursak şimdi read cycle'ında ne yapmamız gerekiyor? E önce bir işte adres enable komutu t1 zamanında yani t1 dediğimiz şurası t1 zamanında bir address enable komutu şurada geldi. Adress enable komutundan önce zaten adres line içerisinde geçerli bir adresimiz vardı. Bu adres bu line üzerinde adres üzerinde belli bir süre bulunacak. Şimdi bu süre içerisinde eee bizim memory türümüz artık nereden okuma yapıyorsak eee okuma işlemini gerçekleştirecek ve okuduğu veriyi işte şu aslında şu kısım içerisinde veri okuma işlemi gerçekleştiriyor. T2 zamanında. T3 zamanında da okunan veri artık datine üzerine yerleştirilmiş oluyor. Burada artık bizim bir valid datamız var. Şimdi eee, valid datamız varsa, eee, ne yapabiliyoruz? İşte eee, bu valid datayı alıp biz o sırada belki bir memori alanına başka bir yere transfer edebiliyoruz. Ama önemli olan şu, valid datanın oluşmuş olması. Right cycle'ına bakacak olursak da, eee, biz dataline'a bir veriyi koyuyoruz. Veriyi koyuyoruz. Yine stable adresimiz burada var. Ama bu adres artık bizim için bir destination adres görevi görüyor. enable edilmiş bir destination adresi. Elimizde hem adres var şurada hem veri de var. Artık şurada write komutunu verdiğimiz zaman bir sonraki işlemde artık memory bu e buradaki valid data şurada belirtilen eee adrese yani buradaki data buradaki adrese yazılmış oluyor. Şimdi dikkat ederseniz bu işlemlerde burada şey yoktu. Eee pardon burada eee dikkat ederseniz senkron bir şekilde bu işlemleri yapıyoruz. Yani burada T1, T2 ve T3 şeklinde bölünmüş ki bunlar işte clock e rising'lerine göre işte şurada bir risingimiz var. Burada bir risingiz var. Burada bir rising agimiz var. Ona göre bölünmüş senkron zaman dilimlerimiz var. Ve bu zaman dilimleri içerisinde işte read deniyor. Bir zaman dilimi bekliyorsun sonuca alıyorsun. R diyorsun bir zaman sonra sonucu alıyorsun gibi. Bu işlemlerin belli süreleri var ama bunlar bilinen süreler ve her eee tikte siz bir işlem yapabiliyorsunuz. Şimdi bunu Bir diğeri ise asenkron eee işlemler. Şimdi eee asenkron rate ve asenkron right cycleının yapısına bakacak olursak şimdi burada böyle bir clock olmadığı için öyle bir timing vesaire bir yapı da yok. Dolayısıyla burada bizim için önemli olan zaten şurada görüyorsunuz her ikisinde de acknowledge dediğimiz bize bir geri bildirim. Çünkü geri bildirim olmazsa e biz işlemin tamamlanıp tamamlanmadığını eee bilemeyeceğiz. Bunu bilmek için launch sinyalinin bize gelmiş olması gerekiyor. Şimdi yapıya bakalım. Adres işte read işlemi için eee adres satırında eee stable adresimiz burada bulunmakta. Bakın soldan sağa zamanının aktığını düşünüyoruz. Yine burada read komutu verildiğinde belli bir süre sonra bakın eee dataline üzerinde valid data oluşuyor. Ama valid data oluşunca memory bir acknowledge sinyali gösteriyor. Artık eee dataline'daki datayı kullanabilirsiniz. Orada geçerli bir sonuç oluştu. Yani şu acknledge bizim için önemli. Asenkron iletişimde benzer bir durum eee asenkron iletişimdindeki right da mevcut. Yine işte bir adrese bir veriyi yazacağız. Adres basımızda adres bilgimiz var. Data basımızda ise valid datamız bulunmakta. Artık tek şey bu right komutunun gelmesi. Write komutu geliyor. Write komutu geldikten bir süre sonra right işlemi gerçekleştiğinde device bize bir acknowledge gönderiyor. Bu acknown sayesinde artık ya bu bu neyi sağlayacak? Bir sonraki işleme geçebilmemizi sağlayacak. Aksi halde hani bu right işlemi ne kadar sürdü bunu bilmiyoruz. İşlem asenkron olduğu için eee bunu ekne oluç sinyali üzerinden eee gerçekleştiriyoruz. Evet. Şimdi burada bir ara verelim. Point point interconnect'ten zaten bahsetmiştik ama ara verelim. Aradan sonra eee devam edeceğiz  arkadaşlar. Eee
 önemli bir konu. Eee, birkaç farklı eee, cashmapping yöntemi var. Eee, en basitiyle başlayacağız. Direct cash mapping'ile başlayacağız. Ardından eee, asociative ve set asociative'ile devam edeceğiz. Bununla ilgili işte birtım örnekler yapacağız. Hemen cash mapping konusuna geleyim. Geçen hafta biraz bir giriş yapmıştık Cash Mapping'ile ilgili olarak. Eee, şöyle Şuradan şunu bitirelim. Yapayım ben. Evet. Şimdi üç farklı cash mapping yöntemi var. Biri direct, biri asociative, diğeri de set asociative. Eee, günümüzde eee, en son teknoloji olarak kullanılan yöntem set asociative yöntemi. Ama onu eee, şimdi set asociative yöntemini anlayabilmek için kendi içerisinde barındırdığı direct ve asociat yöntemlerini de öğrenmemiz gerekiyor. Yani giderek eee birbirini içeren şekilde işte birbirlerinin dezavantajlarını, avantajlarını kimi zaman azaltarak, kimi zaman çoğaltarak devam eden yöntemler bunlar. Eee ilki ise direct cashping yöntemi. Zaten burada görüyorsunuz. En basit yöntem olarak geçiyor. Eee simplest technique. Eee buradaki asıl amaç main memorydeki her bir bloğun eee cash'teki bir line'a eee map edilmesi, eşleştirilmesi. Şimdi bu eşleştirilme eee birebirlik bir eşleştirme değil tahmin edeceğiniz gibi. Çünkü hani bizim main memory dediğimiz RAM diye bahsettiğimiz kısım günümüzde işte 8 GB, 16 GB, 32 GB şeklinde klasik birtım boyutlara sahip. Şimdi bunun karşılığındaki cashş boyutuna baktığımız zamansa işte 1 2 3 4 MB'lık cashler görüyoruz. Dolayısıyla hani birebirlik bir olma ihtimali zaten yok. Hiçbir zaman da olmadı. Eee burada eee memory tarafından cash tarafına eee min to one bir relationship bulunmakta. Bu şekilde bir mapping işlemi yapılacakmış. Şimdi bu mapping'de eee direct mapping'teki bu durum hani her ne kadar işte memory blokları bu şekilde yerleşiyor dedik keşa. Ama bu görselde geçen hafta da bahsetmiştim. Hani soldaki e kısım e main memory sağdaki kısım bizim cash memoryiz. Ama burada eee soldaki kısım kısmın büyüklüğü çok daha fazla. Yani defalarca kez daha büyük bir boyuttan bahsediyoruz. O yüzden birçok sol taraftaki birçok blok eee sağ taraftaki bir line'a karşılık gelecek. Bu arada yine unutmuyoruz. E cash memoryde kullanılan line size byte cinsinden büyüklüğü ile memory tarafında kullandığımız block size'ın byte cinsinden büyüklüğü birbirine eşit olacak. Çünkü hani bunları birbirine map ettiğimiz için hani memoryden bir bloğu alacağız. keşe bir line'a yerleştireceğiz. Dolayısıyla kapasite olarak bunların birbirleriyle birebir bite bit uyumlu olması gerekiyor. Şimdi böyle bir durumda bizim nasıl bir adresleme yapmamız lazım ki eee tüm bu işte eee karmaşık işlemleri eee çözebilelim? Şimdi öncelikle eee burada yapılan bütün işlemlerde yani direct cash mapping tekniğinde direct mapping tekniğinde kullanılan bütün yöntemlerde bit işlemlerini kullanacağız. Bu sizin daha önce Digital Design'da öğrendiğiniz işte kaç bitle ne kadar adresleme yaparız sorusunun çok sıklıkla kullanıldığı bir alan. Çünkü eee burada bir işlemcinin üretmiş olduğu eee sanal adres üretiyorlar biliyorsunuz. MMU tarafından bu fiziksel bir adrese daha sonra dönüştürülüyor. Bu sanal adres içerisindeki bitlerin anlamları var. Bu anlam ramlarını o bitleri eee belli yerlerden eee bölerek daha da detaylı hale getiriyor. Direct mapping tekniği biraz daha bazı işlemleri kolay hali kolay bir şekilde yapılmasını sağlıyor. Şimdi eee şöyle bir yine slayta geçelim. Şimdi dark mapping cash organizasyonunda nasıl bir yapımız var? Öncelikle şimdi main memory dediğimiz de sağdaki kısım Aslında hani bu biz bunu vertical bir stack gibi bir aray gibi gösteriyoruz ama gerçek yapısı böyle değil. Yani fiziksel organizasyonu düşünecek olursanız eee Primary memory'nin bir matris şeklinde bir yapısı var ve eee yani DDR RAM'lere matris üzerinden erişiyoruz. Biliyorsunuz önce bir satır koordinatı gönderiliyor. Daha sonra işte adres basa bir satır row adres eee değeri gönderiliyor. E ardından eee kolonlardan bir tanesini se etmek için işte kolon adres değeri gönderiyor. Yine adres eee line kısmına adres bas üzerinden. Sonra işte read işleminin kontrol sinyali gerçekleştiğinde bu satırla sütunun kesiştiğin matristeki kesiştiği noktada yer alan kısım bize eee okunmuş bilgi olarak geliyor. Şimdi buradaki gösterimlerde biz odayı biraz daha eee basitleştirmek için bunu bir aray gibi gösteriyoruz. Kimi gösterimlerde bu main memory kimi kitaplarda eee yani cash'le uyumlu olsun diye Cht'teki kısım aynı ya. Buradaki blok gösterimi eee yatayda gösterebiliyorlar. O kafanızı karıştırmasın. Mesela bu bizim kitabımızdaki gösterim dikey bir gösterim. Yani V0, V1, V2, V3 yani W0 1, 2, 3 wordleri eee dikey olarak yerleşmiş ve bunlar bir blok sıfırı oluşturmuşlar. Yani dör tane Word olmuş. Bu arada eee birçok problemde kolaylık olması açısından daha önce bahsetmiştim bu Word tanımını işlemcinin eee aslında üretmiş olduğu verinin büyüklüğü ile alakalı bir bilgi bu. Word eee Word size genellikle bu tarz işlemlerde bir Word 1 byte gibi düşünülüyor. Eee bunu da eee söyleyeyim. Yani eğer herhangi bir şey belirtilmemişse word size'ı eee byte size olarak düşünebilirsiniz. Mesela şuradaki açıklamada bile words ortes şeklinde ifade etmişiz. Çünkü buradaki bütün makinelerin en basitlik açısından eee işte byte address işte ya da word addressable diyelim. Zaten word addressable hepsi de byte addressable olduğunu eee söylüyoruz. Eğer bunun dışında bir durum varsa bir Word'ün kaç tane byt'tan oluştuğunu da ekstra belirtmemiz gerekiyor. İşlemlerde de bunu ekstra göz önüne alarak işlem yapmamız gerekiyor. Yani sadece bölme işlemlerinde eee bu tekrardan hesaba katılacak bir parametre olacak. Şimdi eee burada birtım parametreler var. Bu bunlara geçmeden önce ben bunu kendi şe çizimimle göstermek istiyorum. Şimdi örnek üzerinden çünkü şuradaki eee bu 2 üzeri s + w'lar, w'lar, s + vitler vesaire bunları bir anda anlamanız zor ama bir görsel üzerinden, bir örnek üzerinden gidersek çok daha basit anlayacaksınız. Şimdi arkadaşlar şöyle bir yapımız var. Eee ben genellikle kitaplarda da kullanılan işte 128 byt'lık bir memory ve işte kaç olsun 16 byt'lık bir cash örneği üzerinden gideyim. Diyelim ki şöyle bir memoryiz var bizim. Buna main memory diyoruz. Main memoryde bizim eee bloklarımız var. Şimdi bunlar tabii birçok blok şöyle devam ediyor. Aşağı doğru gidiyor gidiyor gidiyor gidiyor. En son yine bir bloğumuz daha var. Diyelim ki bu main memoryimizin büyüklüğü 128. Normalde Word cinsinden söylememiz lazım ama Word byte'a eşit düşündüğümüz için e 128 byte cinsinden bir eee boyutu verdik. Yani eee toplamda 128 tane erişebileceğimiz hücre var bunun içerisinde. Fakat bunlar hücre değil. Bu çizmiş olduğum dikdörtgen bloklar birer adı üzerind blok ve her bloğun içerisinde de n tane farklı eee byte olabilir. Eee bunu tanımlayan ifade ise kısaca BS dediğimiz block size. Şimdi kolaylık olması açısından block size'ı ben 4 byte olarak ifade edeceğim. Yani her bir blok içerisinde toplamda 4 tane de byte olacak. Bakın yani şuradaki eee şöyle göstermiş olayım. Şuradaki her bir byte eee bloğun bir adet bytteına karşılık geliyor. Eee şimdi burada blokla alakalı olarak şöyle bir yeşilde göstereim onu da. Şurası bir saniye şöyle. Evet şurası 0 nolu blok. Şurası 1 nolu 2 nolu 3 nolu yani yataydaki şu tüm bloğu kastediyorum. Bu şekilde gidiyor. Eee şimdi kaç tane bloğumuz olacak? Hemen bunun hesabını yapmak istersek bakın buradaki bütün işlemler eğer bu görseli iyice kafanızda oturursanız çok basit işlemler. Toplam memorimizin kapasitesi 128 byte ise 128 de kaça karşı kıy eee 116 30 64 128 7 2 üzeri 7'ye karşılık geliyor değil mi? 128 dediğimiz şey Dolayısıyla bizim 2 üzeri 7'yi yani memory kapasitemizi block size'ımız olan 4'e yani 2 üzeri 2'ye böldüğümüz zaman 2 üzeri 5 tane eee bu da kaç olacak? Eee 128 byte dedik. 4 2 üzeri 5 de 32 mi yapıyor? Toplamda 32 tane eee bloğumuz olacak. Dolayısıyla şuradaki son blok adresi 31 olmuş olacak. Ama bunun içerisinde de eğer adreslemeyi biraz daha byte cinsinde gösterecek olursak eee şurası 0ın byt 1 byt 2 3 byt 4 bu şekilde gittiğini kabul edeceğiz. Bu sadece sanal bir gösterim bu arada. 4 5 6 7 8 9 10un tamamını ilk kısım için yazayım. 11 12 13 14 15 dedik ve en sonda 128 byte olduğu için tabii son kısmını şeye eklememişiz. Eee blok içerisindeki 4 tane byt'ımızı şuraya eklemedik ve bunu içerisinde de eee 127 eee byte, 126 byte, 125 bytte ve 124 byt şeklinde bir yerleşim olacak. Üstteki de yine tam yani diğer şeyleri tahmin edersiniz. Şimdi yapı bu şekilde. Direct cash mapping'de memory'nin bölünmüş olduğu bloklar bu şekilde ifade ediyor. Bir memory eee işte byte cinsinden her bir bytea erişilebilir olacak. Eee ve imizde block size adını verdiğimiz bir değer olacak. Bu size'ı şeyle karıştırmayalım. İşletim sistemlerinde daha sonra göreceksiniz. İşte orada bir page size olacak, frame size olacak. Uygulamaların çalışması sırasında o farklı bir hikaye. Burası farklı bir burası computer organization tarafı. Burada block size işte 4 byte dediğimiz zaman her bir blok içerisinde 4 tane byte olacak. Dolayısıyla hemen yine dijital dizayig'a geri dönelim. Burada bu 4 byt'ın herhangi bir tanesine benim erişebilmem lazım. Yani E örneğin şöyle siyah renkli seçeyim. Diyelim ki ben, eee, şu 3 nolu bloktan bahsediyorsam eğer 3 nolu bloktan bahsediyorsam eee, 3 nolu bloğun eee, içerisinde yalan 0, 1 2inci ve 3üncü bakın her bir blok kendi içerisinde 0a göre eee, adresleniyor. Dolayısıyla 3ünc bloğun ilk bytı aslında burada 12 memoryin 12 bytına karşılık geliyor. Yani o şekilde bir relative adresim olduğunu düşünün. Eee dolayısıyla ben burada 3üncü eee bloğun ilgili elemanlarına ulaşabilmek için yine dör tane bu adresi kullanmam lazım. 0, 1ci, 2inci. Yani bunlar eee şöyle düşünün. 3üncü blok içerisindeki adresler eee 4 tane bloktan oluşuyor. Ben d tane bloğu abdestleyebilmek için kaç bite ihtiyaç duyarım? 2 bite ihtiyaç duyarım. Yani buradaki bütün adresler aslında şu formatta olacak. Eee 0 0 1 0 ve 1 başka ihtimal yok. Yani buritle gösterdiğimiz zaman bu dör tane eee adresi her bir blok içerisinde ki bunu teknik olarak offset adres diyoruz. Offset bilgisi olarak kullanacağız. Dolayısıyla ben 3ünc bloğun eee işte 3üncü bloğun eee 1inci elemanı dersem 0 elemandan başladığı için 1inci elemanı 13'e karşılık gelecek gibi. Bu şekilde hesaplama yapacağız. Şimdi bu bize neyi sağlıyor? Şimdi bizim şu sol tarafta bir yerde CPU dediğimiz işte central process unitimiz var. Central processing unit eee bir virtual adres üretiyor. VA üretiyor. Şim burada bir VA'imiz var. Bir PA'imiz var. VA dediğimiz şey virtual adres. PA dediğimiz şey physical adres. Bizim amacımız bu virtual adresi physical adrese bir şekilde metmek. Tabii burada e virtual adresle physical adresin bir şekilde aynı olduğunu da düşünüyoruz. Ama şimdi bu üretmiş olduğumuz virtual adres ya da bu adres değeri kaç bitlik olacak? Şimdi bu baş başka bir problemi ortaya çıkartıyor. Bu CPU bu memory eğer kullanıyorsa bu memoryeki her bir byte'a erişebilmeli. Yani 0 byt'tan 127 byte'a kadar bu toplamda 128 byt'lık bütün alana erişebilmeli. Dolayısıyla 128 byte'ı birden adresleyebilecek bir bit sayısına ihtiyacı var. Yani buradaki CPU çıkışının toplamda 128 byt'ı adresleyebilecek eee bir bit sayısına ihtiyacı var. Bu da kaç olacak? İşte 2innin katlarıyla gidiyoruz. 128'e ulaşıncaya kadar 2 4 eee pardon 4 8 16 32 64 128 toplamda 7 bite ihtiyacımız var 128 tane adresi oluşturabilmek için. Şimdi ben bu adresi şu şekilde buraya bir blok şeklinde gösteriyorum. Yani toplamda şöyle buraya doğru geldiğini düşünün. Eee 128 bytte'ı adresleyebilecek. Dolayısıyla benim toplamda 7 bite ihtiyacım var. Yani C diyor. 7 bit üretmeli ki bu 128 tane byt'tan herhangi bir tanesine ben erişebilim. Şimdi ikinci durum şu. Ben eee şimdi burada eee bu 7 bitin 2 bitini offset adresleme için kullanacağım. Yani şuradan bunu kesiyorum. Buraya 2 yazıyorum. Burası offset dediğimiz kısım ya da blog adresim olarak da geçiyor. Bak offset yani bir blok içerisindeki adresleme amacı ile kullanacağım bit sayısı. Çünkü bu 7 biti parçalara böle böyle gideceğim. 2 bit'i bu amaçla kullanacak. Yani işte şu 0ıncı mı, 1inci mi, 2inci mi, 3üncü mü eee byt olduğunu buradaki 2 bitlik alanla algılayacağım. E geriye kaç bit kalıyor? Şuraya toplamda 5 bit kalıyor. Şimdi başka bir noktaya daha gidelim. Aslında bu 5 bit ne biliyor musunuz arkadaşlar? Hemen baş dersin başında söyledim. Şurada hesapladığımız 2 üzeri 5'teki şu 5 sayısı. Yani şurada 0 ile eee şöyle diyeyim. im şurada 0 blok 1 2 3 blok dedik 31 blo kadar geldik ya toplam 32 tane blok yani 2 üzeri 5 tane blok dedik ya işte o 5 buradan yani burada 2 üzeri 5 tane blok oluşuyor eee ki zaten teknik olarak şu kısma biz block number diyoruz sağ taraftaki kısma da offset eee ya da block offset ismi veriliyor. İkisi toplamda 7 bit yapıyor. O da 128'e karşılık gelecek. Eee buradaki 2'nin anlamı blok içerisindeki adresleme. Buradaki 5'in anlamı Hangi blok? Memurdaki hangi bloğa biz erişmek isik? Mesela çok çok basit bir e örnekle e şey yapalım burada eee işte ne olsun? Şöyle bir yeşil renk yazayım. Örneğin 7 bitlik bir sayı üretti CPU. 0 0 eee 0 1 0 kaç oldu? 3 4 5 6 7. Böyle bir sayı ürettim. Şimdi normalde bu sayı kaçtır arkadaşlar? 2 4 8 12 13 diye bir yani tek olarak bu sayı 13 gibi bir sayı değil mi? Yani binary olarak bunu desimala çevirirsek eee 13'e karşılık geliyor. D harfine karşılık gelecek. Şimdi eee peki bunu şuradaki gösterimde olduğu gibi bölersem yani şuradan kestiğimiz zaman bu neye karşılık geliyor? Bakın blok numarası 3 offseti 1. Yani 3ün e bloğun 0 elemanı buydu. 1 elemanı şu bakın yine 13'ü elde ediyoruz. Anlaşıldı mı? Yani buradaki kullanım şekli bu. Sayı kendi içerisinde bölündüğü zaman işte şuradaki kısmı bir böldük. Buradaki kısmı böldük. Sol taraftaki değer yani 0 0 eee 1 1 değeri şu kısım 3 sayısına tekabül ediyor. O da blok sayısı. Şu kısım block number'dı biliyorsunuz. Eee ilk 5 bitimiz block number'ı verdi. Sonraki 2 bit ise bloğun içerisindeki relatif e byte numarası. O da 01 denmiş. O da buraya kaç geliyor. Dolayısıyla 3ün blok 0 1 eleman dediğimiz zaman 13'e karşılık gelmiş oluyor. Başka bir tane daha örnek yapalım. Eee yine şunu yapalım işte. Mesela 2inci bloktan bir örnek vereyim. 2inci blok örneği vermek istiyorsam mesela direkt olarak buraya 0 1 0 yazdım. Atıyorum eee 1 diye şöyle bir şeymiş olan. Şimdi yine burada da şöyle kestik. Şu kısım ve bu kısım eee 2 nolu bloğun 3 bytı yani şurayı aldığımız zaman 2 nolu bloğun 0 1 2 3 şuna karşılık geliyor. O da 11 olması lazım. Dikkat ederseniz şunun sayı karşılığı yani şuradaki ifadenin binary ifadeninin decimal sayı karşılığı da 2 4 8 2 daha 10 daha 11 şeklinde olacak. Bakın bu gösterim aslında bu bize neyi sağlamış oluyor? Aslında veriyi eee hani byte byte işlemiyoruz da blok bazında çünkü cash mekanizmalarının tamamında bu eee yöntem uygulanmakta İşte daha sonra göreceğiz işte cash'le ilgili birtım locality principle vesaire gibi özellikler var. Yani siz memoryde bir lokasyona ulaşıyorsanız yakın zamanda o lokasyonun sağında solunda bulunan lokasyonlara da istatistiksel olarak ulaşma ihtimaliniz yüksek. Yani bir mesela bunun bir aray olduğunu düşünün. A'in ilk elemanına ulaştıysanız bu 11 eleman bile olsa işte e 12, 13, 14, 15'e de mutlaka ulaşacaksınız demekti bir şekilde. Yani istatistiksel olarak böyle bir olasılık var. var. Cash aslında bu olasılığı kullanarak eee bu veriyi hız daha hızlı bir ortama blok halinde çekip üzerinde işlem yapmamızı sağlayan bir eee hızlandırıcı eee özellik. Şimdi burası anlaşılmıştır herhalde diyorum. Şu örnekleri silmiş olalım. Şimdi gelelim burada asıl bu many to one relationship'in yaratmış olduğu soruna. Şimdi eee şunun ismini de yazalım. Şimdi buraya offset dedik. Buraya da eee Blog adres diyoruz. Şu kısım blogdr diyelim. Tamam. Burası da offset demiştik zaten yalnız. Eee, şimdi şurada şöyle bir problemimiz var. Şu an ne kadar cash ile alakalı hiçbir şey yapmadık dikkat edersiniz. Sadece main memorydeyiz. Main memory bloklara bölünmüş durumda. Block size değişirse kaç tane blok olacağı değişiyor. Tabii burada mutlaka block size ile memory size arasında 2innin katları üstünden bir ilim bir eee ilişki olması gerekli. ekte. Aksi halde gereksiz yere bir bit kullanımına vesaire sebebiyet verilebiliyor. Ya bu sebeptendir ki hani bilgisayar sistemlerinde hep ikinin katları aslında düzenli bir şekilde kullanıyor. Yoksa e başka bir eee gereksiz bitsa orada işte atıyorum CPU 8 bit üretse gerçekten 8 bit hiçbir işe yaramayacak. Boşa üretmiş olduğu bir bit olacak. Gereksiz bir kullanım. Şimdi bunun yanında dedik ki tabii direct cash mapping'de bir de cashşimiz var. Cashimiz olmalı. Cashimizi de burayı çizelim. Tabii relative olarak çok daha küçük bir alan olacak keş Orada cash diyelim. Şimdi eee main memorydeki bir bloğu komple biz cash tarafına aktaracağımız için hani bir istek diyelim ki mesela şöyle bir şey diyelim. Ben diyelim ki memory'nün 10 bytına ulaşmak istiyorum. Şimdi memoryunu tamam 10 güzel bir örnek olmadı 6 diyelim. 6 bytına ulaşmak istiyorum. Şimdi bu durumda CPU gidecek eee 7 bitlik bir eee adres üretecek 6'yı göstermek için. 6'yı nasıl gösteririz? 0 0 0 eee 1 1 0 mı oldu? Kaç oldu? 2 4 6 7 tane. Evet. Şimdi bakın bunun karşılığı 6 biliyorsunuz değil mi? Hani 1 0 6'ya karşılık geliyor. Şimdi eee CPU bu adrese erişmek istediğinde hemen şunu şöyle bakalım. Gidip 1 nolu Gloo'a erişecek. Bunun da 2inci elemanına işte 1 nolu glu 01 2inci elemanı burası oluyor. 0 indeksi bir yapıda işte 6'ya erişmiş oldu. Fakat 6'ya eriştiğimizde sadece CPU eee tamam CPU sadece 6'ya yarışmak istiyor ama arka taraftaki organizasyon yani cash mekanizması bu altının bulunmuş olduğu bloğun tamamını alıp 5'e yerleştiriyor. Çünkü eğer sen 6'ya eriştiysen muhtemelen bu blok içerisindeki diğer elemanlara da erişme ihtimalin var. Tabii burada 7 ise 8'e erişme ihtimalin var deyip bir sonraki O bloğu almıyor ama eee 7 ise belki 4 yani 4 5 6 da eee onunla birlikte cas yerleşiyor. Tabii bu yerleşme için ne demiştik başlangıçta? Cash'teki line size adını verdiğimiz cashşin içerisinde line'lar var. Mesela şöyle 4 line'dan oluşan bir cash diyelim. Şimdi bakın bunu baştan 4 line diye ben eee ürettiğim için cashin siz'ını da otomatik olarak belirlemiş oldum. Çünkü neden? Çünkü block size'ımız bizim 4 byte. O zaman buradaki her bir line 4 byt'tan oluşacak. Dolayısıyla eee işte line şuraya bu tarafa yazalım. L0 L1 L2 L3 isimli eee line'larımız olacak. Bu arada şu oku şuradan silelim. Yanlış bir yeri gösteriyor. Eee evet. Şimdi L0, L1, L2, L3 isminde 4 tane line'ımız oldu. Her bir line'da toplam 4 byte kapasiteye sahip. Çünkü block size'ımız 4. Yani şuradaki memorydeki her bir bloğun kapasitesi 4. byt. Dolayısıyla cash line size'ımız da 4 byte. Şimdi eee bu nedenle ben burayı da yine şu şekilde bölebilirim. Yani o line'ların her bir line'ın içerisine de 4 tane byte geliyor. Şimdi burada yerleşim nasıl olacak? Bu many to one relationship nasıl olacak? Ona bakalım. Şöyle bir şey oluyor arkadaşlar. Şimdi dedik ki buradaki 5 bitlik adres. 5 bitlik adres 5 de biraz fazla olmuş ama neyse. Şimdi 5 bitlik bir adresin blokların adreslerini izleyelim. O 5 bitlik adres biliyorsunuz şuradaki 0 1 2 3 ve 31'e kadar olan sayıları üretiyor 5 bitte. Dolayısıyla eee başlangıcı şöyle o adresleri şuraya yazayım. 0 0 0 0 0 şeklinde 5 adres. 0 0 1 0 şunları biraz şöyle hızlandıralım. Hepsini yazmayacağım merak. Bekleyin. Şurası 1 0 0 sayadım. 0 0 0 0 1 0 1 kısmını doldursak yeterli. 1 0 böyle devam ediyor aşağı doğru. Yani 31 tane toplam 32 tanesinin devam ettiğini düşünün. Şimdi arkadaşlar bu noktada eee başka bizim şu hani blok adres diye ifade etmiş olduğumuz şu kısım vardı ya 5 bitlik. Bu 5 bitliği de aslında eee bölmeye başlayacağız. Yani yeni işimiz bu 5 bitlik kısmı nasıl eee böleriz? Çünkü buradaki ifadeyi de ikiye bölmemiz gerekiyor. Çünkü işin içerisinde cash line'ları girecek. Şimdi öncelikle ilk soru şu. Eee benim hani nasıl memory tarafında, eee, blokları adreslemek için burada 5 bit'i kullandım ya 0'la 31'e kadar olan kısım için. Şimdi her bir cash line'ı da bu CPU'nun üretmiş olduğu adreste, eee, üretebilmem lazım. Yani kaç tane cash, cashş var burada? 4 tane. E, 4 tane cashişi ben adresleyebilmek için kaç bite ihtiyacım olacak? Yine 2 bite ihtiyacım olacak. Dolayısıyla şuraya bir 2 bitlik Bir kısım daha ekledim ben. Bu da cashteki bir line'ı göstermek için. Yani bu line'lar da nasıl gösterecek? 0 01 line'ı, 1 line'ı ve 1 line'ı. Yani şuradaki line'lar her bir line'a karşılık geliyor. E şimdi e 2 daha toplamda şurada 4 biti kullandık. Toplamız 7 bitti. O zaman geriye 3 bitlik bir kısım kalıyor ki buna da biz terk diyoruz. Şimdi bu tag bitin anlamı şu arkadaşlar. relationship'te eee birden fazla memory bloğu aynı keşe yerleşmeye çalışacak ve bu aynı yere eee yerleşmeye çalışma aşamasında bizim bir şekilde keşteki blogun gerçekten aradığımız blog mu değil mi? Bunun eee kararını vermemiz gerekiyor ve bunu anlayabileceğimiz tek nokta tek kısmı. Şimdi şöyle söyleyelim. Bakın eee bölüm 3 2 şeklinde oldu. Yani 7 bitlik bir bölme işlemi şuradaki 7 bitlik bir bölme işlemi 3 2 şeklinde parçalandı. Yani bu bu sistemde bu işlemci ve bu memory ve bu cash cashin olduğu sistemde 3 bitlik bir tag var. 2 bitlik bir line adres var. Şuraya onu yazmadık. Line diye onu belirtelim. Şurası cash line adresi. Şurası offset. Yukarıda da yazıyor zaten. Eee şurası da yine tek kısmı. Şimdi bu yapıya göre üretilen eee Herhangi bir adres mesela şunu şöyle silelim parçalarını. Artık bunu e bölme işlemine tabi tutarken şöyle 2 biti buradan sildik. 2 biti buradan yaptık. Şurada 3 bitlik kaldı. Pag'imiz 0, line adresimiz 1. Eee, block offset adresimiz de 2 olacak şekilde bir yerleşime karşılık geliyor bu. Şimdi neden böyle? Öncelikle şu şeye bakalım. Şu line adres kısmına bakalım. Bakın arkadaşlar, bizim hangi bitlerimiz line adresi gösteriyor. Yani şuraya 0 bit, 1 2 3 4 5 6 diye eee adresi verirsek 2 ve 3 bitler yani şuradaki bitler bize line adresini veriyor. Dolayısıyla eee şimdi şurada biz şu 5 bitlik kısmı şurada ifade ettik. 5 bitlik kısmı ifade ettik. Bu 5 bitlik kısım içerisinde bu kaça karşılık geliyor? En sağdaki 2 bite karşılık geliyor. Şurası değil mi? Yani şuradaki ifade bakın şurada bir 0 var. Şurada bir 00 var. Şurada bir 00 var. En sağdaki 2 bit. Aşağıya gidiyoruz. Bir noktadan sonra bir tane daha olacaktı vesaire. Şimdi bakın bu 0lar şunu demek. Eee yani üretilen bir blog adresinde 0 ve 0 eee bizim cashine adresimiz. Başka bir ifadeyle eee şuna biz eee şey ismi verirsek Line blok adreses isini verirsek burası 0 blok. Burası 1inci burası 2inci 3ünc 11 12 diye gidiyor. Ne zamana kadar? 31'e kadar gidiyor aşağıya doğru. Değil mi? Şurada devam ettiğini düşünürsek. Şimdi 0 blok için şurası bir blok adresti ya 5 bitlik blok adresi. Yani şuradaki adresti. Bu 0 blok için sağdaki 2 bit bize bu bloğun statik olarak yerleşeceği eee cashin adresini gösteriyor. Yani cash line 0'a yerleşecek. Yani şurasını aslında line numaralarını desimal değil de 0 diye gösterirsem şurayı 0 1 şurayı 1 0 şurayı da 1 dersem aynı şeye karşılık gelebiliyorsunuz. 0 1 0 1 eee bu durumda 0 blok Yani şu blok şuraya yerleşecek. Aynı şekilde 4üncü blokta bakın yine şuradaki işte 4 diyelim. 4üncü blok da buraya yerleşecek. Aynı şekilde 8. blok da gelip şuralarda bir yerlere 8 blokta gelip buraya yani many to one relationship'tan bahsetmiştik ya. Çünkü memory size çok daha büyük. 5 çok daha küçük bir alan. Dolayısıyla 0ın 4 8 tahmin edersiniz ki işte e 4 daha ekledik. 12 yerlerde şurada çünkü 12 sayısında da dikkat ederseniz sağdaki 2 bit 0 olacak. Yine 16 yine 0 olacak vesaire. Bunların hepsi buraya geliyor. 16 işte eee 4 daha 20 gelecek. 24 gelecek 28 gelecek. Toplamda eee 0ıncı geldi. 1 2 3 4 5 6 7 8 tane eee Blok cash line 0a yani 00 adresli line'a yerleşmiş oluyor değil mi? Ya burası net. Çünkü şuradaki 30 0' la 31 arasındaki bu 32 tane bloğun eee 8 tanesinde son 2 bit 0 şeklinde bitmiş olacak. Buradaki bu 2 biti aslında şuradaki 2 bit olarak ortadaki iki line adresi olarak algıladığımız için yani 5 bitin 2 biti çiğ diye algıladığımız için bunların hepsi 0, 4, 8, 12, 16, 20, 24 ve 28. bloklar gidip yani toplamda 8 tane blok gidip cashl 0a yerleşecek. Bu ne demek? Eğer ben cashl 0 içerisinde bir byte bilgisine sahipsem bu byte buradaki 8 tane bloktan herhangi birisine ait olabilir. Yani cash line içerisinde eee 0 1 2 3 verisi de olabilir. Yani buralar ben isim de Ahmet Mehmet diye Ahmet diye her bir hücreyi bir harf de koyabilirdim. 0 1 2 3 de olabilir. Ya da işte şurada devam ettiğimde yer alan işte 16, 17, 18, 19 da olabilir. Yani şurada 16, 17 da olabilir. E bu durumda CPU bu farkı nasıl algılayacak? Bunu anlayacağı tek nokta arkadaşlar tag dediğimiz ki bu tag aslında CPU cash kapasitesinin de eee ötesinde bir kavram. Yani bunu biz eee, şu şekilde gösteriyoruz. Buraya kitaplarda da bu şekildedir. Her bir bu cash line'ın yanında ekstradan bir flag gibi düşünün bunu. Bu kısma da tag kısmı diyoruz. 3 bitlik tag kısmımız var. Şu tegi hatırlarsanız en soldaki yani blok adresindeki soldaki 3 bitlik kısım bizim tagimizde. Dolayısıyla mesela diyelim şimdi tek kısmı şuradaki ifadede nereye karşılık geliyor? Bakın oradaki şu 3 bitlik kısma karşılık geliyor. Şimdi dikkat ederseniz bakın bu sayıların 3 bitlik adreslerin bakın 00 geldi buradan şuradan şöyle işaretlenmişim point 00 bakın bu te 1 sonraki tek 0 1 0 bakın 0 1 2 3 4 diye gidecek oradaki tekler bakın orada da bir yine bir belli bir düzen içerisinde eee tek numaralarımız geliyor. Bu sayede eğer eee cash içerisinde atıyorum 00 1 00 var. Bu durumda bunun tegi de 001 olmak zorunda. Yani ben eğer şuradaki 4 nolu eee bloğu keşe yerleştirmişsem bu durumda 4 nolu bloğun eee keşe yerleşim şekli nasıl olmuş oluyor? Eee kendi tegi 001 buraya gelmiş oluyor. Eğer ki 8 nolu e tag buraya gelmiş olsaydı hemen silelim. Bu durumda buraya gelecek olan tek 0 1 0 olacaktı. Şimdi 0 1 0 olduğu zaman işte 8 nolu eee blok şurada bir yerde. İçerisinde de işte Ahmet yazıyor diyelim. Ah her bir hücreye bir tane harf gelmiş. Ah M diye burada yazmış. T de şuradan devam ediyor işte vesaire. Şimdi bu durumda 8 nolu blok buraya geldiği için bunun içerisinde ne olacak? Ah m diye. Bunun value'su yani değer kısmı o memoryün içerisindeki değer. buraya yerleşmiş olacak. Peki şimdi diyelim ki CPU bir adres üretti. CPU dedi ki eee 0 nolu adresi üretiyorum işte 0 0 Hatta böyle 0 olmasın da atıyorum 1 0 şeklinde bir adres üretti. 6 bir tane daha olacak pardon 7. Şimdi bu 7 bitlik adreste şöyle bölmeleri yaptık. Bölmeleri yaptık. Offsetimiz burası. Line kısmımız burası. Tagimiz burası. Şimdi off e blok adresimiz 0. Bu belli. Eee dolayısıyla 0ın blok içerisinde biz eee 2inci elemanı arıyoruz. Yani CP'nin üretmiş olduğu adres bu olduğu için işte 0 bloktaki 0 1 2 yani şurayı arıyoruz aslında. Şu kısmı arıyoruz. Peki cash'te var mı? Şimdi geleceğiz cashşe. E bunun line numarası kaç? Line numarası 0. Line numarasına 0'a geldik. Keşte orada Ahmet diye bir bilgi var. Şimdi bu ahme mi yoksa 0 1 2 3'ün olduğu ilk blok mu? Bu ayrımı yapabilmek için direkt olarak ilk başta yapmamız gereken işlem tek karşılaştırma işlemi. Buranın tegine hemen kırmızıyla işaretleyelim. Buranın tagi 00 yani işlemcinin üretmiş olduğu adresteki tag 00. Cash'teki tag ise 010. Bunlar match etmiyor arkadaşlar. Match etmediği zaman e cash'teki bilgi bize yaramıyor demek. Yani evet o cash line'da bir blok var. Ama o blok bizim aradığımız blok değil. Bu nedenle ne yapmamız gerekiyor? İşte o eee blun üzerine gidip ilk memory bloğunu işte buradan bir burada bir cashmile karşılaştık aslında. Hani aradığımız şu adres'te çıkmadı. Çünkü direct cash mapping'de her bir memory bloğunun tek bir eee gideceği adres var. Bütün eee işte 0, 4, 8, 12, 16, 20, 24, 28 bloklar eee 0 adrese gidiyor. Aynı şekilde diğerlerine bakacak olursanız işte 1inci, 5, 9un, eee, 13 diye devam eden bloklarda işte cashl 1'e gidiyor. Çünkü sağdaki o 2 biti 1 şeklinde bitmiş. Ya başka bir ifadeyle blok sayılarını hani şöyle, eee, kolaylık olsun diye şunu da söyleyebiliriz. Şurayı silelim. Turuncuyla şimdi blok sayılarını yazacağım arkadaşlar. Turuncu renkte işte 0 blok, 1 blok 2 blok 3ün blok 4 blok 5 blok 6 eee 7 Bakın bunlar blok sayıları bu şekilde de ifade edebilirsiniz 10 11 12 13 14 15 devam eder yani buraya sığdırma gibi bir şey yok yani. 12 tüm burası için söylüyorum. 12 15'ten sonra mesela 16 blok tekrardan işte şuradan devam ediyor. 17 18 19 20 22 23 şeklinde bu. Bunu devam edin. Ne zamana kadar devam et diyoruz? 31'e kadar bu şekilde vertical bir şekilde yani dikey bir şekilde yerleşim yapabilirsiniz. Aynı şey çıkıyor. Bakın yatayda. Şimdi tekrardan bakalım. Yatayda bakarsak 0 4 8 12 diye gitti. 1 5 9 13 vesaire diye olanlar 1 line'a. 2 6 10 16 diye olanlar eee 2inci line'a. 3 7 11 eee 15 şeklinde gidenlerde 15 19 diye gidenlerde son line'a yerleşmiş oluyor. Yani burada Aki bu 4eli kısıtlı değil. O yanlış anlaşılabilir öğrenciler tarafından. Yerleşimde dikey bir şekilde blog adres yerleşimi yaparsanız hangi bloğun hangi line'a gideceğini de çıkartıyorsunuz. Ya basit matematiksel işlemler aslında bunlar. Sadece farklı gösterimleri gösteriyorum size. Şimdi slayt biraz karışık gibi oldu ama yani umarım kafanızı karışmamıştır. Yani çok eğlenceli bir konu. Çok rahat anlaşılabilen bir konu. Hani offsetti buluyorsunuz blog içerisindeki adresleme için. Eee line numarasını buluyorsunuz. Cash'teki line adresini bu. olmak için. Bir de casin içerisindeki bu lineları birbirinden ayırt edebilmek için de eee tek kısmımız var. Dikkat ederseniz tek 3 bitten oluşuyor burada. Onu söyledim mi bilmiyorum ama şimdi 3 bitten oluşuyorsa hani burada 8 tane yani 0, 4 8 12 16 20 24 28 diye 8 tane blok gelmişti ya. Zaten 8 tane bloğu birbirinden ayırt edebilmek için eee 3 bite ihtiyacımız var. Yani bu bunları ayırt edebilmek için yani şuraya 3 tane bitle biz 8 tane farklı bloğu ayırt edebiliyoruz. Ya o da bunun başka bir tarafı. Malisel olarak onu destekleyen başka bir tarafı. Eee oradaki 3 bitin anlamı o. 8 tane farklı bloğu adresleyebilmek. Şimdi bir ara verelim arkadaşlar. Ya da blog da yapabiliriz. Az bir şey kalıyor. Direct cash. Bugün direct cash mapping'i bitirip yarın eee asociative set asociative'e geçeceğiz. Nasıl yapalım? Ara verelim mi? Devam edelim mi? Bir iki örnekle ara verildik. Ara verildik. He şimdi eee saat 1115 diyelim. 11.3'ta tekrardan başlayalım. Nerede kalmıştık? Evet, genel olarak yapı bu şekilde arkadaşlar. Eee, burada, eee, direct mapping'te, eee, bir takım belki soru çözümleri yapabiliriz ama kitabınızdan bir tane örnekle devam edelim. Şimdi burada gerçek bir sistem örneği var. Eee, şuradaki not önemli. Bu aslında birçok şeyi kafanızda oturtmak adına önemli bir bilgi. Birçok kitapta da bu e gösterim kullanılmakta. Eee, memory adres değerleri binary olarak gösterilmiş durumda. Yani şuradaki memory adresleri dikkat ederseniz bunlar binary. Diğer değerler ise hexadeimal olarak işte şuradaki ya da içerideki değerler ya da line numberları vesaire. Sadece memory adres değerleri binary olarak gösterilmiş durumda bu gösterimde. Şimdi burada eee benim az önceki şuradaki gösterimime biraz ters bir şekilde yani memory eee solda, cash sağda şeklinde eee bir yerleştirme kullanılmış. Şimdi bakın arkadaşlar, şimdi burada burayı nasıl anlamaya çalışacağız? Bu bir e memory organizasyonu, direct cash mapping organizasyonu. Şimdi öncelikle memorimizin büyüklüğüne bakalım. Eee, şimdi burada iki tane bilgi verilmiş. Biri 16 MB, biri de 32 bitlik bir genişlik şekli. Şimdi biliyorsunuz 32 bitte'a karşı karşılık geliyor. Eee yani 4 x 8 32 bit. Eee bu da şu demek. Eee bizim eee blok size'ımız 4 byt'tan oluşmakta. Yani bu genişlik e şuradaki genişlik 32 bitlik genişlik bize 4 byte eee olarak gelecek. Bu da bizim bir blok içerisindeki byt sayımız. 4 tane byte. Dolayısıyla Çok basit bir şekilde bakın şurada da görüyorsunuz. Adresleme kısmında 2 bitle biz bu 4 byte'ı çok rahat bir şekilde gösterebiliriz. Yani o kısmı bulduk. Ama asıl kısım şu. Eee 16 MB'lık main memory'den bahsediyoruz. Hatırlarsanız yine dijital dizayig referans vereceğiz. E 1 KB dediğimiz şey neydi? 2 üzeri 10'du. Geri kalan kısmını işte 2 KB diyorsak 2 üzeri 11 diye hemen bulabiliyorduk gibi. Eee şimdi buradaki ifade megb ise neydi? 200 20 ile gösteriliyordu. Buradaki ifade ise 16 MB yani 16 x MB bu da 2 üzeri 4 olacak değil mi? Yani şurası bize 16'yı veriyor. Şurası da 1 meg 16 tane 1 MB. Eee yani toplamda 2 üzeri 24'lük bir eee adres bilgisi bize gerekmektedir. Yani toplam 2 üzeri 24 byt'ımız var memorinizde dediğimiz Bu başka bir ifadeyle eee CPU'nun üretmesi gereken bit sayısı 24 bit olacak. Eğer ki şuradaki zaten memoryyi gösteriyorum demiş ya şuradaki ifadede eee buradaki bit sayısına bakarsanız yani buradaki bitler aslında bakın nibl'ar halinde bölünmüş. 4 bit 4 bit gidiyor. Şöyle dikkat ederseniz burada 6 tane nibble var. Yani 6 4 24 tane eee bitten oluşmak. Yani buradaki memory adresi 24 biten oluşmakta. Şimdi bu ilki bir kısmını çözdük. 24 bitimiz var. Dolayısıyla yani 24 bit dediğimiz şey neresi aslında? Bu CPU'nun oluşturmuş olduğu yani şuradaki bütün bitlerin sayısı 24. Zaten şuradaki rakamları toplarsanız işte 8 14 daha işte 22 2 daha 24 zaten onu verecek bize ende sonunda ama daha bu 8 ve 14'ün nereden geldiğini bulmadık daha bilmiyoruz. Şimdi burayı çözdük. Eee dolayısıyla eee burada işte eee sağdaki kısım 2 bit bize offsetimizi verecekti. dedik. Geri kalan 22 bitin yani şuradaki şu kısımda yer alan 22 bit'in nereden nasıl geldiğini henüz bilmiyoruz. Onu anlayabilmemiz için. Şimdi o kısım neyle alakalı? Block size'ile alakalı. İşte block size cashlak vesaire gibi birtım bilgilerden yararlanarak orayı da çözeceğiz. Şimdi şuraya gelelim. Burası ne? Burası cash. Cash'i burada göstermişler. Şimdi eee doğal olarak yani bizim memorimiz 32 bit ise cashşimiz de 32 bit olacak. Yani E block size, memuraki block size ile cashteki line size eee aynı olacak. Şimdi burada boyut olarak bakın farklı bir gösterim tercih edilmiş. Kilob, megb vesaire bir şey denmemiş ama 16 kiloline cash demiş. Yani 16K tane line'ımız var. Cash line'ımız var demek oluyor. Her bir line'ın 32 bit olduğunu biliyoruz. Yani 4 byte olduğunu biliyoruz ama 16K tane. Şimdi pardon nereye gittik? Heh. Şimdi 1K ne demiştik? 2 üzeri 10. E 16k ne? 16 x 2 üzeri 10. Yani 2 üzeri 4 x 2 üzeri 10. Oradan da 2 üzeri 14. Yani benim 14 bite ihtiyacım var. Niye gösterebilmek için? Eee 16K line cas gösterebilmek için. Yani 16K'yı gösterebilmek için benim eee 14 tane eee bite ihtiyacım olacak. 16'yı gösterebil 16K'yı gösterebilmek için 14 bit'i ihtiyaç. olacak. Yani şuradaki eee line numberları gösterebilmek için benim eee toplamda 14 bite ihtiyacım olacak. Ama dikkat ederseniz 14 sayısı yani 14 nereden geldi? 2 üzeri 4 x 2 üzeri 10'dan geldi. 2 üzeri 10 1 k demek. 2 üzeri 4 de 16 demek. Bu da 2 üzeri 14 yapıyor. Başka bir ifadeyle 16K yapıyor. Biliyorsunuz kilo dediğimiz şey işte 1000 gibi alıyorduk. Şimdi burada bir şöyle bir sıkıntımız var. Eee geleneksel yapıdan farklı olarak buradaki cash size ayarlanırken 2inn katlarıyla pek gidilmemiş. Yani yeni tamam 14 bit yine 2inin katı gibi görülse de tam olarak bizim istediğimiz 2inin katında değil o. Nasıl değil? Çünkü eee normalde bunun 16 olmasını bekleriz değil mi? Hani 2 4 8 2 yani 2in katı derken kuvvetleri diyelim. 2 4 8 16 geçmesi lazım. 16 yerine 14 yani daha düşük kapasiteli bir cash tercih edilmiş. Bu da line number gösteriminde şöyle bir adreslemeye sebep oluyor. Yani 14 bit olduğu için buradakinin her birisinde eee 4 bitlik nell'ar olduğunu düşünürseniz şunların 4 k 4 16 tane var burada ama en sondaki bit f'e kadar gitmiyor. Bakın dikkat ederseniz 3'e kadar gidiyor. Yani şuradan bahsediyorum. Şunu şöyle pointerla gösterelim. Şurada 0'dan başladık. Eee 3 F F F'e kadar gittik. Hani normalde biz hani e bu adresleme mantığında işte 2 bitim var 4'e kadar giderim. 3 bitim var 8'e kadar giderim. Ama 8'e kadar giderken 0'la 1 1 yani 00 binary değeriyle 1 1 binery değeri arasında 0' la 7 arasında gidiyordum. Normalde toplamda 8 tane oluyordu. E burada işte biliyorsunuz hani 1 1 durumları F'e karşılık geliyor. Dijital dizayndan hatırlayın. Burası da F oldu. Diğeri F olmuyor. Diğeri yani burada 1 2 3 3 eee 4/3 12 tane eee bit buradan geliyor. 3 tane de buradan gelecek ki işte bu en son eee 16K'yı tamamlayabilsin. Buradaki değer buna karşılık geliyor. Şimdi bu gösterimde biz 14 bitlik bu kısmı bulduğumuzda aslında yani şu line kısmını bulmuş olduk. Şuradaki 14 sayısının nereden gelmiş olduğunu bulduk. Offset'i zaten bulmuştuk. O 32 ile alakalıydı. Yani bir blok içerisinde ya da bir cash line içerisinde da kaç byte var? Oradan eee o 2 bit'i bulduk. 14 bit'i ise cash'te yani cash eee memoryde kaç tane line var? Şuradaki her bir line'ları linearı bulmaya çalıştık. O da 2 üzeri 14 tane line olduğu yani 16K tane. Dolayısıyla 14 bitte temsil etmemiz gerektiğini bulduk. E şimdi memorimiz 16 MB olduğu için buna da işte 24 bit gerekliydi. E 24 bitin 16 bitini zaten keşfetmiş olduğumuz için geri kalan 8 biti de bizim tageri ayırmakta bulacak. Bu şu demek. Tagimiz 8 bitse eee 2 üzeri 8 tane yani 2 üzeri 7 128 2 üzeri 8 256 tane memory bloğu ı cash line'ına map edilmiş durumda. Bakın 256 tanesi aynı cash line'ına map edilmiş durumda. Şimdi bu adresimi yaptıktan sonra geri kalan kısma yani dekomposit kısmı çok kolay. Çünkü hani şuralardan biz CPU'nun üretmiş olduğu adresleri ki onlar hani örnek şunları gösterebiliriz. Bunlar bir Örnek eee bu adreslemeye göre işlemi rahat bir şekilde yapabileceğiz. Şimdi hemen şöyle temizleyelim slaytı. Şimdi bakın şurası yine 24 bitlik bir adresti. Şimdi bunun bir de bakın şurada şu kısma bakacak olursanız bazı memory e bloklarının bazı cash line'lara yerleştiğini görüyoruz. Şimdi e bir memory bloğunun bir cash line'a yerleşebilmesi için eee şuradaki 14 bitlik adrese bakacağız. Şimdi öncelikle şuradaki kısım bizim 24 bitlik bir adresti. Bunun eee şuradaki 2 bitini bir atalım. En sağdaki 2 bitini atıyoruz. Daha sonraki 14 bit'i alıyoruz ki o da şu arada karşılık geliyor. Yani şu kısım bizim eee line'ımız, line adresimize karşılık geliyor. Bakın şuradaki eee bir üst satırdakinin bir üst satırdakinin line adresine bakacak olursanız Tamamen 0. Dolayısıyla bu gelip 0 alana yerleşmiş. Veri olarak zaten o memory bloğunda 1 3 5 7 9 2 6 varmış. O oraya yerleşmiş. Şimdi şuradaki için bakalım. Şuradaki ifadeye bir bakalım. Yine şuradan kesiyoruz. Offset kısmını attık. Eee şuradan atıyoruz. Zaten dikkat ederseniz tek kısmı burada eee grayout olarak gösterilmiş. Yani o ayrı bir eee alan şeklinde gösterilmiş. Eee, bir de aslında bununla ilgili tagory size diye bir kavram var. E, onu aslında geçen ders atladık söylemeyi. Eee, tag directory size dediğimiz şey de şu arkadaşlar. Hani dedik ya burada bizim bir cash memorymiz var. Şurası cash memory. Eee, şöyle kırmızıyla iyice belirleyim. Bu bizim cashşimizin kapasitesi. Atıyorum buradaki ne kadardı? 1 2 3 4 kere 4 16 byt'lık 16 byt'lık bir adresti. Burada yani cash kapasitemiz 16 byte. Şimdi 16 byte için bizim eee 1 2 3 yani 4 tane line'ımız var. 4 tane cashl'ımız var. Çarpı her bir tagde de 3 tane bitimiz var. Dolayısıyla 12 bitlik bir eee tek directory size'a ihtiyacımız var. Bu size cashin içerisinden değil arkadaşlar. Bu ekstra bir alan. Yani ekstra bir memori lokasyonu düşünün. Eee zaten bakın burada bunu kulakçık olarak ifade ettik. Şuradaki kısımlar hep ekstra bir alan. Yani buradaki 16 byte'a dahil olan bir 3 bit değil. Bu ayrı bir 3 bit. Eee bunun büyüklüğünü yani tag directory saysının büyüklüğünü de nasıl hesap ediyoruz? Bu ekstra alanın büyüklüğünü. Line sayısı 4 tane line var. Eee yani 4'ü de nereden bulduk? İşte line number burada 2 bitle ifade ediyorduk. İşte 2 üzeri 2 aslında o yani 4 tane line üretebiliyor ve her bir line'da da tek size olarak 3 bit kullanılmakta. Dolayısıyla toplamda 12 12 bitlik bir eee bakın bit byte değil ona da dikkat edin. 12 bitlik bir alan da tek directory size olarak kullanılıyor. Şimdi buradaki yapıya geri dönecek olursak ne dedik? Şuradaki örnek için bakıyoruz. İşte şu memory bloğunu bir bakalım. Bakın şimdi bu memory bloğunun eee şuradaki offsettii 00. Blog adresi ise bakın blog adresi şu kısım. Ortadaki kısım. Onun biner değerine bakacak. şurada bir tane 1 var. Dolayısıyla 1inci adrese yerleşecek. Ama bakın yerleştiğinde kendi tagini oraya atıyor. Bakın şuradaki tagne eee 2 4 8 eee 16 ama pardon bunu nibble olarak bakacağız. Bakın şurası 1 şurası da 6. Kolay hegadeimalı gösterir mi? Yani şurada bahsetmiş ya hegadeimal tutuyoruz diye. Direkt 1 ve 6 şeklinde şey yaptık. 1 ve 6 şeklinde. Bakın buraya geldi. Şuradaki yine 0 0 şeklindeydi. Aynı şekilde şuradaki yapıya bakalım. Bakın o da yerleşmiş. Şu memory bloğu şuradan kesmiş olduk. Bak kesmiş olduk. Bunun tegi yine 1 ve 6 olacak. Bakın aynı tag fakat farklı bir memory oluyor ve farklı yere geçiyor. Neden? Çünkü şuradaki blog adresi farklı. Blog adresi. Eee şöyle şimdi bunu şöyle hesap edeceğiz arkadaşlar. Blog adresine hesap edebilik. Yani daha doğrusu E, cash line adresini hesap edebilmek için. Bakın, eee, bu şöyle önemli. Şuradan onu turuncu renkle göstereyim daha iyi anlaşılsın. Eee, şu noktadan itibaren 4 yine bölüyorsunuz arkadaşlar. Şimdi böldüğünüz zaman buranın adresi ne? 0 1 1 1. Bunun karşılığı eee, pardon 0 1 1'in karşılığı 7 olacak değil mi? 1 1 0 karşılığı ne olacak? 2 4 8 12 14. O da E harfine karşılık geliyor. 1 0 ne? 4 8 12. O da C harfiydi. Burada sadece 0 0 kaldı. Onun başının da tamamen geri kalan kısmı yani onun biliyorsunuz sol tarafa 0ırları ekleyebiliyoruz. Sayıların sonuna istediğimiz kadar ekleyebiliyoruz. Dolayısıyla onun karşılığı da yine 0. Dolayısıyla bunun line adres karşılığı 0C7. O da zaten bakın şurada gösterilmiş durumda ve onun içeriği şuradan arılıyor. F E D CBA vesaire diye keşif. içerisine bu şekile gelmiş. Mesela burada kastedilen işte şurası 0 aslında şuradaki işte FE değeri eee şey olarak gelecek. Tek kısmında da bakın 16 var. 16 da şuraya yerleşmiş durumda. Yine şu ifadeye bakalım. Eee buradaki durumda ne var? Şurayı yine kestik. Burayı kestik. Eee buradaki dash line yerleşimi nasıl olacak? Şurası F. Şurası F. Burası F. Eee, burası ne oluyor? 0 1 şeklinde alacağız burayı. Burası da 3 olacak. Yani en son adres 3F f şeklinde oluşmuş oluyor. Yine tek kısmında da şöyle böldüğümüz zaman 1 ve 6 sayıları var. O da şuradaki tege yerleşmiş durumda. Dikkat ederseniz bakın tegin uzunluğu 8 bit. Onu zaten biz şurada 24'ten 14 + 2'yi çıkartarak zaten bulmuştuk. 8 bit olduğu için de yani hegisim olarak iki tane eee en'la gösterilmekte. Evet. Eee, isterseniz sonuncuya da bakalım. Sonuncuda, eee, hangisi yerleşmiş? Şu yerleşmiş. Üstteki kestiğimiz zaman şöyle parçalarabiliyoruz. Bakın oradaki kendi, eee, bölütlemesi bizi ilgilendirmiyor nereden kestiği. Biz 4 bit 4 bit ayrı bir şekilde kesmeyi yapıyoruz. 1 1 eee 0 şeklinde dediğimiz şey neydi? Yukarıda da yapmıştık. Şurada eee E harfiydi. 1 1 dediğimiz şey F harfi. 1 1 dediğimiz şey F harfi. 0 1 1 diyeceğiz. Bu da yine 3F şeklinde bir adrese karşılık geliyor. O da nereye gidiyor? İşte buradan gelip 3F dediğimiz adres şurası. Kendi içeriğini yani şuradaki memory bloğunu buradaki cash bloğuna koyuyor ve kendine ait şuradaki eee tek kısmını da yani FF olarak geçen tek kısmını da buraya yerleştirmiş oluyor. Ha bu şekilde eee bu e direct mapping'de eee yerleşin işte hangi bloğu nereye gidiyor eee ya bunlar aslında eee birden fazla eee bu tek bilinmeyenli denklem aslında arkadaşlar hani yapılan işlem böyle akla debe bir şey değil. Memory block size'ını gidiyoruz işte eee blog size'a bölüyoruz. Kaç tane bloğumuz var? İşte cash e kapasitesini blog size'a bölüyoruz. kaç tane cash line'ımız var? Eee, işte block size'ı kaç bitle temsil ettiğimizi buluyoruz. Offset bit sayısını buluyoruz. Cash line sayısını kaç tane bitle temsil ederizin cevabını buluyoruz. Bunu line kısmına koyuyoruz. CPU'nun toplam kullanması gereken bit sayısını işte memory kapasitesini adreslenmemesi gereken bit sayısıyla hesap edip e bu sayıları birbirinden çıkarttığımızda da tek kısmı karşımıza çıkıyor. Şimdi bütün bu bilgiler ışığında aslında mesela şuradaki yapıyı anlamak belki biraz daha şimdi kolay olacak sizin için. Eee, çünkü işte burada ne demiştik? Memory bir tane adres üretti. Bakın, tag'imiz var, line'ımız var, cash line'ı bu. Word'ümüz var. Word dediği kısım aslında Word offset adresi. Şimdi eee, teknik olarak bütün bu memory üretilen adres uzunluğuna S + W E deniyor. S kısmı eee blog adresini göstermekte. Yani tag ve line, tag + line dediğimiz kısım yani daha doğrusu şuradaki kısım eee, S'ye karşılık geliyor. W diye gösterdiğimiz kısım ise sağdaki kısım olarak karşımıza çıkıyor. Bu adres lengthimiz. Şimdi kaç tane eee byt'ı adresleyebiliriz? E burada şurada kaç tane bitimiz varsa yani S + W kadar biti 2 üzeri şeklinde gösterip o kadar eee adresleme yapabiliyoruz. Bunu block size dediğimiz şey tabii burada e offsette kaç tane bit kullanmışsak 2 üzeri e offset kadar da block size bilgimiz olacak. Aynı zamanda block size'ımız cash'teki line size'a da eee eşit olacak. Yani şuradaki bir line işte burada mesela 4 tane var. Dolayısıyla eee line size 4 byte diyebiliyoruz buraya. Eee aynı şekilde block size da 4 byte olmuş oluyor. Main memory'deki eee blok sayısı. Şimdi main memory'nin kapasitesi ne? 2 üzeri S + W kadar kapasitesi var, değil mi? Yani CPU çünkü S + W bit üretti. Dolayısıyla bununla 2 üzeri S + W kadar byte generate edilmiş. adreslenebiliyor. E şimdi bunu biz gidip de blog sayısına şurada bahsetmiştikte W'ya bağlı olan 2 üzeri W'ya böldüğümüz zaman da elde edeceğimiz değer 2 üzeri S de bizim eee main numeradeki blok sayısı. Zaten hani blok sayısını S'le şurada gösteriyoruz demiştik. Yani o gösterim sadece. Bir de e number of lines in cash diye bir yapımız vardı. E cash'teki eee line sayısını da neyle göstereceğiz? İşte şurada bunu şu line kısmını eee şu line kıs kısmını R ile ifade etmiştik. Şimdi tüm bu ifade S olduğu için burası da S - R şeklinde. Tek kısmı da S - R şeklinde ifade ediliyor. İşte cash sayısı da 2 üzeri R oluyor ona göre. Yani R bit'le cashbitteeki bütün şu line'ları line işte line 1, line 2, line m -1 burada m diye göstermiş. Bir de ekstradan m'i katmış içerisine ama aslında şuraya şey diyebilirdi yani bunu matematiksel gösterimde L'de M -1 değil de L2 üzeri R - 1 şeklinde bunu gösterebilirim. Yani teknik olarak aslında bu daha doğru bir ifade olur şurada. Eee çünkü biz Rabbit ile line'ı göstermiştik. Bu şekilde bir eee Cashmap organizasyonu oluşmuş oluyor. Şuralarda da memory tarafında da dikkat ederseniz işte her bir blok kendi içerisinde Word'lerden oluşuyor. Aynı bu Word'ler işte buraya yerleşiyor vesaire gibi. Eee matel gösterimde de işte blok numarasıyla aslında şöyle bir doğrusal bir ilişki var. Tek bilmeyenli bir denklem. İşte 4C + 1, 4C + 2, 4C neyse ona göre eee adresi bulabiliyorsunuz. Fakat buradaki flow chart neyi gösteriyor diyecek olursanız da işte CPU şu adresi generate etti. Yapmamız gereken neydi? İşte many to one bir relationship olduğu için cashteki bir eee satır birden fazla memoryin hedefi konumunda. Bunu ayırt edebilmek için tagi'i kullanıyorduk hatırlarsanız. Dolayısıyla ilk işlem hemen CPU'nun generate etmiş olduğu şu bu generated ya da compute tag. Bu tag kısmını al. alıyoruz bir compare eee donanımına eee ki işte ilk sorgate olabilir vesaire bir karşılaştırıcıya tabi tutuyoruz. Daha sonra bu karşılaştırıcıların sayıları da önemli olacak. Associative as mapping'de burada bir tane var. Eee bununla bakın neyi karşılaştırıyoruz? Buradaki tag bilgisi ile bizim işte şuradaki orta kısımdan da cashluk. Cashline bilgisi diyor ki bizim gidin işte şu ortadaki bir tane işte line'da bu veri var dedik. Bu line'a geldiğimiz zaman yani şu line'ı line i'ye kastediyorum ya bu burayı bulduk. Cash line'ımız bu dedik. Burada kayıtlı olan tag ile şuradaki cash'teki tag ile bakın oradaki tag gelecek. Bizim eee CPU'nun generate etmiş olduğu tag burada compare işlemine tabi tutulacak. Eğer ki aynıysa yani karşılaştırma sonucu ikisinin aynı olduğuna her iki tagin de aynı olduğu sonucuna varılmışsa Bu durumda bakın şurayı takip ediyoruz. Cashit'imiz var. Cashit durumunda sonucu direkt bu cashşin içerisindeki offsetten yani offset diyor ki bu blok içerisindeki 3üncü ya da 4düncü işte artık kaçıncıysa onu al diyor. Dolayısıyla bunu biz gidip buradan alıyoruz. Cash hitimiz olursa. Ama bu karşılaştırma sonucunda cash miss olursa yani eee computed tag ile cashteki tag kısmı birbirinden farklı ise bu durumda biz buradan aşağı geliyoruz. Cash miss durumumuz oluştu. Yani aradığımız şey cash'te mevcut değil. Eee mevcut olmadığı için onu memurden bulacağız. Memur'den bulurken dikkat ederseniz artık eee burada line number'ın herhangi bir önemi yok. Yani R'yi orada kullanamayız çünkü memory tarafındayız artık. Cash iptal oldu. Dolayısıyla şuradaki bütün yapıyı kullanmamız lazım bizim. Yani bütün yapı derken tag + line yani s diye ifade ettiğimiz kısmı kullanarak memory bloğuna erişiyoruz. Bu durumda yani öncelikle cash'te cash line'a erişmeye çalışmıştık. Nereden? İşte şuradaki ortadaki şu e line adres kısmından şuraya eriştik ama Tag'ler uyuşmadı. Yani şu tag'le buradaki tag uyuşmadı. Uyuşmadığı için bu sefer memory gidip memorin işte memorydeki bloğu bulacağız. Bloğu bulmak için de blok adresimiz bizim yeşille gösterdiğim şu kısım yani tag artı line kısmı. O da s ile gösteriliyor hatırlarsanız. S ile ifade ediyor. Burada S kısmından blog adresini buluyoruz. Blog adresini bulduktan sonra yine benzer şekilde şuradaki offset bilgisi bizim bloğun içerisindeki işte kaçıncı elemana yani W ile kaçıncı elemana erişeceğimiz bize söylemiş oluyor. Bu yapı da bu şekilde arkadaşlar. Hani biraz belki kafa karıştırıcı olabilir ama çok da kafa karıştırıcı bir şey değil. Son derece açık net bir eee yöntem. Eee birçok yerden de hani desteği olan bir şey yani bir şeyi çok farklı noktalardan eee doğrulayabilirsiniz ya da bulabilirsiniz cashmapin yönteminde. Şimdi buna geldik. Zaten açıklamışız herhalde. Tamam bunları söylemiştik. Evet asociative'e geçmeyelim. Ş'e geçmeyelim ama eee şöyle bir şey yapayım ben. Eee mesela şununla ilgili bir tane eee sorelim. Diyelim ki ben size işte eee main memoryinizin büyüklüğünü eee atıyorum 32 GB olarak verdim. 32 GB'lık bir bilgisayarınız var. Buradaki cash size'ınızda. Cash size'ınız da ne kadar olsun diyelim? E 64 kob'lıkta Bir cash büyüklüğümüz olsun. Block size. Block size'ımız da ne verelim? Eee, 2 kb'lık block size'larımız olsun diyelim. E, soru şu olacak. İşte bizim text size'ımız ne olur? Kaç bitlik? Yani bu şuradaki şu gösterimi istiyorum aslında. Hani bu, eee, bir eee, sanal bir adresin dağılımı nasıl olacak? Hepsini bulalım. Tekini bulmuş olacağız bunu bulurken bir de Tek directory size'ımız ne kadar olur diye sorarım mesela. Tek directory size'ı soralım. Şimdi hemen şuradan başlayalım. Mesela 32 GB. Şimdi eee 1 GB dediğimiz şey neye karşılık geliyordu? 1 GB 2 üzeri 30'du zaten. Hani 1 KB 2 üzeri 10, 1 MB 2 üzeri 20, 1 GB 2 üzeri 30. Bu 32 GB diyor. Yani 2 üzeri 5 ile çarpılmış değil mi? 2 üzeri 5 32 yapar. 2 üzeri 5 x 2 üzeri 30'luk bir alan bu. Toplamda 2 üzeri 35 byte diyoruz. Byte addressible olduğunu hep kabul ediyoruz. O yüzden byte'a çevirerek aynı standart bir düzlemden gideceğiz. Bu da demek oluyor ki şöyle bir şu gösterimi yapacak olursak bunun tamamı 35 byte çıkacak. Evet. Yani CPU 35 pardon 35 bitlik Ben de şey yaptım. 35 bitten oluşacak. Sig'un üretmiş olduğu bir eee adres toplamda 35 bitten oluşacak. Hemen şurada bunun offsetini şöyle keselim. Şuradan offsetini bulacağız. Offset için block size'a bakmamız lazım. 2 KB. Şimdi 1 KB dediğimiz şey 2 üzeri 10'du. 2 KB 2 üzeri 11 olacak değil mi? Bir sonrası yani top Toplamda 11 bite ihtiyacımız varmış. Onu hemen buradan buldum. Siz şimdi geriye ne kalıyor? E şöyle bölelim. Ya buradaki gerçek oranı da bölmüyor olabilirim. Yani 11 bitin uzunluğuyla diğerleri aynı olabilir. Sadece 3'e böleceğimiz için bir yerden kesit attım. Şimdi line size'a bakacağız. Şimdi casşimizin kapasitesi 64 kbmış. Biliyorsunuz şu kısım bize eee line eee addressing için bit sayısını verecek. Şimdi 64 kb'lık bir adres eee ne kadar bir şimdi 1 kb eee x 64 olacak. Yani 2 üzeri 10 x 64 kaç oluyor? 6 mı oluyor? 4 8 2 16 32 64 evet 6 eee 2 üzeri 6 x 2 üzeri 10 değil mi bu? Yani 2 üzeri 16 2 üz 16 tane byt'tan oluşuyor bu cashbellik. Eee 2 üzeri 16 tane byte oluşuyor ama o zaman gidip 16 yazmıyorsunuz. Bak onu bir unutun. Çünkü burada block size dediğimiz bir kavram var. Yani cash'in içerisinde de cash line var. Memur'daki block size gibi. Dolayısıyla ya 2 üzeri 16'yı 2 üzeri 16 byt'lık bir alan içerisinde kaç tane 2 kob'lık alan var? Bunu da 2 üzeri 11 olarak bulmuştuk. Ne çıkıyor? 2 üzeri 5 tane eee line'dan oluşuyor bu cash. 2 üzeri 5. Yani 32 tane line'dan oluşuyormuş. Dolayısıyla Bizim aradığımız rakam ne? 5. Şuradaki kısım 5 bit. Lan kısmımız 5 bit. Geriye kaç kaldı? 20 19 mu kaldı? Şuraya 19 mu oluyor? Kaç tane oluyor? Tek kısmına eee 19 24 35. Evet. Oluş. Tek kısmımıza da tekimizde bakın 19 bitten oluşuyor. Aslında bu kötü bir durum. Yani eee bu cash'te e 2 üzeri 19 tane eee blok Aynı cash line'a karşılık geliyor bu memory kazası. Tabii memory çok büyük 32 GB. Cashimiz sadece 64 GB. Normalde hani cashimiz burada biraz daha megab'larda falan olursa biraz daha değişir ortam ama 19 bitimiz tag'e gidiyor. 5 bitimiz line addressing'e gidiyor cash'te. 11 bitimiz de eee offset'e gitmiş oluyor. Şimdi burada teory size'ı şunu hesaplamak istersek şimdi tech directory size ne demiştik? İşte bizim şöyle bir cashşimiz var. Buraya cash diyelim. Cash'teki her bir line'ın bir kulakçığı vardı değil mi? Şey ekstra ekstra her bir line'da bu cash'in sizından bağımsız eee ekstrası var. Burada bir sürü cash line'ımız var. Şimdi amacımız take directory size hesaba ederken bu kulakçıklardan bu kulakçıkların toplam kapasitesini bulmaya çalışıyoruz. Dolayısıyla cash'te kaç tane line var? Burada hemen cevabımız varmış. 2 üzeri 5 tane değil mi? Ya da şuradaki 5 sayısını al. 5 tane bitle 2 üzeri 5 tane cash line üretmiş olduk. Çarpı her bir Tegin uzunluğu ne kadar? 19. Buradan da kaç çıkar? 2 üzeri 5. 32 x 19 gibi. Bilmiyorum kaç çıkıyorsa artık sonuç. E ama sonuç bits cinsinden arkadaşlar burada şu kadar bitlik bir eee şeye ihtiyacımız çıkıyor. Eee ne denir o? Eee tag directory size'a ihtiyacımız çıkıyor. Şimdi başka bir şeyde mesela şöyle bir şey diyebiliriz. Eee Eee, mesela şu örnekten gidecek olursak diyelim ki CPU bize şöyle bir adres generate etti. Diyelim ki adresimiz burada 7 bitlik bir adres generate ediliyordu. 0 1 0 1 0 kaç oldu? 2 4 6 7 tane adres ürettik. Tamam, 7 biti ürettik. Şimdi soru şu, eee, belli bir anda CPU cash içeris cash memory içerisinde eee, ilgili byt bulunmak Cash'te başka hangi byt'lar bulunabilir? Yani bize deniyor ki 0 1 0 1 0. Memur'daki bu adresteki byte şu an Cash'te mevcut. Cash'te başka hangi byt'lar bulunabilir? Şimdi bakın bunu bulabilmek için yine hemen şu decomposition'ı yapacağız. Şuradan kesiyoruz. Buradaki bölüm 3 2 şeklindeydi. Buradan da kestik. Yani 3 iki tane cash line iki tane de offset için. Şimdi bu eğer memory bu eğer cash memory yerleşmişse line olarak bu bir defa line 00'a yerleşmiş değil mi? Şurası line number line 0'a yerleşmiş. O zaman bu line 0da başka hangi adresler olacak? Diğer offsetler olacak. Yani eee şurası ilk başlangıç blog kısmı aynı olmak kaydıyla blog kısmını aynı yazıyorum. 0 1 ile başlayan line kısmı 00 olan bakın burası bir blok adresi. 12 12 nolu blok. Bunun 0 0'ı var. 0 1'i var. 1 0ı var. 1'i var. Bakın şuradaki eee bahsi geçen 10 zaten bu şuradaki seçeneklerden bir tanesi. Çünkü bu blok memory yerleşince aynı initial'la başlayan 00 1 ve 1 de blokta olduğu için yani bir cash line'a bu yerleşmiş. Cash 0'a şuraya yerleşmiş bu kısım. Eee dolayısıyla diğerleri de olacak. Eğer ki sizde eee mesela ben sınavda şeyi de sorabilirim. Şu cash memory içerisine mesela Ahmet gibi bir takım value'lar da koyabilirim. Siz gidip işte burada lines 0a baktığınızda bu line 0 değil de işte line kaçmış bu 12 mesela 12 line'da şurada bir yerde eee c x y gibi bir takım veri olsun. E ben derim ki işte eee cashte eee 1 0 ne? 0 1 2 cas'te x harfi bulunuyorsa başka hangi harfler bulunabilir? E c y de olabilir. Çünkü biliyorsunuz bu blok halinde gelecek keşe yerleşecek gibi. Ya bununla bununla ilgili sorular falan böyle son derece eğlenceli. Çözümü kolay eee basit eee E sorular sadece işte farklı noktalardan tüm bu yapıyı bilmek gerekiyor. Yapıda bilmeniz gerekenler cash line size ile memory block size birbirine eşit olacak. CPU sizin e main memory kadar byte'ı adresleyebilecek kapasitede bit generate edecek. Ve bu bitleri generate ederken memorydeki block size'ı adresleyebilecek sayıda en sağda offset dediğimiz bir bit alanınız olacak. Orta kısımda işte cash kapasitesi bir şekilde hesaplayacaksınız. Kaç tane line'dan oluşuyorsa o kadar line'ı adreseyebilecek sayıda bitiniz orta kısımda olacak. Geri kalan kısmına da genellikle tek çıkarma işlemi sonucunda bulunuyor. Eee tabii yani genel olarak sorular bu tarzda sorulduğu için çünkü bazen tek kısmı da verilebilir size. İşte atıyorum tekle line kısmı verilir. Offset verilmemiştir size işte block size istenir gibi. Yani sorunun bu tek bilmeyen denklemin birçok tek bilmeyen denklem içerdiği için böyle eee farklı yerlerden eee problemi çözme şansınız oluyor. Genellikle çok farklı noktalardan. Şim burada keselim arkadaşlar. E yarın asociative ve set asociative mapping'le devam ederiz.Evet arkadaşlar, eee, dün direct cash mapping yöntemini görmüştük. Eee, bugün ise, eee, bu yöntemin, eee, biraz daha gelişmiş versiyonların günümüz sistemleri, günümüz işlemcilerinde kullanılanlarına bakacağız aslında. Günümü sistemlerinde kullanılan işte Nway ya da Kway set asociative mapping yöntemi. Ama onu anlamak için öncelikle asociative cash nedir? Eee, onu anlamak gerekiyor. Şimdi eee cash mapping teknikleri üç ana başlıkta inceleniyor. Bir tanesi şurada eee bahsetmiştik. Direct cash mapping. Biri asociative diğeri de set asociative. Dediğim gibi güncel işlemciler set asociative yöntemini kullanmak Çünkü set asociative yöntemi eee hem direct cash mapping yöntemini kullanmakta hem asociative mapping yöntemini kullanmakta. Bu açıdan bakıldığında aslında biz buradaki cash mapping yöntemlerini temelde şuradan ayırabiliriz. Hani direct ve asociative aslında kendi başına farklı farklı yöntemler. Eee set asociative ise eee işte set kısmını direct cashmapping ile yapan eee as yani şu set buradaki ismindeki set kısmını direct ile eee gerçekleştiren asociative kısmını da işte asociet ile yapan bir hibrit yöntem diye düşünebiliriz. Eee şimdi burada eee dark Cash Mapping'de daha önce dedik ki avantajı işte eee hızlı bir şekilde map işleminin gerçekleştirebilmesi. Yani direct cas mappingde biz hiçbir şekilde bir algoritmayla vesaire uğraşmıyoruz ama eee eee, asociative ve set asociative'e geldiğiniz zaman artık eee, problemi çözmeye çalışırken birtım ekstra bilgilere ihtiyacınız var. Mesela direct cash mapping'de şu yoktur. İşte many to one relationship olduğu için memory tarafından eee, cash tarafına many to one bir relation olduğu için eee, burada memorydaki bir bloğun e cashteki hangi line'a yerleşeceği sorusunun cevabı en başta bellidir. Programınız çalışmadan önce de belli. Çalıştıktan Sonra da belli bu değişmiyor zaten. Fixed olarak tanımlanmış bir hat var. Fiziksel bir bağ var orada. Dolayısıyla eee memory bloğuyla cash line arasındaki ilişki çok net bir şekilde tanımlanmış durumda. Burada bir eee başka bir ihtimal durumu yani böyleyse şöyleyse durumu yok. Oradaki mesela siz cashl'a bir eee memory bloğunu yerleştirmek istiyorsunuz. O casline'ın daha önceden yerleşmiş bir veri varsa mecbur üzerine yazıyorsunuz. Yani bunun başka bir kaçırı, başka bir eee eee olasılığı ihtimali yok. Cashmapping çok direct cashmapping çok eee o konuda eee stabil fiks bir eee kullanım durumu var. Associat mapping'de ise eee daha flexibel bir yapı var. Yani artık eee memory bloklarının eee cash line'ına yerleşmesi sırasında seçeneklerimiz var. Şimdi mesela directing'de worst case senaryoyu söyleyeyim size. İşte 1 megb'lık bir cashiniz var diy diyelim. Ama siz sürekli olarak işte Memory'nin ilk eee belli bir bloğun belli bloklarına erişiyorsunuz. Ve bu blokların tamamı öyle şans diyelim tamamı bir şekilde işte 8'in katları olmuş, 16'nın katları olmuş bir şekilde hep eee cash line'daki 0ıra denk geliyor. Yani 0ın cash line'a map edilmiş durumdalar. Bu durumda sizin 1 megb'lık cashşiniz bomboş olmasına rağmen sürekli cash line 0da siz update işlemleri yapacaksınız. Yani yeni geleni eee eskisinin üzerine yazmanız gerekecek. Bu da birazdan bahsedeceğim. O da biraz karmaşık bir süreç aslında. Eee yani şöyle bir şey otobüs var. Otobüste işte 50 kişilik bir otobüs. Sürekli her gelen eee yolcu için e ilk numaralı koltuğu veriyorsunuz ve eee yeni bir yolcu geldiğinde oturan yolcuyu otobüsten çıkartıyorsunuz. Yeni yolcuyu eee aynı koltuğa oturtuyorsunuz gibi bir yöntem aslında derk geçmek mümkün. Ya eğer öyle bir olasılık denk gelirse böyle bir dezavantaj var. Yani boş yer olmasına rağmen siz eee fixed mapping yöntemi kullandığınız için eee diğer boş yere bunu yerleştirelim diyemiyorsunuz. Tarihleşme associative'de ise eee bakın şurada zaten o belirtilmiş durumda eee permits memory block to be loaded into any line of the cash. Yani 1 MB'lık bir cashiniz varsa artık siz bu cash line'larından herhangi bir tanesine boş olan herhangi bir tanesine eee memory blowunuzu yerleştirebilirsiniz. Bu bir avantaj. Çünkü eee cash'in daha eee yüksek olasılıkla kullanılmasını sağlıyor. Çünkü cash hit ratio dediğimiz işte bu cash'te aradığımız eee veriyi bulabilme ihtimalimiz, oranımız eee cash ne kadar doluysa o kadar artacak aslında. Yani cash'te boşluklar olması avantajlı bir durum değil. Çünkü cash biliyorsunuz eee memori eee türleri arasında bizim sahip olduğumuz en hızlı araç. Dolayısıyla aradığımız bir şeyin e en çok orada bulunabilmesini biz isteriz. Dolayısıyla keşin dolu olması bizim için bir avantaj. Şimdi eee tabii bu problemin bir tarafı, bir yüzü hani eee bir probleme bakarken bir de diğer yüzünü görmek lazım. Şimdi bu asociative direct cash mapping'e göre bir artı getiriyor burada. Boş alanları da kullanabilme yeteneği. Ama tabii boş alanları da kullanabiliyorsanız bir de bunun yönetilme yeteneğini de sağlamanız lazım. Yani yeni bir eleman geldiğinde Artık fiks olarak işte 0ıa işte atıyorum memory bloğu 0 4 8 12 16 bunların hepsi memory bloğu sıfıra geliyordu. Şimdi canları nere isterse oraya gidebilecek. Ama tabii biliyorsunuz bilgisayar eee da böyle canları nere isterse gider durumu da yok. Yani birinin bunu yönetmesi lazım. Bir management olması gerekiyor orada. Ön sizin bu hani keep track of dediğimiz bu e boş yerleri bir şekilde tutmanız lazım. Yani eee ilk boş yer neresi mesela? Eee ki yeni bir memory blok geldiğinde direkt olarak boş bir yere kaydedilsin. Eğer eee cashşte zaten var olan bir şey deyse yani cash miss oluşmuşsa eee cashş miss durumunda gelecek olan bloğun eee nereye kaydedileceği eee keşflerin de nereye kaydedeceğini bir şekilde tutmamız gerekiyor. Ama tabii bu sadece yine asociative MPIN getirdiği bir yük aslında. Hani eee bir yer göstericiye ihtiyacımız var. Bunun dışında da eee bir de tabii eee şeyde direct cash mapping'de ona geri nerede? Şuralardayız. Neredeyiz? Evet direct cash mapinding'de yani şimdi burada bu yapıyı böyle gösterdik ama biraz computer organization açısından bakalım biraz dijitalle de birleştirelim mesela buradaki yapıyı. Mesela bu burada bu sistem nasıl çalışacak? İşte biz şey diyoruz ya hani bir tane bizim eee şöyle CPU'muz var. C diyelim. Şimdi bu CPU bir işte adres generate etti. İşte bunun generate etmiş olduğu adres şöyle bir adres alanı diye söylüyorduk. Birçok da adres generate ediyor. Memory'daki bir byta'a erişmek için bir adres işte örneklerde 6 byt'lık 6 bitlik adresler vesaire yapmıştık. Şimdi direct cashmapping'de bunu biz önce işte bir tane şurada word offset kısmı yani bu listing bit kısımları word offset yani bir blog içerisindeki adreslemi de kullanılıyor dedik. Geri kalan kısım ise blog adresi. Yani şu kısım blog adresi, şu kısım ise offset demiştik. Fakat blog adresi kısmı da daha sonra iki parçaya bölüyorduk. Bir tanesi eee ortada yer alan kısım cash line'ı gösterirken en solda kalan kısım da tag kısmını bize gösteriyordu. Şimdi böyle bir yapımız vardı. Şurası tag, burası line. Eee şey kısmı da offset. Şu kısımda offset diyelim. Şimdi böyle bir yapıda eee eee hani fiziksel olarak bunu nasıl yapmış olabilir? Şimdi şuradaki yapıya bakarsanız şuradaki eee işte flow chart gibi de görünüyor biraz aslında akışı da gösteriyor bize. İşte cash'imiz burada eee cashteki bir veriyi bulurken işte tag'i alıyoruz. Buradaki bir compare işlemine tabi tutuyoruz. Eğer compare'den çıkarsa işte hit olacak, compare'den çıkamazsa miss olacak. Memory'ye gideceğiz gibi bir takım seçenekler var. Şimdi burada aslında şu kısımda eee bizim eee işlemcimizin oluşturmuş olduğu line bitleri ki burada atıyorum işte 3 2 tane bit var diyelim iki tane bit geliyor. Yani bunların bir fiziksel kablo olduğunu düşünün arkadaşlar. Bu iki tane bit gidecek işte aslında işte cashşimizde şöyle bizim birtım eee cash line'larımız var. Cash line'lara asociate edilmiş durumda olan birtım taglerimiz var. Eee nasıl diyelim? Eee öncelikle bunu nereden çekeriz? Evet aslında şu kısmı da eee şöyle almış olalım. Şimdi bu tagin içerisinde de e işte tag bilgimiz var, line bilgimiz var. Eee line'lar şuradaki her bir cash line'ın çıktısı diyelim. Bu şekilde bir multiplexer üzerinden hatırlıyorsanız MUX yapımız vardı bizim multiplexer. Yani içerisine eee atıyorum işte 4 tane input girişi var. İki tane de selectory var. Bir tane de enablerı olsun. Bir tane çıktısı olsun. Multiplexer hatırlarsanız ne yapıyordu? İşte selectorları S0 ve S1 selectorları vardı burada. Burada da eee işte eee farklı F1 fonksiyonu, f2, F3, F4 fonksiyonu vardı. En son fonksiyonumuzda bu selectorlerin eee durumuna göre f1'den f4'e kadar olanlardan bir tanesi oluyordu. Şimdi bu yapıyı biz eee şeyde kullanmak istersek, burada kullanmak istersek ne yapmamız gerekir? İşte bu diyelim ki bu cashin işte atıyorum şurada şöyle gitti bir tane çıkış tabii burası 4 tane çıkış var. E bu dör tane çıkışı ben almış olsaydım işte 4 tane çıkış şöyle gelmiş olsun multiplexerım burada yer almış olsun. E bu multiplex'a bunlar input olarak girsin her bir tanesi. Dolayısıyla işte benim 4 tane cash line'ım eee burada e yani onların read kısmı burada bulunmakta. Bunlardan bir tanesini ben seçeceğim. O cash line'lardan bir tanesini seçeceğim. Neye göre seçeceğim? Bakın eee şuradaki, eee, selector'ımı da seçeceğim. Yani CPU geldi bana bir tane cashline'ı oku dedi. Ben gittim pat diye o cashl'dan okuyacağım veriyi seçebiliyorum. Benzer şekilde oradan alacağım işte tag'leri de bir multiplex üzerinden çekebilirim. İşte atıyorum cash line'ım 1.0 oldu. Dolayısıyla selector şuradaki şu kısımdaki selector 1.0 olacak. Eee, 1.0'ın yani eee, 0 1 2 şuradaki eee, cashl'ımızın tıktısı gelecek. Ama gelmeden önce biliyorsunuz cashm bir tag kontrolümüz var. İşte tag'imiz de aynı şekilde eee gelecek eee bir işte exclusive or yapısı gate ile buradaki tag'le buradaki tag bir kompatör üzerinden C ile gösteriliyor genelde. Eee karşılaştıracak. Eğer o uyarsa benim buradaki eee multiplexer'dan gelen çıkışımı ben kullanabilirim. Ya da işte onun içerisinden offsetle bilgiyi yine benzer bir yöntemle çekebilirim. Şimdi burada fiziksel altyapı bu şekilde kuruluyor. Yani daha önce hani öğrendiğimiz bu eee logjik elementler işte İşte encoderlar, decoderlar, multiplexerlar, işte comparatorlar vesaire burada işe yarıyorlar. Hani aslında bu işleri onlar sağlıyor. Arka planda benim işte bir line'ım var. E işlemci bir e şurada line oluşturmuş. Şöyle bir line bilgisi var. Bu 1 ya da 0. Bu kablo üzerinden gidiyor multiplexerın selector kısmına. E multiplexer neyi select edecek? Cash line'ları yine bir wire üzerinden multiplexer'a bağlı. E dolayısıyla selector ne derse onu seçecek. Tabii bunun dışında bir de işte bunun şurasında hatırlarsanız ktrol vesaire var. Mesela ben bu eğer komparatör kısmı eee hit olursa şuradaki o hit kısmı mesela komparatörün çıktısını da ben bunun enable bitine bağlarım. E comparatör hit yaptığı anda eee bu multiplexer enable olur. Bunun çıkışı o zaman aktif olur gibi. Yani bu yapı alt tarafta bu şekilde kurulmuş durumda. Şimdi bu yapıyı biz eee asociative'e eee dönüştürdüğümüzde nelerle karşılaşacağız ona bakalım. Şimdi dedik ki asociative eee map yönteminde eee fleksibility var. Dolayısıyla işte sağ tarafta görmüş olduğumuz memory blokları artık eee cashteki bu line'lara yerleşirken herhangi bir boş bulduğu line'a yerleşebiliyor. Eee tabii burada dedik gibi management durumu var. İşte boş bir yeri bulma kısmı var. Artı eee başka bir sorun daha ortaya çıkıyor. Daha önce biz direct cashmapping yönteminde aradığımız şeyi, eee, aradığımız veriyi daha doğrusu eee, buradaki cash line adresin kısmından direkt olarak çekiyorduk. Yani cashşimiz buraydı. Eee zaten adresin içerisindeki şu orta kısım bize hangi line'a bakmamız gerektiğini dir cash mapinting'te söylüyordu. Ama şimdi belli bir line'a bakamayacağız. Çünkü aradığımız eee memory bloğu cash line'larından herhangi bir tanesinde olabilir. Dolayısıyla bu bize biraz daha eee karışık bir durum oluşturuyor. Yani eee hatırlarsanız eee onun grafiği var mıydı? Evet. Mesela bir tane örnek yapmıştık dah Cashmapping'de dikkat ederseniz burada eee biraz karışık görünüyor ama hatırlarsanız dünden işte 0ın 4 8 12 16 20 24 ve 28 cashl 0a yerleşecekti fix sabit bir şekilde. Aynı şekilde işte 1 5 9 13 hani bunları atlaya atlaya katlarıyla atlayarak giderseniz onlarda cash line 1'e yerleşecek. Bunlar fix bir şekilde tanımlanmıştı. Ama burada şu bizim dikkatimi çekiyor. Yani 0 1 2 3 4 5 6 7 8 tane mi olacak? Kaç pardon? 1 2 3 4 5 6 7 8 tane. Toplam 8 tane memory bloğu cash tarafında aynı casline'a map edilmiş durumda. Dolayısıyla biz bu 8 tane memory bloğunu birbirinden ayırt edebilmek için tabii logaritması alırsak ya da işte 3 bit ile yani tag ile ifade ettiğimiz 3 bit ile bu 8 tane memory bloğunu daha sonra birbirinden ayırt edebiliyordu. Orada tek kısmında 3 bitlik bir kullanım vardı. Şimdi bu kullanım e asociative cas geldiğinde biraz daha büyümesi gerekiyor. Neden büyümesi gerekiyor? Çünkü biz işte eee nasıl diyelim ona? Eee diyelim ki şöyle bir boş sayfa yapayım ben. Burada Skype diyelim. Şöyle bir şimdi diyelim ki eee Mesela memory size'ımız, memory e size'ımız hadi 32 GB'lık bir memorimiz olsun. Şimdi 32 GB'lık bir memory eee dediğimiz zaman hemen bu dönüşümü yapabiliriz. Kaç bite ihtiyacımız? Ya da e gigab'ı bir defa bir byte cinsine çevirelim. Bu tarz sorularda hemen çevrim önemli arkadaşlar. Şimdi Gigab dediğimiz şey zaten 1 GB dediğimiz şey 2 üzeri 30'du. O sabit. Eee bir de 32 x 1 GB var. Yani eee çarpı 32 dediğimiz şey de 2 üzeri 5 değil mi? Bu durumda 2 üzeri 35 byt'tan bahsediyoruz. Yani başka bir ifadeyle CPU'nun cerit etmesi gereken eee byte miktarı bit miktarı 35 olmalı. Bu birincisi. Şuradaki 35 bize işte şöyle bunu ifade edersek gösterdik. Toplamda burada 35 bitimiz bulunacak bu sistemde. Eee diyelim ki e block size'ımız Yani memory tarafındaki block size'ımız da ne kadar diyelim? Eee, 32 kb diyelim buna da. 32 kb. Hemen bunu da, eee, byte cinsine dönüştüreceğiz. Biliyorsunuz 1 kb dediğimiz şey 2 üzeri 10'du. 32 yine 2 üzeri 5 olacak. 2 üzeri 10. Tersten yazıyorum ama neyse fark etmez. Çarpmanın değişme özelliği var. Çarpı 2 üzeri 5. O da 2 üzeri 15 byt'lık. bir eee block size'a karşılık gelmekte. Eee dolayısıyla hemen burada block size eee bu olduğu için yani 2 üzeri 15 olduğu için şuradaki offset kısmımızın 15 bitlik bir alan kapladığını o şuradaki 15'ten geliyor. Eee direkt olarak söyleyebiliriz. Şimdi bu bu arada asociative mapping örneği yapacağız. Eee şimdi şöyle bir durum var arkadaşlar. Şimdi bundan sonraki kısım şimdi direct mapping'de eee biliyorsunuz şu geri kalan kısım Buu turuncu olarak gösterelim. Y şu kısım eee blog adresyordu ve biz bunu direct cash mapping'de daha sonra tekrardan e bölüyorduk. Yani cash line orta kısım cash line oluyordu. En soldaki kısım ise tek kısmı oluyordu. Yani bitler o şekilde daha da bölünüyordu. Ama burada şimdi eee şöyle bir durum var. Tamam offsetimiz yine e aynı direct cashming'deki gibi. Yani bu blok kısmına dokunmadık zaten. 32 KB'ımız vardı. O da 2 üzeri 15 by yapıyor. Dolayısıyla adresleme yapabilmemiz için 15 bite ihtiyacımız var. Onu sağ tarafta ayırdık. Şimdi geriye kaldı 20 bitlik bir kısım. Şimdi bu 20 bitlik kısım zaten burada da asociative mapping'de de e blok adrese karşılık geliyor. Yani burada 20 bitlik bir eee blok adres var. Ama şimdi eee şöyle çizecek olursak eee cashişi. Şurada bir cashş alanı çizelim. Eee tabii cash büyüklüğünden cashş büyüklüğüne ne kadar diyelim? Eee, 5000 kliimiz ne kadar olsun? Tamam. Neyse o ona sonradan kaybız. Bunun şimdilik sadece cashş kısmını şöyle çizmiş olayım ben. Şimdi burada satırlarımız var. Evet. Son cash line'ımız burada. Burada herhangi bir set vesaire yok. Tek bir tane setimiz var as mapping'de. Şimdi şuraya kalan 20 bitimiz kalmış durumda. Bu 20 bitimiz eee şu şekilde kullanacağız. Şimdi memory sağ tarafta yer bırakmadım ama eee memoryiz de şurada bir yerde olsun. Memorimiz çok daha büyük vesaire vesaire işte Ne kadar demiştik? 32 GB'lık memory. Şimdi 32 GB'lık memoryde bizim eee birçok bloğumuz olacak. Şimdi kaç tane bloğumuz olacak? Zaten şuradan 20 bize söylüyor onu. İşte toplam kapasiteyi yani 2 üzeri 35'i yani 32 GB'lık memory içerisinde bizim 32 kb'lık bloklarımız olacak. Yani 2 üzeri 15 byt'lık bloklarımız olacak. O da toplam 2 üzeri 20 tane. O da zaten şuradaki 20'yi gösteriyor. 2 üzeri 20 tane memory bloğum olacak bizim memory tarafında. Şimdi bu 2 üzeri 20 tane memory bloğu cashteki herhangi bir yere gelip yerleşebilir. Çünkü asoşat eğitimin özelliği bu dedik ya tek bir yere yerleşmeyor. Herhangi bir yere yerleşebilir. Dolayısıyla şuradaki eee tagler biliyorsunuz tag'lerin amacı neydi? Eee direct mapping'de işte eee keşe yerleşen memory bloklarını ayırt edebilmek. Bir önceki örnekte hani 8 tane yerleşiyordu. Dolayısıyla tag bitimiz 3 bitti. E şimdi burada 2 üzeri 20 tane blok cash'teki herhangi bir satıra yerleşebilir. Dolayısıyla bizim burada cashin e tek sizeı ne kadar diye bakacak olursak şuradaki 20'yi direkt olarak alacağız. Çünkü 2 üzeri 20 tane memory bloğunu ayırt edebilecek büyüklükte bir text size'a ihtiyacımız var bizim. Dolayısıyla şuradaki tech size'ların boyutu 20 biti bulacak. Yani tag directory size'ımız burada biraz büyüyor dikkat ederseniz. Çünkü artık line size diye ya da line index adresi diye bir şey söz konusu değil. Eee, dolayısıyla asociative mapping'de eee, nasıl diyelim? Buradaki eee, sağ taraftaki offset kısmımız var. Offset'imiz var. Eskisinde olduğu gibi. Eee, fakat eee, geri kalan tüm kısmı tag için kullanıyoruz. Yani başka bir field'ımız yok burada. Yani line adresleme gibi bir mekanizma yok. Çünkü dediğim gibi burada line herhangi bir line'a yerleşebildiği için aradığımız memory bloğunun eee, bizim istediğimiz memory blok olup olmadığının testinde tamamıyla tag'i kullanacağız. O yüzden tag'ı oldukça büyümüş oldu. Yani tag burada blog adresi gibi bir şeye karşılık geliyor aslında. Doğrudan böyle bir yapı var. Şimdi burada eee şöyle bir durum var. Yani bunun dezavantajı ney dedik. Şimdi eee dezavantajı şu. Eee bizim işte comparatör dediğimiz karşılaştırıcılara ihtiyacımız var. E kaç tane karşılaştırıcıya ihtiyacım var? Şimdi bunu tek arayabilir miyiz? Yani CPU şurada CPU burada bulundu diyelim. İşte bu işte yukarıdaki işte neyse şöyle bir adres generate etti. Bunun içerisinde 15 bitlik şurada yer var. İşte 20 bitlik şurada eee tek kısmı var. Şimdi bunu bir eee algoritmik olarak çözeceksek ne yaparız? Karşılaştırma yapacağız diyelim. Şuradaki 20 bitlik kısmı aldık. 20 bitlik işte line kısma geldi. Bunu bununla karşılaştıracağız. Eee o değilse bununla karşılaştıracağız. Bulamadıysak bununla karşılaştıracağız diye bir yapıyı kurarsak arkadaşlar keşi hiç kullanmayalım daha iyi. Çünkü biliyorsunuz bu serial bir search. Eee, yani seri eee, siz algoritmalar dersini 3. sınıfta göreceksiniz ama eee, şöyle diyelim. Eee, bu, e, ölçeklenebilir, sürdürülebilir bir yapıya sahip değil. Buradaki eee, cashş büyüdükçe sizin, eee, bir veriyi arama miktarınız artacak. Yani, eee, RAM'de bile bir random access'te fixed bir access time'ınız varken burada aradığınız bir şeyi bulmak fiks olmuyor. Sizin cash siz'ınız, büyüklük için aradığınız şeyi çünkü arada boşluklar da olduğu için eee bütün bu taglere tek bakmanız gerekecek. Burada bu arada hani böyle kompleks algoritmalar, data structuredda gördüğünüz o yapıları vesaire de kullanamıyorsunuz. Yani onlar bile eee şimdi bir veri yapısını burada kullanmaya kalktığınız için çok alt seviyedesiniz. Donanım üzerindesiniz. Zaten yapmaya çalıştığınız işlem memoryden gelen bir verinin daha hızlı gelmesini sağlamak. Memory'den gelmek yerine cash'ten gelmesini sağl Ama siz algoritma çalıştırmaya kalkarsanız ki bunu bir şekilde yapsanız bile cashş içerisinde çalışan bir algoritmaya dönüştürmeniz lazım. İşlemciyi buna ulaştırmamanız gerekiyor. Bu çok aşırı kompleks bir süreç olur. Yani işte burada bir ne bileyim eee quick sort kullanayım da bir yer bulayım ya da işte binary search kullanayım vesaire gibi bir şeylere dahi giremiyoruz. Çünkü bunlar zaman kaybına yol açacak. Eee dolayısıyla eee buradaki çözüm şu paralel komparatörler yani her bir Eee, her bir tag kendine dedicate edilmiş bir, eee, komparatöre sahip. Yani şunlara şöyle diyelim. İçerisinde C, C, C, Cek. Komparatörümüz var. Ve hepsi de eee, işte bütün bu line'ların geldiğini düşünün. Eee, buna aynı anda compare işlemini, bütün eee, comparatorlar aynı anda compare işlemini yapıp paralel bir şekilde, eee, e CP'nin üretmiş olduğu bir 20 bitlik tag'in, eee, mevcut cash line'larında olup olmadığını bu komparatörler çek ediyorlar. Tabii bu kompatörlerin çekmesi bu noktada bitmiyor. Bunun nasıl bir devamı olması gerekiyor? Bu komparatörlerin çıktısını da bir asitik diye gösteriyorum. Şurada ne olacak? Bir orgate'imiz olacak, değil mi? Yani biz burada cash hit yaptık mı, yapmadık mı? Bunun sonucunu elde edebilecek mi? Komparatörlerin bir tanesinden bir eee olumlu sonuç gelmesi lazım. Bu hit durumuna göre de biz cashin line'ını aktif edeceğiz ya da ekleyeceğiz ya da işte memoryde bu araba işleğine geçeceğiz gibi sonuçlar olacak. Şimdi bunun dezavantajı ne? Avantajı ne? Avantajı tamam bir şekilde komparatör sayısını artırarak eee zaman kaybının önüne geçmiş olduk. Ama bu da eee bir eee yani circuit tarafında, devre tarafında bir kompleksiteyi beraberinde getiriyor. Çünkü eee cash siz büyüdükçe eee özellikle blok sizeı küçük ve cash size büyük olduğu durumlarda çok fazla cash line'ına sahip olacaksınız ve her cash line için bir tane kompatör koymak eee hem bir maliyet getirecek hem devreyi kompleks ettirecek, güç tüketimini artıracak. Bunu biliyorsunuz CPU'nün içerisindeki kısımda yapılıyor. Artı bunu bir de daha sonrasında Orgate'e beslemeniz gerekiyor. Orgate'e bağlamanız gerekiyor. Bu kadar inputun tek bir ORgate'e bağlanması zaten mümkün değil. Oralarda birtım problemler eee ortaya doğurabilir. diyor. Ama şimdi bundaki sistemlerde işte ne sorulur? Nasıl bir eee şeyden bahsederiz? İşte mesela bu örnekte 32 GB dedik. İşte block size 32 KB dedik. Ve şimdi bu durumda şimdi cashin şu an için cashin kapasitesi vesairesi kaç line olduğunun pek bir önemi yok. Eee şimdi bir komparatörün şurada C ile ifade etmiş olduğumuz komparatörünün de belli bir eee gecikmesi var. Wargate'in hatırlıyorsunuz Orgate'in de kendi bir gecikmesi var. Komparatörün de bir gecikmesi var. E bu komparatörlerin gecikmesi arkadaşlar genellikle k harfine yani daha doğrusu k sayısına bağlı olarak değişer. Yani kaç bit compare ediyorlarsa ona göre. Mesela 1 biti compare etmek için şuradaki tek bir komparatör 1 biti compare etmek için 10 nanosaniye harcıyorsa şurada eee bir komparatörün compare işlemi sırasında harcayacağı miktar 10 nanosaniye çarp 20 bit olacak. O da 200 nanosaniyelik bir eee gecikme demek. Yani bunların her birisi 200 nanosaniye ama paralel olarak yapıldığı için toplam yine değişmeyecek. Tüm bu işlem 200 nanosaniye gibi bir sürede bitmiş olacak. Artı işte bir 20 nanosaniyeyi de şuradaki or kapısına verirsek toplam bizim işte hit latenimiz ne kadar olacak? 200 artı işte en sona şurada e orgateinden gelen 20 nanosaniye toplamda 220 nanosaniye gibi bir hit latency'ye sahip olacağız. Yani dikkat ederseniz burada e şey var yani tamam cashş çok hızlı Amaş keşin içerisinden bir şey okumak çok hızlı. Onlarda hiçbir sorun yok. Fakat işte aradığımız şeyi bulduk muşte var mı gibi bir takım soruların cevaplarını ararken yine belli bir miktar zaman kaybına eee uğruyoruz bu sistemlerde. Şimdi eee evet burada aslında hani şurada komparatörler eee dikkat ederseniz nokta nokta bakın eee aslında iyi bir dikkatle baktıysanız şurada direct cash mapping'de bir tane compare bir tane komparatörümüz var. Yani hoca sistemde tek bir compare eee komparatöre ihtiyaç sadece bir tane bir tek devre compare işlemi yapan tek bir devre exclusive war'la yaparsınız onu. O kadar. Ama buradaki asociative map'teki eee grafiğe bakacak olursanız şurada bakın nokta noktalar var. Yani şu komparatörler her bir teg'e bağlı olan komparatörler. Yani ister ben buraya az önceki şurada şeyde C cc c diye ifade ettim ama yani komparatörde yani burada compare işlemini yapan n tane kompatörünüz var. Şu kısım kompleks hale geliyor. Eee bir de tabii bunun sonucunda o compare işleminin sonucunda da bir or kapısıyla sonuçların birleştirilmesi gerekiyor vesaire. Onun dışında zaten şuradaki şimdi şu yapıda memory adresimiz işte word offset'imiz yine W ile gösterilmekte. Geri kalan kısım zaten blog adresi S ile gösteriyorduk. Bakın tek kısmı da S ile geliyor ve o S işte taglerle karşılaştırılıyor. Bakın buradan gelen veriyle eee tagden gelen bu sebit karşılaştırılıyor. Hepsi karşılaştırılıyor bir şekilde. Eğer Miss durumu olursa da buraya geliyoruz. Zaten S bilgisi yani tag bilgisi aynı zamanda memorydaki blok bilgisini de bize sağlamak. As cash de eee bu şekilde bulunuluyor arkadaşlar. Eee bununla ilgili şunu yaptık. Hemen şu örneği de yapalım. İkinci derste de set asociative mapping'i gösteririz. Öyle de bitiririz. Hemen biraz daha şuradan atmış olalım. Şimdi associated mapping'de dedik ki ility var. Yani eee belli blowu replace edebiliyoruz. Burada replace kısmında bile mesela eee hepsi dolu olduğunda, şimdi hepsi dolu diyelim ki bütün cash line'larımız dolu oldu. Şimdi avantaj olarak dedik ya istediğimiz yere yerleştirebiliyoruz. Eee dolu olsa normalde geçmek de üzerine yazıyorduk. Burada ise boşluk varsa boşluğa yerleştirdik. Peki hepsi doldu. Bu durumda ne yapıyoruz? Bu durumda eee bir cash replacement stratejiye ihtiyacımız var. İşte case replac replacement algoritmaları var. Yer değiştirme algoritmaları. Bunlarda da işte günümüzde en sıklıkla kullanılan Inıntel'in AMED'nin kullanmış olduğu LRU algoritması var. Le recently used ya da en eski eee bloğu sil, at sistemden at gibisinden. Şimdi bakın list recently used bile kendi başına düşündüğünüz zaman tamam en eskisini atalım ama bunu atabilmek için de birtım yine veri yapılarıyla uğraşmanız gerekiyor. Yani Bir bloğun en eski olduğunu nereden bileceksiniz? Yani koca cash içerisinde bir tane bloğun en eski olduğunu nereden bileceksiniz? Eee bu arada list recently used tek algoritma değil. Eee işte frequently used olan var mesela. List recently used yerine list frequently used olan var. Yani en az sayıda kull yani bir cash en az işte heit ratiolarına göre mesela belli bir cash bloğu, cash line'ı yüksek hite' sahipse, yüksek frekansa sahipse mesela onu tutmanız lazım. Ben Belki o ilgin işte 1 milyonluk bir for döngüsü var. Oradaki değişkenler sürekli cashşte hit alıyorlar. Sizin onu değiştirmemeniz lazım bir defalık kullanımda kullanacağınız başka bir işlem için. Dolayısıyla burada eee kullanacağınız algoritma da önemli oluyor. Ama bakın bu basit algoritmalar bile işte en eskiyi atalım ya da işte en az kullanılanı atalım dediğiniz sistemin bile şimdi algoritmik olarak düşünün. Bunu uygulamaya kalksanız neye ihtiyacınız var? Bir eee her bir cash line için bir counter'a ihtiyacınız var. Değil mi? Yani burada nasıl her bir cashl'ın bir tagi var? Bu tag gibi o tag'in yanında belki bir auto increment bir field'a ihtiyaç var. Ne zaman hit olursa bu cashl sayısı bir artsın. Dolayısıyla eee iş replacement noktasına geldiğinde hit sayısı en az olan eee ya da hit olmamış olan işte neyse eee satır eee hani victim olarak seçilsin diyelim. Eee dolayısıyla burada şey var hani asoci mapping direct mapping'in üzerine çok şey koyuyor ama bunları yaparken de işte artıları var fleksibility sağlıyor bize. Fakat eee tek başına bu şekilde kullanıldığında biraz da şey eee dezavantajları da biraz ağır bos açıkçası. Aynen. O yüzden sistemler associative mapping yerine daha çok set asociative'i kullanılı. Onu bir sonraki derste göstereceğim. Bir de diğer bir disadvantage olarak göreceğimiz şey az önce bahsetmiştik. Complex circuitry neden oluyor. Yani bu comparator dediğimiz karşılaştırıcılar ın sayısı direct cashmapping'de 1 iken burada eee sizin kaç tane cash line'ınız varsa o kadar tane de komparatöre ihtiyacınız oluyor. Eee şimdi bu örneğe bakalım şöyle kısaca. Şimdi bu örneğe bakalım. Bu örnekte eee aslında direct cash mapping örneğinde kullandığımız eee rakamlar var. Aynı rakamlar işte 16 MB var. Şimdi 16 MB dediğimiz zaman ne olacak? Yine MB 1 MB için 2 üzeri 20 bite ihtiyacımız var. 16 sayısı için 2 üzeri 4. Yani toplamda yine eee 2 üzeri 24 bitten oluşan bir memory. Dolayısıyla 24 bitlik yani şurada görüyorsunuz zaten 24 bitlik bir eee CPU memory şey eee bir adres üretmekte. 32 bit genişliğinde bloğumuz var. Bu 32 bit 4 x 8 yani toplam 4 byt'lık bir blok size sahip. Dolayısıyla 4 byt'ı adreslemek için yine bizim şurada 2 bitimiz var. Şimdi asoci bping olduğu için toplam 24 bitin 2 biti offset'e gittiyse 22 bitlik kısmı zaten bizim tag olarak adlandılarımız kısım olacak. Yani blok sayımız aynı zamanda burada tagına karşılık geliyor. Şimdi eee yine adreslere bakarsak bakın sağdaki iki tanesi eee bizim sadece offsetimizi göstermiş. Eee soldaki kısım ise tamamen tek field'ını eee oluşturmakta. Adresleri oluşturmakta. E cash kısmına baktığımızda yine 16 kiloline cash'ten bahsedi. Dolayısıyla 16 dediğimiz şey 2 üzeri 4'e karşılık geliyor. Eee, kilo dediğimiz şey 2 üzeri 10. Dolayısıyla 2 üzeri 14 eee, 2 üzeri 14 tane line eee, bulunmakta bu eee, cashş'te. Eee, 2 üzeri 14 olduğu için eee, bakın şuradaki şey 3 FF gidiyor. Yani 14 yani nasıl söyleyelim? E, buradaki f'lerin her biri 4 tane 1e karşılık geliyor. Bu bir tane F. Eee, bir 4 tane daha yaptık. Burası da bir F oldu. 8 etti. Bir tane daha 4 tane 1 koyduk. Burası da F oldu. E kaç tane olacak dedik? 14 tane. Burada kaç tane var? 12. 13 14'ünü koyduk. Geri kalanlar 0. Dolayısıyla şurası da 3'e karşılık geliyor. O yüzden hani şuradaki maksimum adres 3F'te bitmiş durumda. Şimdi eee genişlik yine biliyorsunuz block size'ile eee cashlak. 32 bit. Tabii burada da artık tek kısmımız dediğimiz gibi şurada 22 bit olacak. Nereden bulduk? 24 bitlik bu adresten. 16 MB'lik adresten 2 bitlik offsei çıkarttığımız zaman 22 bitlik tag field kaldı. O da buraya yerleştik. Dikkat ederseniz artık hani eee işte bunun tegi 0 bakın tegi 0 olan bir kısım gelmiş buraya yerleş illaki sıfıra yerleşeceğim şuraya yerleşeceğim diye bir şey yok. İstediği bütün şeyler istediği herhangi bir alana yerleşebiliyor. Associative mapping yöntemind de şimdi eee mesela basit bir soru. Örnek bir soru. Diyelim ki 8 kb'lık bir asociative cashşimiz var bilgisayarda. Eee line size'ımız 32 byt'mış. İşte main memory size da yine eee ne kadar? 1 GB olarak verilmiş. Şimdi bu durumda bazı sorular dolu. Şimdi hemen bakalım. Şimdi 8 KB'lık asociative cash dediğimiz zaman hemen şeklimizi çizelim. Şimdi bu asociative cash'imiz bizim işte İşte arada noktalı söyleim 8 k denmiş. 8 dediğimiz şey 2 üzeri 3 çarpı kilo dediğimiz şey 2 üzeri 10. Yani toplamda 2 üzeri 13 by'tan oluşuyor. 113 byt'lık bir eee cash memoryimiz var. Line size 32 byt'mış. Bu aynı zamanda biliyorsunuz block size olacak. Eee main memoryin size ise 1 GB. 1 GB dediğimiz şey de 2 üzeri 30 biliyorsunuz. Eee 2 üzeri 30 by. Dolayısıyla öncelikle işlemcinin üretmiş olduğu eee adresin hemen şöyle bir dağılımına bakalım. Toplamda 30 by 30 bitlik bir adres üretilecek işlemci tarafından. Bu 30 bitlik adreste eee line size 32 olarak belirtildiği için block size da 32 olacak. Dolayısıyla 32 2 üzeri 5 bizim 5 bite ihtiyacımız var offset için. Geri kalan zaten bu asociative cash kullanıldığı söylendiğine göre geri kalan bütün kısım yani 25 bitlik kısım ise bize eee text size olarak gelecek. Eee burada eee zaten ilk kısmında take how many take bits required demiş. Onu hemen yapıştırıyoruz. 25 diye. How many comparators required denmiş. Şimdi comparatorların sayısını bulabilmek için cash'teki line sayısını bulmamız lazım. Şimdi cash'in kapasitesi 2 üzeri 13 byte. Şurada hesaplamıştık. 200 eee nereye yapalım? Şuraya yapalım. 2 üzeri 13 byt'lık bir cashşimiz var. Eee bir line'ın büyüklüğü ise 2 üzeri 5 yani 32 byt. Bunu buna böldüğümüz zaman kaç tane line'ımız oluşacağını buluyoruz. Kaç çıkacak buradan? 8 mi? 2 üzeri 8 tane bizim eee line'ımız oluşacak 5'te. Dolayısıyla her bir line için bir tane kompatöre ihtiyaç duyduğumuzdan cevap 2 üzeri 8. Ben sınavlarda soruları sorduğumda bunu işte 25'i 2 üzeri 25 yapan çıkıyor. Tek bitini sorduysam bu 25'tir. 2 üzeri 25 değildir. How many compators record dediğim zaman 8 yazanlar çıkıyor. Bu 2 üzeri 8'dir. Yani orada 8 sadece onun bit gösterimi yani 8 bitle on temsil edersiniz ama eee how many diye sorduğum için 228 tane komperatöre ihtiyaç var diye çıkacak. Eee what is the comparator size in bits? Tabii comparitor size yani bu karşılaştırıcının boyutu ne kadar olmalı kısmına da tek size kadar olmalı. O da zaten 25 bitlik yani 25 bitik eee komparatörler kullanmamız gerekiyor. Yani 2 üzeri 8 tane 25 bitlik karşılaştırıcı kullanmamız gerekiyor. Şimdi sorunun devamında da denmiş. ki işte propagation delay for comparator e onların saniymiş for each tag bit yani her bir tag biti için bakın tagin tamamı için demiyor her bir tag biti için diyor 10 nanosaniyelik bir gecikme yaratıyor bir komparatör dolayısıyla bizim komparatörümüzde kaç tane bit var? 25 bit var. 25 x 10 nanosaniyelik bir komparatörde gecikme olacak. Bu da 250 nanosaniyelik bir eee gecikme yapar kompatör başına. Ama bunlar paralel çalıştığı için 2 üzeri 8 tane kompatörde de aynı gecikme aynı anda başlayıp aynı anda bitecekler. Dolayısıyla bu artmıyor. Bunu 2 üzeri 8'le çarpmıyoruz. 150 saniyelik bir kompatör gecikmesi olacak. Bir de end demişiz. Propagation delay of the orgate. Yani biliyorsunuz bu comparatörler ardından bir orgate'e bağlayacak. O da 30 nanosaniye olarak verilmiş. O zaman bu 30 nanosaniyeyi de buna ekliyoruz. Toplamda heat lancei bize sorulmuş. Bu da 280 nanosaniye diye çıkmış oluyor. Tamam. Şimdi bir ara verelim arkadaşlar. E sanırım burada Evet burada bitiyordu. Nway ya da K assing de önümüzdeki ders devam edelim. Evet, şimdi bu derste arkadaşlar eee set asociative mapping eee yöntemine bakacağız. Daha önce görmüş olduğumuz iki yöntem direct mapping ve asociative mapping yöntemi birbirinden farklı iki yöntem. Kway set asociative ise bu iki yöntemin avantajlarını eee kullanarak oluşturulmuş farklı bir yöntem ama hipt bir yöntem olarak da geçmekte. Eee bu yöntemlerin dezavantajlarını mümkün olduğunca azaltıyor. Avantajlarını kullanmaya çalışıyor. Şimdi Cashmapping'deki avantaj neydi? Eee bir eee CPU'nun üretmiş olduğu bir memory bloğunun cash'te hangi adreste olduğunu kolay bir şekilde bulabilmek. Bu bunun avantajıydı. Eee dezavantajı ise fixed bir bağlantı olmasıydı. Mapping işte in fix olmasıyla, dinamik olmamasıyla. Associative mapping'de ise avantaj eee istediğimiz herhangi bir yere flexible bir şekilde memory blownu yerleştirebilme avantajımız vardı. Dezavantaj da bu beraberinde bir complex circuitry getiriyordu. İşte komparatör sayısı artıyor. Eee işte bizim blog adresi için kullandığımız alanın tamamı tech field'ına kullanılıyor vesaire. Şimdi Kway Set associate map'te ise Eee, mesela cash mapping hangi amaçlı kullanılıyor? Set bir aradığımız memory bloğunu belli bir sete koyma amacıyla. Yani o cash mapping'de kullandığımız o fixed adresleme, fixed mapping yöntemi burada tek bir cashl için eee gerçekleştiriyor. Yani bir memory bloğu. Eee eskiden dör tane cashlımız vardı. İşte bu dört cashlan işte üçüncüsüne yerleşmek zorundaydı. Direct cash mapping'de eee Set associated mapping'de ise bu memory bloğu belki 3 numaralı sete yerleşmek zorunda. Eee 0 ve 1'e yerleşmiyor ama 3 numaralıya yerleşmek zorunda. Ama bir set kendi içerisinde birden fazla cash line'a sahip olduğu için de eee bu açıdan baktığımızda eee içerideki set içerisindeki işlemlerde asociative bir şekilde gerçekleşecek. Eee bu da neyi sağlıyor? İşte paralel bir şekilde aradığımızı hızlı bir şekilde bulabileceğiz. Yani asoci mapping'deki o avantajı gösterecek. Ama asso maping'deki bu complex circuit rary dezavantajını da eee indirgiyor. Çünkü bütün setler bir tane kompatöre bağlı. Dolayısıyla eee siz setteki her bir line için bir komparatör kullanmak yerine eee bütün setleri eee komparatöre bağlayarak eee bu complex quzavantajından da kurtulmuş oluyoruz. Şimdi burada Kway Set associate mapping'de eee K sayısı eee her bir set içerisindeki cash line sayısını göstermekte. Bu genellikle işte two way, 4 way, 8 way şeklinde geçiyor aslında. Şöyle bir bakayım güncel işlemcilerde eee durum nasıl? Bakalım. Eee 12 işlemci şıştırım diyecek. Cep kendi sayısı yokmuş. Tamam çıkmış. Şuna bakalım. H işlemci bilgini şey Ş bulamıyorum. Halbuki böyle bilgiler O zaman ekrana geliyor eee şuradan bakalım. Prosesörlerde bir var. Çok ilgince. Şimdi bir sani bulacağım arkadaşlar. Bulacağım. Neden bu kadar görüyorum? Neyse bir tane işlemci buldum. Eee, evet şu ekranımızı paylaşalım şuradan. Evet. Şurada bu hangi işlemci? Inıntel 7 10 nesil bir işlemci. Bakın burada level 1 ve level 2'deki eee ve level 3'teki yani CPU casindeki eee yapının türü olarak işte eee way set asociative instruction cash, way associative data cash. Biliyorsunuz L1 Cash'te instruction ve data casiniz var. Yani bu işte yarı yarı diye oluyordu. Burada da yine yarı yarıya ayrılmış durumda. Vay yani bir eee set içerisine 8 line gelecek şekilde eee bir yapı oluşturulmuş. E level 2'de fourway set asociative cash var. Level 3'te de 16 way set asociated. Bu 64'e kadar gidebiliyor bazı modellerde bu şekilde de bakın kapasiteler de bu şekilde. Toplam 6 x 256 KB. 2 tane de 6 x 32'lik L1 var. Bir tane de 12 MB'lık eee keşf bulunmakta. Bu hiyerarşik bir keşif tabii. L1, L2, L3. L1, L2 biliyorsunuz direkt olarak CPU'ya bağlı. L3 ise CPU corları arasında sher şekilde kullanılabiliyor. Eee, evet yani burada gördüğünüz gibi yani güncel bir işlemcide 8 way, 4 way ve 16 way set asociative cash memory kullanılmakta. Eee, AMD için de benzer durum söz konusu. Şimdi buradan nereye gideceğiz? Eee, şimdi burada Kway set aset mapik'ten bahsederken işte K ve V sayılarımız var. Bu K sayısı her bir setteki eee, line sayısına karşılık geliyor. Mesela az önceki örnekte 8 wave, 4 way ve 16 way diye gördük. Yani 8, 4 ve 16 way diye gördük. Oradaki 8, 4 ve 16K'ya karşılık geliyor. Yani bir set içerisindeki cash line ses. Yani kaç tane cash line'ı bir şik bir tane set oluşturuyor. Çünkü bu set eee içerisinde asociative mapping gibi davranacak her bir set ama sete erişim sırası geldiğinde o setler bir cash line gibi görünecekler. Direct cash mapping gibi davranacak sistem. Bir de V sayıs V sayımız var. V sayısı tabii burada şey de gösterilmiyor ama V sayısı number of set'i gösteriyor. Set sayımızı gösteriyor. Tabii number of set daha çok bizim keşimizin ne kadar büyük olduğuyla alakalı bir durum. Eee çünkü hani keşiniz büyük sizin buradaki şey sayınız belli. Her bir set için eee kullanacağınız cash line sayısı belli. Dolayısıyla set sayısını artırmak istiyorsanız eee o sayıda fazla cash line'a ihtiyacınız var ki set sayısı bir bir artsın vesaire gibi düşünebilirsiniz. Bu dolayısıyla cash size'ınızla alakalı bir durumda. Ve eee burada tekrardan bizim eee CPU'nun üretmiş olduğu şeyler ne bu eee adres tekrardan 3'e parçalanacak. Direct cashmapping'deki gibi 3'e parçalanacak ama Orada hatırlarsanız e tagimiz vardı. Line number vardı. Bir de word ofset vardı. Burada ise e line number yerine set number kısmımız var. Yani kaç tane setimiz varsa onu adreseyebilmek için gerekli olan bit sayısına ihtiyacımız var. Bu da şeyden kaynaklanıyor. Yani memory bloğunu alıp biz direct cash mapping'de bir cash line'a map edeceğimiz için orada line adresini tutuyorduk. Burada ise memory bloğunu alıp bir set içerisine yerleştireceğimiz için set adresini tutacağız. Yani mekanizma şey aynı aslında. da sadece set üzerinden eee gidecek. Bir sette işte K tane cash line'dan oluşacak. Böyle bir iç detayı bulunmakta. Şimdi eee şöyle bir yapı var. Yine şimdi tekrardan şunu bir algılamaya çalışalım. Aslında bununla ilgili bir tane eee YouTube videosu var. O yani ben elimden geldiğince çizim yapmaya çalışıyorum ama benim çizimlerim biraz karmaşık oluyor. Eee güzel bir anlatım buldum. Onun üzerinden de bir tane örnek üzerinden de düzgün grafiklerle örnek üzerinden de eee izleyip Bu ben bu konuyu anlattıktan sonra şimdi Kway Set asociative mapping'de eee dediğimiz gibi bir tane word of setimiz her durumda var. Üç türde de bu var zaten. Burada tekrardan bir set adres kısmı geldi. Bunu D ile temsil ediyoruz. Artık eee tek kısmımız var. Tabii şu kısım yine bildiğiniz gibi bu blok adresi aslında burası değişmiyor. Yani S olarak ifade ettiğimiz blog adres kısmı değişmiyor. Sadece set kısmını Dbit'le temsil ediyoruz burada. Dolayısıyla tek kısmı S - D olarak ifade edilmiş durumda. Şimdi burada eee K tane şimdi Kway set asociative'de K tane line K tane line birleşerek şunların her birisi bir line şuraya iki tane çizdim ama her birisi bir line eee bir seti oluşturuyor. 2inci set 3üncü set tane set oluşuyor burada. Dolayısıyla belli bir memory bloğunun e şuradaki işte kaç tane set oluşmuşsa kapasiteye göre cas kapasitesine göre kaç set oluşmuşsa işte 4 bitli temsil ediyorsak işte 16 tane set var. 16 tane İşte bu Nway ise 16 sani setin her bir içerisinde işte two way diyelim iki tane cashlayısıyla cash line'ı bir cashlın içerisinde kaç byt var falan gibi bir takım bu hiyerarşik yapı üzerinden giderek bu sayıları basit bir şekilde yine bulabilirsiniz ve burada önemli olan bu yapıyı anlamak yani ezberlemek falan kesinlikle değil bakın bunu anlamaya çalışın zaten hepsi eee nasıl söyleyelim birbiriyle tamamen tutarlı bilgiler. Hani hepsini birkaç farklı yerden destekleyebiliyorsunuz. Bit bazında açıklayabiliyorsunuz. tarafından açıklayabiliyorsunuz. Cash tag bazında açıklayabiliyorsunuz. Set bazında açıklayabiliyorsunuz. Byte cinsinden, line cinsinden eee yani birçok yerden aslında bu sayıları doğrulayabiliyorsunuz. Çünkü hepsi tamamen, eee, nereden bakarsanız bakın birbiriyle uyumlu çalışan, eee, yapılar. Sol derece güzel dizayn edilmiş, organize edilmiş yapılar. Bu arada şimdi eee ne dedik? Her bir setin içerisinde cash line'larımız var. Cash line'ların içerisinde tag'lerimiz var. Yani bu cash line'larındaki tag'ler değişmiyor. Dolayısıyla Her bir setin içerisinde de bir sürü tagimiz var. Ama bir set içerisinde biz arama yaparken de asociated mapping yöntemini kullanıyoruz. Yani yine bizim en tane komparatörümüz var ama şu komparatör sayısı buradaki bütün tagler için değil arkadaşlar. Yani buradaki komparatör sayısı benim şu setimin içerisinde kaç tane tagim varsa yani çünkü ben associative mapping'i set bazında uyguluyorum. Dolayısıyla bunu şey gibi düşünün. Eee hani direct cash mapping'de şurası bir cashline. Burası da bir cashline. Bir sonraki de cashline. Hatırlarsanız direct cash mapping'te işte bir tane eee şey vardı, komparatör vardı. Eee dolayısıyla şu kısımların tek bağlandığı nokta o tek bir tane kompatör oluyor. Ama bunun içerisinde bunun içerisindeki şu yapıları biz tek asociative mapping'deki gibi bir bir şu komparatörlere bağlıyoruz. Ama bu komparatör sayısı set sayısıyla vesaire çarpılmıyor. Tek bir tane set için komparatörünüz var. Dolayısıyla complex circuit problemi orada bir miktar çözülmüş oluyor. Çünkü kaç setiniz varsa o miktarda bir azalmaya sebebiyet verecek. Bu da drastik bir düşüş aslında. Eee geri kalan davranış aynı. Yani işte bir eee line içerisinde Word of Set üzerinden veriyi buluyoruz. Eee işte bir memory bloğunun işte bir set numarası var. Setten hangi sete dahil olduğunu buluyoruz önce bunun. Ardından o içerisinde asociative search yöntemiyle işte paralel bir search'le eee aradığımız eee verinin olup olmamadığını olmadığına bakacağız. Şimdi buradaki eee bir diğer avantaj dezavantaj durumu da ne? Ona da bakalım. Şimdi bu yöntem asociative'deki gibi her boş bulduğu yere bir veriyi yazmıyor. Mesela burada yine direct'teki şey problemi oluşabilir. Sizin çalıştığınız şey sürekli aynı setle işlem yapıyordur. Burası dolmuştur tamamen. Burada boş yerler olmasına karşın sizi burada seçeneksiz bırakmıştır. Buna sebebiyet verelim. Bu mümkün ama çok e aşırı olası bir durum da değil açıkçası burada. Çünkü birden fazla cashlan işte kompatör sayısı azaldığı için de eee devre bakım açısından işte power consumption açısından da birtım avantajları bulunmakta. Dolayısıyla bu yöntem hem eee işte eee direct cash mapping'in avantajını hem asociative mapping'in avantajını kullanıyor. Dezavantajlarını da düşürüyor. Ya yok etmiyor ama düşürüyor. Dolayısıyla ikisinden ol hibrit bir yöntem olarak karşımıza çıkıyor. Şimdi eee yine kitabınızın örneği benzer şekilde eee işte 16 MB'lık bir yine benzer memory 32 bitlik bir blog size'ımız var. Şimdi burada bakıyoruz. Tabii bu two way set asociative olarak uygulanmış. İki tane seti görüyoruz burada. Şimdi buradaki durum yine nasıl ona bakalım. Şimdi toplamda işte 16 MB neydi? 2 üzeri eee kaç 24 mü oluyordu? 2 üzeri 24 Geçen ders hesap etmiştik. 2 üzeri 24. Dolayısıyla toplamda 24 bitlik bir şöyle toplarsanız 24 bitlik bir adresimiz olacak. 32 bit yine bize eee 2 bitlik bir word ofi eee getirecek. Bunun dışında şimdi geri kalan 22 biti nasıl böleceğiz? Ona bakmamız lazım. Şimdi öncelikle eee sete bakmamız gerekiyor. Kaç tane setimiz oluşacak? Şimdi bizim keşimiz eee ne dedik? 16 kiloline'lık bir casimiz var. Bu byt cinsinden verilmemiş. Dolayısıyla 16 6'yı 2 üzeri 4 şeklinde yazdık. Kilo dediğimiz şeyi de 2 üzeri 10 şeklinde yazdık. 1 line'ımızsa 32 bit yani 2 üzeri eee pardon 2 üzeri 2 byte. Evet yani 32 bit 4 byte. O da 2 üzeri 2 şeklinde ifade ettik. Bu da 2 üzeri 16. 16 sanki 14 mü hesaplamıştık daha önce bir kontrol edeyim hemen. 10 2 üzeri 4 16 2 üzeri 10 x 1 line eee 32 bit 4 by tamam 14 16 tamam 2 üzeri 16 byt'lık bir keşimiz var doğru yapmışız şimdi 2 üzeri 16 byt'lık bir eee cashte bu cash size'ımız 2 üzeri 16 byt'lık bir cash size bu eee bunun eee içerisinde kaç tane set olacak? Şimdi bunu bulmanız lazım. Şimdi bunu bulmak için de bu sizeı böyle grafi de bulabiliriz aslında. 2 üzeri 16 eee kaç tane set olacak? Set size'ı bilmemiz lazım. Şimdi bir set içerisinde ne dedik? İşte two way set asociative mapping diyoruz. Yani bir set içerisinde iki tane cashlak. Dolayısıyla 2 üzeri 16'yı 2 x cashl'a bulmamız lazım. Cash line size'ımız ne? Block size'ile aynı. 4 byte. 2 üzeri 2 byte. Dolayısıyla 2 üzeri 3 oldu. Dolayısıyla bu ne oldu? 2 üzeri 16/ 2 üzeri 3'ten 2 üzeri 13 oldu. Yani bizim 2 üzeri 13 tane setimiz var. 2 üzeri 13 tane sets demiş olduk. Bu da demek oluyor ki bunu tabii adresleyebilmek için de kaç tane? 13 tane bite ihtiyacımız olacak. Şimdi toplam 24 bitti. 13 biti sete gitti. 2 biti offsite'e gitti. Eee 15 bit geriye kaç bit kaldı? Tag içinde 9 bitlik bir alan kaldı. Şimdi şuradaki gösterimde bakacak olurs Ak şimdi burada set number olarak gösterilmiş bu gösterim. Kitaplarda bunlar farklı şekillerde gösterilebiliyor arkadaşlar. Kimileri tek bir vertical bir gibi gösterip setleri o ereğin içerisinde mesela işte şu şekilde gösterip eee yani şunlar bizim memory bloklar pardon cash line'larımız diyelim. İşte two way set asociative'de şöyle birden bir böldük. Burayı bir daha böldük. Burayı bir daha böldük. Yani her iki line işte burası set 0 burası set 1 set 2 diye gidiyor. Yani line'lar, line numaralar işte 0, 1 2 3 4 5 böyle line numar cashler bir şekilde artarken setler her iki cashl'da bir artıyor şekilde o kadar sayıda cash şey setiniz oluşuyor. Şimdi 9 bitlik tag var dedik. 13 bitlik set eee indeksimiz var dedik. 2 bitlik de offset var dedik. Şimdi şuradaki yapıya bakalım. Şimdi eee set sayımız 13 bit olduğu için eee bunu eee 4 tane eee Nibble'la eee temsil ediyoruz. Hatırlarsanız geçen derste yaptık. Şimdi 13 biti temsil ettiğimiz şey ne olabilir? 13 biti nasıl gösteririz? İşte eee maksimum adres 13 bitte ne olacak? 1 2 3 4 1 2 3 4 8 tane yaptı. Şunu silelim aradan. Şöle silim. 1 2 3 3 4 toplam 3 pardon 4 8 12 oldu. 13 bit için şuraya bir tane daha 1 koyuyoruz ama geri kalan kısımlarını 0 yapıyoruz değil mi? Bu da 1 F f adresini bize üretecek. Bakın şurada görmüş olduğunuz 1 FF adresi aslında eee oradan gelmekte. Çünkü hani 13 bitle temsil ettik. 13 bitle üretebileceğiniz maksimum değer olmuş oluyor. 1F F adresi 1 FF F adresinde bizim yalnız eee bir tane setimiz var. Yani 1 FF f nolu bir setimiz var. Bu setin eee şurada görmüş olduğunuz bir tane cash line'ı burası. Diğer cashl'ı da burası. Yani öncelikle memory'nin üretmiş olduğu bir eee adresi hesap hesap ederken eee mesela şurası için şöyle bakalım. Mesela diyelim ki eee işte CPU şu şekilde bir memory üretti. Memory adresi üretti diyelim. Buraya Şim ürettik. Şimdi burada bizim eee son 2 bitimiz şuradaki şu 2 bitimiz şeydi neydi? İşte World ofti. Eee geri kalan 13 bit'i alacağız. Bakın geri kalan 13 biti alırken şöyle almamız gerekiyor. 4 tane aldık. Şuradan 4 tane aldıkmadan şöyle 4 tane aldık. Şuradan 4 tane aldık mı? Aldık. Ama tabii şuradaki o 1. almıyoruz. Şu birim başına sıfırlı kendimiz ekiyoruz. Dolayısıyla şurası kaç oldu? F. Eee, F. Şurası da F. Şurası bakın sadece 1 var burada. Şu mavi alandaki bizi ilgilendirmiyor. O kısım bizim için 0 olarak gelecek. 0 1 yani 0 şey 1 FF adresi yani 1 FF f nolu sete geldik. Bu set içerisinde eee ya şu tek bizim verimiz ki buradaki veriye bakacak olursak eee Onu da sileyim. Burada bu rakamlar hegades mi arkadaşlar? Bakın şurada sağ alt kışta yine e bir notumuz var. Memory adres value binary. Diğer değerler hexadecimal. Bakın hexadecimal diyorsunuz n gösteriminde son derece avantajlı ve kolay bir kullanım sağlıyor bize. Yani şuradaki mesela 1 FF'imiz 4 bitlik parçalar halinde tak bulabiliyoruz. Hexadecimal gösterimi o açıdan çok avantajlıydı. Dijital dizayndan hatırlayacak olursanız. Şimdi burada eee şu adresi yorumlarken 4 bit'i bu şekilde alacağız. Şu 4 bit ve şu 4 bit. Yani 1 0 ne olacak? Şu 1 0 4 8 12. Bu C harfine karşılık geliyor. Bu E 2'ye karşılık geliyor. Şunun başına da hep 0 ekleyeceğiz. Bu da 0. Yani bunun tek field kısmı 0 2C. Bakın bunu olduğu gibi şu haliyle eee yorumlamıyoruz. Hani tam bittiği yerden tek hesaplamamız lazım. 02C 02C zaten buradaki değermiş. Yani şurada bu set içerisindeki arama yöntemi asosative olacağı için paralel bir arama var. Hem 02 C'ye bakacak. Hem 1 FF'e bakacak. Şuradaki tege bakacak. Eee, bu bir komparatürden geçecek. Paralel komparatörlerden geçecek. Daha doğrusu 02C ise bura doğru yanıtı veren, eee, eleman olmuş olacak. Eee, dikkat ederseniz şurada yine 02C var galiba. Çünkü o da aynı şeyi üretmiş. Şurada gibi. Eee, bir setin bir tarafı dolu olabilir, bir tarafı boş olabilir. Yani bu tamamen, eee, o anki duruma bağlı arkadaşlar. Tabii kendi içerisinde, eee, mesela kimi yöntemler şey kullanıyor dedim ya. Yani burada işte list recinctly used, list frequently used gibi bir takım algoritmalar kullanılabilir. Eee eğer işte fullse ya da üzerine bir şey yazılacaksa mesela e sağdaki seti yani şuradakilerden bu tarafı e older'ı bu tarafa newer'ı yazma eğilimi olabilir. Dolayısıyla yeni bir eleman geldiğinde buradaki elemanı buraya aktarıp bu older olmuş oldu. Yeni eleman buraya geldi. Buradaki yine newer oldu. Yani aynı set içerisinde hangisinin atılacağına karar vermede böyle bir shift işlemiyle. Çünkü biliyorsunuz buradaki işlem çok hızlı olabiliyor. hani orada bir gecikme, bekleme vesaire diye bir şey yok. O yüzden eee böyle yöntemlerle bu iş gerçekleştirilebiliyor. Yani burada da böyle atla deve bir durum yok. Sadece hibrit bir yöntem olduğu için eee Nway set asociative mapping'i anlamak için dark cash mappingi ve asociative e mapping'i iyi bir şekilde anlamak gerekiyor. Eee evet sınav sorusu. Örnek sınav sorusu geçmiş yıllarda sordum. çözümü de kalmış üzerinde. Online derslerden 15 puanlık bir soru olduğunu görüyoruz burada arkadaşlar. Eee, consider ach byte addressable memory. Tamam. Eee, 2 üzeri 16 byte. Burada kolaylık olsun diye 2 üzeri 16 byte'ı direkt vermişim. GB vesaire bir şeylerle uğraşmak için ki zaten bu gigab değil. Eee, kilob mertebesinde bir hafıza. 2 üzeri 10. Bu grupta eee, antiblock size 8 byte olarak verilmiş. Asımda ha bu dar mapping sorusuymuş bu arada. Neyse tamam bunu da çözelim. Asınd direct map cash consisting of 32 used machine. Tamam. Şimdi eee ne diyeceğiz? İşte bir tane cashşimiz var. Bu cashşimiz içerisinde 32 tane line var. Yani şurada görüyorsunuz. Line 0, line 1, line 2, line 3, line 30, line 31. Toplamda 32 tane line'ımız bulunacak. Block size'ımız 8 byte. Dolayısıyla cash line size'ımız da 8 byt. Yani şurada e 0'dan 7'ye kadar 2 3 4 5 6 ve 7 byt'lar bulunmakta. Eee işte main memoryizde 2 üzer byte olarak vermişiz. Toplam 2 üzerine 16 -1 adresimiz şurasına karşılık geliyor. Bir blokta içerisinde de yine eee 8 tane byte bulunacak. Şimdi bu durumda işte eee burada ipucunu da vermişim. Niye böyle bir şey yapmışım ya? Ben sorunun içinde cevabı da vermişim gibi olmuş. 16 bitlik bir memory adres. Abi bir konu vermemem daha güzel olurdu. Yani memory adres tag, line number byte number'a nasıl bölünür diye sormuşum. Şimdi eee bir defa hani block size'ımız 8 byte olduğu için 8 byte'ı adreslemek için şurada 3 e bite ihtiyacımız olacak. Şimdi 16 bitlik memoryyi ben vermemiş olsam bile zaten şuradaki memoryi 2 üzeri 16 diye verdiğim için 16 olacaktı. Yani onu kendimiz de bulabiliyorduk zaten. Şimdi 3 biti böyle gitti. Geriye kaldı 13 bit. Şimdi Bu 13 bit'i tag ve eee cash line number olarak göstermemiz lazım. Şimdi bizim kaç tane cash line'ımız var? Ona bakmamız lazım. Eee o da direkt olarak verilmiş. Burada bakın 32 tane cash line'ımız var demişiz soruda. Eee çok 32 line. Dolayısıyla 32 line'ı adreslemek için bizim 5 bite ihtiyacımız var değil mi? E kaç etti? 5 3 8 yaptı. 16'ydı zaten. Tek kısmı da 8 çıktı. Yani 8 5 3 şeklinde. bir dağılım oluşacak. Bir eee CPU'nun generate ettiği bir adreste. Şimdi B şıkkında diyor ki, "What into what line will bytes of each of the following address be stored?" Şimdi şu 8 5 3 dağılımını bildikten sonra eee şuradaki eee yapıyı 8 5 3'e göre bölmemiz lazım. Bakın şuradan bir tane bölme. Onu ben yeşille tekrardan üzerimden geçeyim. Şurada bakın bir bölme yapıyoruz. 3 3 bitlik kısım. Ardından bakın 5 biti yaparken e şu 1 bit burada kalmıştı. O 1 + 4 de şurada var. 5 bitlik. Şöyle bir kısım daha yaptık. Orası da line. Yani şu kısım line. Bu kısım da tek kısmımızı oluşturacak zaten. Eee hani sorduğu soru what line diye sormuş. Yani cash line'ı nereye yerleşecek diye. O zaman line adresimiz şu. Eee ilk satır için 00 1 1. O da line 3'e karşılık geliyor. Burası line 6'ya karşılık geliyor. Line 3'e karşılık. geliyor. Bu da line e 21'miş. Line 21'e karşılık geliyor. Şimdi başka bir C şıkkında da diyor ki eee suppose the byte with address. İşte şöyle bir adres cash'te var. Eee bu veriyle birlikte tutulan cashşte tutulan diğer, eee, byt'lar hangileridir diye soruyor bize. Diğer byt'ların adresi hangisidir diye soruyor. Adres soruyor bize. What are the address of the other by with? Şimdi aynı bölütlemeyi buraya uygulad. ğımız zaman işte 3 bitlik şöyle bir şuradan böldük. Sonraki 5 biti line için böldük. Bu cash line 3'e karşılık geldi. Yani bize soruda aslında şunu soruyor. Cashline 3'te şu an hangi diğer adresler var? Cashline 3'ün tek kısmı şu olduğu için şuradaki kısmı olduğu için orası değişmeyecek. Yani 0 0 eee 0 1 0 kısmı değişmeyecek. Bu tagimiz. O tag'e sahip olan eee cashine'daki diğer eee adresler neler? İşte eee eee 00 1 bu da bizim line 3'ümüzü temsil ediyor. Yani bu kısım sabit ama burada işte bizim block size'ımız 8 olarak verildiği için burada 8 tane byte olacak. Bunlardan bir tanesi zaten şu kendisi zat-ı muhterem eee 0 1 0la biten. Onu burada diğerlerini sormuş olduğumuz için herhalde onu yazmamışım. 0 1 3 4 5 6 ve 7. Yani toplamda 8 tane kendisiyle birlikte adres bulunuyor. DDE E how many total bites of memory can be st in the cash diye bir şey sormuşum. E şimdi 32 tane line var demişiz zaten. 32 tane de line çarpı işte her birisinde line size olarak 8 byte diye söylemiştik. 32 x 8 256 byt'lık bir cashş memory varmış. Bundan eee işte bakın 15 puanlık bir soruymuş bu. Şimdi origin'ye geçmeden size demiştim ya bir tane video izletmek istiyorum diye. Eee ona geçiş yapacağım şimdi. Bir 10 dakika kadar onu izleriz. Ondan sonra dersi bitireceğim arkadaşlar. Gelme diye düşünmüştüm. Gelmiş. Well, a cash is just a small local area of memory that's designed to hold copies of data nearby for quick access. So, CPU caches are designed to store data from system memory or RAM. And the idea is that uh then the CPU can process the data without actually having to make continuous requests to RAM and this reduces RAM traffic and it greatly speeds up our programs. So, CPU caches are much faster than RAM and uh just as an indication it takes something like 100 or 200 cycles to complete a RAM request whereas it might only take say 5 cycles to access uh data from the cash. Ok so modern consumer CPUs we're talking AMD and Intel CPUs here. They generally include three levels of cash and they're labeled L1, L2 and L3. So the L there is just just short for level. Now L1 is the smallest but the fastest cash. L2 is medium sized and medium speed. And L3 is the largest but the slowest cash. And the other thing is all three of these caches in a modern AMD or Intel CPU are also what's called set associative caches. A set associative cash is broken into sets and each set can contain some specified number of elements called the associativity of the cash. So we could talk about a four-way set associative cash and that would mean that the cash has sets which store up to four elements. Or we could say an eightway set associative cash and that would be a cash where the sets contain eight. elements each. So, a set associative cash is really just a cash that's uh split into sets. Now, the elements that the sets hold are actually called cash lines or sometimes cash blocks. And it's a really interesting point and a very very important point. The CPU actually never reads and writes to its cashes or indeed RAM in bytes. It always reads and writes in cash lines. Yeah. So, it'll never write say a single integer or a single float. It always updates the entire cash. line. And in AMD and Intel CPUs, these cash lines are actually 64 bytes wide. So if you request a single little variable at some address, then the CPU is actually going to request the entire 64 by line that the variable belongs to. And this happens to mean that uh any address where the lowest hex digits are 00, 40, 80 or C0, any of those addresses are actually the start of a cash line. So the CPU does this to take advantage of access patterns in It's a funny thing, but if we access a particular B in RAM, then just because of the patterns that we use in programming, there's a very high chance that we're also going to use one of the uh surrounding bytes. Ok, so a set associative cash is split into sets and the sets contain cash lines. Ok, so this is an example of a very small fictional machine just so that we can get an idea of exactly how these set associative caches function. So we have RAM up the top. Now that's system memory. And for this little machine there's actually 200 56 bytes of RAM. So the RAM in our little machine just here can be addressed with a single bytte or 8 bits uh two hex digits in other words. And we'll use the low hex digit to specify the column and the high hex digit to specify the row. Yeah. So I've drawn it as a grid just here but this is actually flat. This is just a single dimensional array just like normal flat RAM in uh X64. So if you want to address RAM just here we could say something like well the hex digits are say 53 would reference this little six just here. Yes. So 3 being the low digit. We just look along the uh column there and uh look up the row number 5. Well, we could uh do hex digit number what? A1. Yeah, that would be the 3 just there. All right. And down below I've drawn a little set associative cash. So you can see in this particular illustration that there's actually four sets. But let's just pretend that we can't see that there's four sets for a moment. And uh we'll just spend a little moment to uh discuss how to figure out how many sets there are from the cash size and the associativity. Ok. So often the information that you're given the total size of the cash. which is 32 bytes. Uh you'll be given the associativity which is two way set associative and you'll also be told the size of the cash lines. Our fictional little machine just here will say that the cash lines are 4 bytes each. Ok let's work out how many sets there are. Well, if the sets contain two cash lines each since it's a two-way set associative cash and if each cash line is 4 bytes wide then that means that each set contains 2 x 4 bytes or 8 bytes in other words. And if the total cash is 32 bytes and each set is 8 bytes then the total number of sets must be 32/ 8. In other words, there are four sets. Ok, let's look at how addressing works. So, addresses are read in three sections. We've got the offset, the index, and the tag. And the offset is the lowest bits. Now, that references the exact byte from a line that the CPU might be interested in reading or changing. The index is actually the set index. And uh for us that will be 0, 1, two, or 3 for our little cash since we have four sets and the remaining bits in the address are read as the tag and the tag is just used to uniquely identify lines when they're stored in the cach. Ok, so we have uh eight bit addresses for our little cash just here. Let's compute the number of bits in each of the sections of the address. So we'll start with the offset the lowest bits. So for our cash cash lines are 4 bytes wide and that means that the offset is 2 bits. Log base 2 of the cash line size equ 2. In other words, we'd need 2 bits to accurately specify any one of the bytes from our cash lines. So that means that the lowest two bits of our dresses will be the offset bits. Next is the index. So the index specifies the set that a cash line belongs to. So there's four sets in our cach. So there's going to be two index bits in our addresses. So once again that's just the log base 2 of the number of sets. Yeah. So we've got four sets in this instance. So log base 2 or 4 gives you 2. In other words, you'd need two bits to accurately specify any one of our four sets. So the offset in our addresses will be the low two bits and the set index will be the next lowest two bits and that leaves the four upper bits to be the tag. Ok so looking at our little diagram just here we can actually make it a little bit easier to see. So we know that every group of four in our ram will belong to a cash line and what we could do is just colored green blue and yellow and arkadaşlar burada görüyorsunuz hani renklendirme yapılınca farklı renkler farklı setlere gidecekler. Bu Ping'teki durum yani fixed olarak mutlaka memoryün bu kısmı kırmızı olan kısmı kırmızı olan sete gidecek bir şekilde oraya yerleşecek. Mavi olan mavi olma şeklinde. Csam add şimdi arkadaşlar 73 73 deimalı düşünmeyin. Bakın başında 0 çarpı var. Bu onun hegadeimal olduğunu gösteriyor. Yani bunu 7 ve nibell'ara ayırarak 7 ve 3 şeklinde 4 bitle gösterebilirsiniz. Yani basit bir şekilde 0111'i ve 0011'i yazarsanız heximal 73'ü oluşturmuş oluyorsunuz. Ox73 Şimdi buna bakarsanız arkadaşlar sol taraftaki 4 bit 0 1 1 yani 7 sağ taraftaki 4 bit 00 1 yani 3 yani dönüşüm yapmanıza gerek yok. Onu tekrardan bir hatırlatalım. two bits will be the set index and the top four bits are the tag. So that would make our offset 11 our set index would be and the top four bits 0111 will be our tag. So what this means is that if the byte Ox73 is in the cash then it's going to be in set 00 or the first set in other words. So the CPU would look at the first set and it would see that the set is empty and it would determine that what it needs to do is read the cash line from RAM and we have what's called a cash miss. So the CPU would then send the request for the cash line containing the byte Ox. 73 to RAM and RAM would return the cash line 9055. So the way that we've drawn RAM just here 9 is the lowest bite of the cash line then the 0 and then the 25 at the top. So RAM is going to return the cash line 9055 to the CPU and the CPU is going to store that in its cash just in case it needs any of those bytes later. Now the set that this line belongs to is set 00 or the first set but when the CPU saves the line to the cash it also records the tag bits because it will need to know exactly which line this is late. Now this is the first element in set zer. So the tag bits 0111 will be written here and the data we read will be written here and the line is stored. So the cash doesn't know what the CPU is doing with the 5. The CPU is going to store the 5 in a register or do some computation with it or whatever. The cash doesn't know anything about that. All the cash does is store the cash line along with its tag. So notice that the offset bits were never stored in the cach. The offset bits are just used by the CPU to look up one of the bytes in the cash line. like the five that it just requested. Ok, so that was a cash miss. Let's have a look at what happens when there's a cash hit. So let's see what happens if the CPU reads address Ox70. So first of all the CPU wants to check its cash to see if this memory is already there. So what we got to do is convert the address OX70 to binary and we get 011100. So once again here the lowest two bits are the offset of the requested byte that's 00 and the next two bits are going to be the set index that's 00 also or in other words the first set. And the top bits are the tag. So 0111 1. So what the CPU knows from this is that if the line is in its cash then it's going to be in set zero. So what it's going to do it's going to look in set zero and see that there's actually data catched there. So what it's got to do now is check if the tag bits match in order to know if the line in the cach is actually the one that it's looking for. So the tag bits in the cach are 0111 which is an exact match for the tag of the address that it's looking for. Yeah. So the tag bits of the address it's looking for are 0111 also. Ok, so the CPU knows after comparing these two tag bits that this is the line that it's looking for. So what we've got here is called a cash hit. Ok so the CPU wants byte 0 from this line. That's the offset bits from the address that it's looking up. And that's the byte 9 just here in our little cash line. So the CPU is just going to read the 9 from the cash and continue on its way. So notice that it hasn't sent any requests to RAM at all this time. And in so doing, in getting the data from its cash, this operation is going to be performed much faster. Ok, so we've seen a cash miss and we've seen a hit. Let's have a look at a cash eviction. So, let's fast forward a little bit and say that our CPU has been executing for a little while and the entire cash is full of cash lines. So, now the CPU wants to read the byte address EA. Once again, it prefers to get this from its cash rather than RAM if it can. So, let's convert the number to binary to see which set the byte actually belongs to. EA in binary is 11101. So, the low two bits there are the offset. That's 10. The next two bits are the set index which is also 10. That means set number two. So if the byte at address EA is in the cach then it's going to be in set number two. Well, if we have a bit of a look at set number two, there's two data elements in set number two. The CPU is going to have to compare the tag bits from the address that it's looking for with the tag bits from both of the lines in the set to see if any of them match. Well, the tag bits from the first line in the set are 1100, so that's not a match. And the tag bits from the second line in the set, the right hand one here are 0100. So that's not a match either. Ok. So the CPU knows that the line that's looking for is not in its cash. It's going to have to get this from RAM. So, it's going to request the line containing the byte EA from RAM and RAM is going to respond with the data 1871. So, the CPU is actually looking for the number seven in that little cash line. So, it can go off and do whatever computation it has to do with that. But now it wants to cash the line 1871 that it just read from RAM just in case it needs those bytes later. So, the trouble is that the set is already full. So, in order to make room for this new cash line, the CPU has to evict one of the existing lines from the set. And the rules that CPU uses to choose which line to the line after it's eved are all part of a proced of the oldest line in the cash will be evicted. This is called the least recently used cash line. So in our little diagram here, the older cash line might be the right hand one. The CPU will evict the line 4545 from its cash. Possibly writing it back to RAM if there's been some change that it has to record. And then what it's going to do is move the line 9635 to the right position since that's now the older of the two cash lines. And It's going to record the new line recording the take bits here and the data here. And that, my friends, is pretty much how a set associative cash work. Yeah, just an illustration of a very small machine here. Yeah, so real CPUs work pretty much the same. It's just instead of having like 256 bytes in RAM, they've got like 16 gab and instead of being, you know, four-way set associative, they'll be 64way and that sort of thing. Yeah, but same idea, just uh larger numbers that they work on. So, this is really really important stuff because if we understand how a set associative cash works, then we can of make sure that the data that we need is actually in the cash when we need it and uh it can speed up programs like twice as fast or 10 times as fast. Ok.
Ok. Arkadaşlar sanırım konu anlaşılmıştır. Haftaya eee bununla ilgili pratik bir örnek de yapacağız. Derste bir kodlama vesaire bir şey gösteririm. Yani bunun önemi yani kişi kullandığınızda nasıl sonuç alıyorsunuz? Keşi kullanmadığınızda nasıl sonuç alıyorsunuz? onunla ilgili bir pratik örnek yaparız. Eee belki benzerini türünü de size ödev olarak da verebilirim. Bu hafta da burada keselim arkadaşlar. Haftaya görüşmek üzere. Bugün eee nerede kalmıştık? Cash mapping tekniklerinden bahsettik. Row meureing kısmından devam edeceğiz. Okey. Eee şimdi geçtiğimiz ders eee üç eee temel cash yönteminden bahsettik. Eee işte direct cash mapping, associative mapping ve set asociative mapping şeklinde dedik ki işte set associative mapping şu an günümüzde kullanılan eee teknik. Bir de bunların dışında eee yani bizim bu bas mimarisi nedeniyle ya da işte e Newon eee one botlenck eee problemini çözmek için kullandığımız tekniklerden bir tanesi de eee bu cash yöntemiydi. Fakat bu cash yöntemini eee doğru kullandığınız zaman yani cashin aslında yapısını bilip doğru kullandığınız zaman bunun avant larından yararlanabiliyorsunuz. Eğer eee yani burada cash'ten faydalanmak her ne kadar eee bizim için biraz abstrakt bir yapı gibi görünse de çünkü hani biz eee işlemci ve memory arasında işte memorydeki bir programı yazıyoruz. İşlemci de birtım instructionları yorumluyor, çalıştırıyor vesaire. Arada e işte kaç defa cash hit oldu, kaç defa cashş miss oldu kısmıyla biz programı yazarken ilgilenmiyoruz normal şartlarda. Ama bu tamamen bu kadar abstrakt bir yapıda değil. Eğer siz y yanlış bir program yazarsanız, yanlış bir program derken eee programın inputu ve outputu aynı olabilir. Fakat eee o bilgisayarın organizasyona uygun bir şekilde kodu yazmazsanız bu durumda tabii ki de farklı sonuçlar, farklı çalışma zamanları, rantime'lar elde edebiliyoruz. Şimdi farklı çalışma zamanları, bunu aslında ben biraz da paralel computing dersinde anlatıyorum ama eee şimdi normalde siz işte bir uygulamayı çalıştırırsanız Uygulamanın bir kısmı seri bir kısmı da paralel çalışabilir yapıdadır. Genellikle eğer herhangi bir data dependency'iniz vesaireniz yoksa uygulamada eee bunu tamamen paralel olarak da çalıştırabilirsiniz. Tamamen kompüte tam dayalı bir işleminiz varsa. Ama bu tabii ki de yani algoritmadan algoritmaya değişen bir yapı. Bunun için bir kabullenme yapmamız zor. Ama uygulamaların belli bir yüzdesi, seri belli bir yüzdesi de paralel çalışabilir yapıdadır diyebiliriz genel olarak. Şimdi burada paralel çalışabilir yapı eee eee daha çok işlemci ya da daha çok CPU coreu kullandığınız zaman eee daha eee kısa zamanda işte problemin çözüldüğü durumları eee oluşturabiliyor. Fakat eee burada eee işlemci sayısını artırmak her zaman için eee performansı aynı oranda artırmıyor. Bunu da bilmemiz lazım. İşte bunu da işte AMDAL yasasıyla eee biliyoruz. Amdal yasası bize diyor ki eee eğer bir uygulamanın tamamı paralelleş ilemiyorsa işte %90'ı paralel %10'u seri ise e bu durumda paralel kısmı mükemmel bir şekilde paralelleştirip 0 birim zamanda çözebilirsiniz. Yani o kadar trilyonlarca belki CPU'nuz vardır. Eee dolayısıyla uygulamanın paralel kısmını eee zamanını yok sayabilirsiniz. O kadar hızlı çözülebilir. Ama seri kısım mutlaka kalacaktır. Bu da şuna sebebiyet veriyor. İşte %90'ı paralel, %10'u seri olan eee bir eee uygulamada hemen hesap edelim. %10 paralel %90 seri olduğu zaman en fazla uygulamayı 10 kat hızlandırabilirsiniz. Yani isterse 1 trilyon tane CPU'nuz olsun. O uygulama sadece 10 kat hızlanabilir. 11 kat hızlanamaz. Dalal yasası bize bunu söylüyor. Aslında çok eee pesimistik bir yaklaşımı var Andal yasasının. Yani uygulamanın küçük bir kısmı bile seri olarak kalıyorsa o bizi ileride eee başka limitle lerle kısıtlıyor. Eee diyebiliriz. Şimdi bu da eee bu işin bir ayı. İşin diğer ayı da şu. Bu normal işte speed up dediğimiz bir kavram aslında. Size söyledim işte bu eee 10 kat hızlanma durumu. Eee hani normalde bir işlemciyle bir saatte çözüyorsanız bir problemi, iki işlemciyle yarım saatte çözersiniz gibi bir şey beklentisi içerisindeyiz. Ama kimi zaman bu Evet. kimi zaman bu şekilde oluyor. Hatta kimi zaman ise eee super linear speedup dediğimiz bir özel ell eee beklenenden daha fazla yani iki işlemciyle yarım saat de değil belki 15 dakikada çözebiliyorsunuz. Yani orada oluşan durumlar her zaman için sadece algoritmik yapıyla alakalı değil. Eee şimdi siz 2. sınıftasınız. 3. sınıfa geçtiğinizde belki işte bu algoritmik kompleksiti kavramını öğrendiğinizde eee biraz daha yerine oturacak bu anlattıklarım. Bu algoritmaların hepsinin bir karmaşıklığı var ve bu karmaşıklıklar eee Biz bu karmaşıklıkları hesap ederken basit anlamda işte koddaki döngülere vesaire bakıyoruz. İşte 1'den n'e kadar gidiyorsa onlik bir karmaşıklığa sahip. İç içe geçmiş iki tane döngü varsa O karelik bir karmaşıklığa sahip diyebiliyoruz. Eee bu da işte eee O kare olduğu zaman işte bu n sayısı karesiyle yani üstsel olarak arttığında da uygulamadaki bu n sayısı büyüdükçe eee bizim bilgisayarlarımızın, sistemlerimizin zorlandığını görüyoruz. Belki hani 10a 10'luk bir matris için işlemi çok rahat yapabilirken işte bine binlik bir matris için belki günlerce beklememiz gerekecek. Yani orada üstsel bir takım işlemler olduğu için hatta işte atıyorum matris çarpımıysa biliyorsunuz klasik matris çarpımı 3 tane for döngüsünden oluşuyor. Dolayısıyla O küplük bir karmaşık biraz sahip. Bu da eee boyut büyüdükçe eee karmaşıklığın çok ciddi oranda artması demek. Yani 10a 10'luk için belki eee 1000 tane işlemle kurtulabiliyorsunuz ama eee 10.000'e 10.000'lik bir işlem için artık trilyonlar gerekiyor. Dolayısıyla eee burada da eee karmaşıklık kavramı önümüze çıkıyor. Ama işin içerisine casş konusu geldiğinde bunun da ötesine geçiyoruz. Yani algoritmik kompleksit ya da algoritmik bu eee karmaşanın eee dışında bazı sonuçlar elde edebiliyoruz biz. Mesela eee atıyorum ON karelik bir algoritmanın on'lik bir algoritmadan eee daha uzun sürmesini beklerken daha kısa sürmesini de sağlayabiliyorsunuz. Eğer cashş yapısını düzgün bir şekilde kullanıyorsunuz. Burada önemli olan kit nokta Şu keşi casin yapısını ben biliyor muyum? Bir programcı olarak kullandığım programlama dili row measure ordering mi kullanıyor? Colum measure ordering mi kullanıyor? Hibrid mi kullanıyor? Ben bunu seçebiliyor muyum? Gibi birtım soruların cevabını biliyor olması lazım. Şu ana kadar Java ile programlama yaptınız belki biraz Python'la programlama yaptınız. Bu dillerde ne kullanılıyor, ne kullanılmıyor? Bir defa bunu bilmeniz lazım. Şu an sadece kodu yazıyorsunuz. Yani şu anki bilginiz evet bir problem var. Bir algoritma üretiyorsunuz. O algoritma sayesinde eee bir çözüm üretmiş oluyorsunuz ama eee bu çözümün computer organization tarafındaki kısmıyla çok fazla ilgilenmiyorsunuz. Çünkü bu zaten sizden bir şekilde abstrak edilmiş bir yapı. Yani CAS'in çalışma mantığı yani siz programcı olarak bir kod yazdığınızda cashşle alakalı herhangi bir işlem yapmıyorsunuz. Şimdi bu ders eee keşi de düşünerek eee işlemlerimizi nasıl yaparız ona bakacağız. Onunla ilgili bir tane örnek göstermeye çalışacağım size. Eee belki bu hafta içinde bir tane de ödev verirmedi artık bir ödevle başlayalım. Ödeviniz olsun. Eee eee kendiniz de hani bu yapıyı eee uygulayarak bir şekilde öğrenmeye çalışın. Yani bir şekilde eee bunu hatırlamanız için, tecrübe edebilmeniz için eee bunu bir şekilde kodlamayla uygulamanız lazım ki hakkınızda gerçekten kalsın. Çünkü önemli bir konu. Eee bunu eğer düzgün bir şekilde kullandığınızda yazmış olduğunuz uygulamaların da daha hızlı çalışmasını sağlayabilirsiniz. Şimdi burada eee böyle bir giriş yaptıktan sonra ROM measure orderin başlığındaki bu eee Bu slayt neyi gösteriyor ondan bahsedelim. Şimdi verilerimizi biz hafızada saptıklarken daha önceki derslerde şöyle bir yapı kullanmıştık. İşte eee işte memory bizim için eee şöyle hemen şuradan göstereyim. Memory bizim için işte eee vertical bir e array şeklinde durmaktaydı. Burada işte eee burada cash ya da işte memory burada eee vertical yapı içerisinde bloklarımız var. Bloklar içerisinde eee işte byt'larımız var vesaire şeklinde bir yapıdan bahsetmiştik. Rasureing'de ise bu blog e felsefesinin aslında eee belli kalıpları olduğunu, bu e blok yapısını düzgün bir şekilde kullandığımızda aslında başarılı sonuçlar elde edebileceğimizi eee göreceğiz. Şimdi şuradaki yapıya bakalım. Roll Maure Eordering'de eee matris şeklindeki bir eee veriden bahsediyoruz. Şimdi matris şeklindeki bir veride eee işte i'ler i değişkeni bizim satırlarımızı yani row dediğimiz satırları göstersin. J değişkenimiz de kolonlarımızı göstersin. Şimdi bu şekilde saklanmış. bir veri gerçekte bu şekilde duran bir veriyi eğer biz row measure orderingde saklamak istiyorsak memoride önce ilk row yani A, D ve A, B ve C eee değerleri memuriye yerleşmekte. Ardından D E F G H I J K L şeklinde bir yerleşim olmakta ki temelde bütün programlama dilleri neredeyse y birçoğu diyelim bu yapıyı Rome Measure Ordering'e kullanmakta. Eee, kimileri herhangi bir order kullanmayanlar da var. Eee daha çok bunlar yorumlamaya dayalı diller. Derlenen dillerde genellikle row maure ordering kullanılmakta. Eğer colum maure ordering kullanırsanız da bu durumda A D g şeklinde yani önce ilk kolon ikinci kolon sonra 3üncü kolon memory yerleşiyor. Şimdi diyeceksiniz ki hocam bu ikisi arasında bir fark var mı pratikte? Eee nasıl bir eee sonuç doğurur bu? Fark eder mi? Ya da yani sonuçta eee randomak access memoryden bahsediyoruz. Yani eee random access memoryin direct access eee avantajı neydi? Her eee memory öğesine eşit zamanda unik bir sabit bir birim zamanda erişebiliyoruz. İşte 30 nanosaniye ise 30 nanosaniye. Ben E harfine de 30 nanosaniyede erişebiliyorum. B harfine de 30 nanosaniyede erişebiliyorum. Dolayısıyla fiziksel altyapı bana fixed bir timing veriyorsa bunu row ya da kolon şeklinde saklamanın bir eee eee farkı var mı diye sorabilirsiniz. Şimdi elbette var. Neden var? Çünkü bu fixed fark dediğimiz şey yani fixed durum yani random access memory bize sağlamış olduğu eee sabit erişim süresi özelliği eee bizim eee primary memory için geçerli. Yani RAM'imiz için geçerli. Oysa eee bu Ral ordering'den bahsettiğimiz kısım aslında bizim daha çok Cash'teki yerleşim. Yani bir veriyi biz bir cas yerleştirdiğiniz zaman eee burada eee Daha doğrusu memoriye yerleştirdiğimizde bunu cashşe aktarırken tekrardan kullanımlarda cash hitlerinde ve cash mlerinde durumun değişmesi. Yani memoride evet A B C D'yi biz row olarak da yazsak kolon olarak da yazsak her bir byte'a sabit bir erişimimiz var gibi görünmekte. Ama bunu cash ile desteklediğimiz zaman işler biraz değişiyor. Yani cashin avantajını gerçekten biz kull kullanmak istiyorsak bu durumda işte birtım keşe ait özellikleri de düzgün kullanmamız lazım. Şimdi onunla ilgili bir tane örnek yapacağım. Örneği C'de yapacağım ama sizin bir şekilde eee C programlama bilginizin eee olduğunu kabul ediyorum. Eee yoksa da şey diye düşünebilirsiniz. Eee Java'ya çok yakın bir programlama değil şeklinde düşünebilirsiniz. Şimdi ben Windows'nda biliyorsunuz eee tıpkı işte Apple Store'dan ya da Google Play'den nasıl APK ya da uygulama indirebiliyor anız kurabiliyorsanız eee Microsoft içinde eee Microsoft Store var biliyorsunuz. Microsoft Store üzerinden eee Windows işletim sisteminize Ubuntu'yu bir uygulama gibi kurabilirsiniz ve onun özelliklerini, derleyicilerini vesaire erişebilirsiniz. Şu an benim makinem Windows 10. Eee içerisinde de Ubuntu eee şekilde kurulu durumda. Şimdi arkadaşlar eee bir tane klasör yaratayım. CS20 şeklinde. Bu klasör içerisinde de bir tane dosya oluşturalım. E draw measure ordering için bir tane C earning yazacağız. Pico'yu kullanıyorum editör olarak. Şimdi birkaç tane bu Java'daki karşılığı importa karşılık geliyor. Input'larımız var. C'de standart input output header dosyamızı ekliyoruz. Birkaç tane daha ekleyeceğim ben. Eee standart libraryimizi ekliyoruz. Zaman ölçümü yapmak için time ekliyoruz. Şimdilik bu kadar yeterli. Hemen basit bir int main main kısmı ekleyelim. İki tane parametri alacak uygulama. Eee, charge olsun. Burası da arg şeklinde. Bu main fonksiyonumuz public static void main karşıladık geliyor. Java'da biliyorsunuz her uygulamanın bir tane maain olmak zorunda. Eğer bu çalışabilen bir uygulamaysa bu bir lip ya da DL ya da shared obje gibi bir yapıysa main olması gerekmiyor. Eee, sadece bir hani obje cluster vesairedir öyle bir durumdaysa buna ihtiyacınız yok. Ama uygulamayı çalıştıracaksanız main fonksiyonunuz olacak. Şimdi, eee, bu uygulamada şöyle bir şey yapacağız arkadaşlar. İki tane matrisi matris biliyorsunuz iki boyutlu erey gibi düşünebilirsiniz matrisleri. İki tane A ve B matrisini toplayıp C matrisine atamasını yapacağız. Yani matrisin ilgili elemanlarını işte birebir noktasındaki elemanıyla B'nin birebir noktasındaki elemanını toplayıp C'nin birebirine atacağız. Böyle basit bir işlem yapacağız. Ve bunu dinamik olarak yapacağım için yani ben uygulamaya gönderdiğim parametrelerle matris boyutlarını ayarlayacağım. O yüzden A, B ve eee C matrislerini pointer olarak yapıyorum şu an bu kısım. Yani sizin şeyiniz de olmasın. Yani kafanızı biraz karıştırabilir ama şey değil. Eee asıl odaklanmanız gereken kısım değil. Şu an sadece memoral location yapacağım. Yani e hafızadan dinamik olarak eee bu A B C değişkenlerine yer ayırıp onlara rastgele işte değerler vereceğim. Sonra toplama işlemlerini yapacağız. Tabii bundan önce de eee tamam şimdilik böyle olsun. Bunlara hemen eee bu arada bir tabii şuraya şey yapalım. Row ve kolon bilgileri için iki tane integer ayarladım. Buraya da işte row kısmımıza e ask integer fonksiyonu yardımıyla argüman kısmından birinci parametremizi alalım. İkinci parametremiz de yine kola. Yani ben kare bir matris hani kolaylık olsun diye tek bir parametre işte 100 diye bir parametre gönderirsem uygulamaya 100'e 100'lük eee bir matris işlem yapacağım demek oluyor. Row ve kolu aynı seçmiş oldum. Ya da şöyle yapayım belki daha eee açıklayıcı olur. Şimdi daha sonra onu değiştirebiliriz. Sıkıntı değil. Eee öncelikle memorial location işlemlerini yapacağım. Sizin bir şekilde bu pointer aritmetiğini de öğrenmenizi isterim arkadaşlar. Eee güzel bir konudur ama eee zaman ayırmazsanız çok fazla bir şey anlaşılmaz. Eee Şimdi integer olarak her bir satıra eee pardon kaç tane satırımız var bizim? Roll tane satırımız var. A değişkenini yaptık. B ve C'yi de aynı şekilde bunlar aynı boyuttan olmaları gerekiyor ki işlem yapabilelim. Bir for döngüsü yapacağım. Onun için i ve j değişkenlerini de yukarıda tanımlamak istiyorum. Döngü içerisinde tanımlamayı sevmiyorum. i küçüktür. Eee gördüğünüz gibi Java'ya oldukça benziyor. Eee, row sayısından küçükken i + diyoruz. Şimdi burada a değişkeninin eee, her bir i satırına tekrardan mallık yapacağız. Burası da eee, integer eee, pointer olacak. Size of intar. Ve bu sefer de her bir kolonu için yapacağız. Eee, aynı işlemi B ve Cine yapmamız gerekiyor. B I C I. Ardından, eee, bir for dönüm dışı daha yapalım. Bunların indislerini memoryi aldık. Artık A, B, C eee, ayarlandı. J indisiyle de 0 J küçüktür. Eee, kolon sayısından J + yapalım. Şimdi burada yapacağımız işlem A I'ye başlangıç için 0 atalım. Diğerlerine de eee B ve C'ye ise round fonksiyonu yardımıyla rastgele sayılar atalım. Çok önemli değil. Şimdi e A = yani Aij = BJ + CJ şeklinde bir işlem yapacağız. Tabii bu bunların zamanlamasını ölçmek için de şuraya bir tane time val Start ve end diyelim. Zaman alma işlemi yapacağız. Şurada mallık get time of day fonksiyonunu kullanalım. Get time of day fonksiyonunu eee bize işte bir start time'ı o anki eee bu wall clock time gibi düşünebilirsiniz. Get time of the walk clock time arasındaki farka bakacağım. Şurada da tekrardan zaman alıyorum. End time'ı yani bu işlem bittikten sonraki end time. Bu işlem dediğimiz şey de bu arada arkadaşlar şey eee, memory allocation yapıyoruz. Yani RAM'den o büyüklükte bir alanı programımız için, prosesimiz için ayırıyoruz ve onu illendiriyoruz. Yani illendirme kısmımız şurası. Eee, şu kısım ise işte dinamik olarak memoryden, alma, hip'ten yer alıyoruz. Bu arada eee, ekrana da şeyi yazdıralım. Eee, time to ne diyelim bu? Time to memory allocate yü 4.4 F diyelim. Sıkıntısı olacak. Bu saniye içerisinden bir hesaplama yapacağız. Şimdi eee bitiş zamanının TV seconds'ını alalım. Eksi başlangıç zamanının TV second'sını alalım. Bu değeri eee şöyle çarpı 1 1 2 3 1 2 3 1 milyonla çarptığımız zaman şuradan bir sonuç elde etmiş olacağız. Bu sonuç bize eee milisaniye cinsinden değerimizi veriyor. Pardon nan saniye cinsinden değeri veriyor. Bir de buna şey eklememiz lazım. Ne ekleyeceğiz? Yine eee end'ten yine aynek farkımızı alacağız. Eee startın TV aldık. Nasıl bir şey oldu tam göstermedi bana. Parantez açtık, kapattık. Parantez açtık. Tüm bu işlemi de şun 1 milyon yaparsak 0 diyelim. Float olarak işlemimiz devam edelim. Evet. Şimdi bunu halletmiş olduk. Şurada da enter karakterimizi koyalım. Pantomalık bize söyleyecek. Şimdi bu işlem ilk kısım asıl bizim yapacağımız kısım şurada. Ekrana yazalım. Printf eee sat row measure. Row measure dedik. Hesaplama yapacağız. Eee hemen yukarıdan alayım. İki tane döngü. Döngüleri kapatalım. Tabii i i olmayacak. Burasını ş yapacağız. Aslında bütün olay burada arkadaşlar. İlk döngümüze i demek. İkinci döngümüze jelen. Tabii aynı da olsa da şurayı kolon şeklinde değiştiriyorum. Burada a eee I j = b i j + C I J şeklinde bir şey yazdık. Yani işte B'nin C'nin ilgili indeks değerlerindeki elemanları A'yı toplayıp A'yı C'ye atıyoruz. Ve bunu yaparken tekrardan get time of day'i yapmamız lazım. Zaman alacağız. Şurada tab burası end değil. Yine start olacak. Tekrardan bir zaman ölçümü yapıyoruz. Şurada bittiğinde de end oldu. Ve aynı şu hesaplama değerini de şuraya koyalım. Time to compute diyelim. Bizim için önemli olan time to compute. Eee, yine bu şekilde yapacak ve bitecek. Evet. Şimdi buna ne dedik? Roll measure dedik. GCC ilerleyicisini kullanarak e - o diyelim. Output dosyamız row measure. Olsun. Bunu da row measure. C'den üretsin. E, get time of day'i sevmedim dedi. Ne diyor? Ben get A 3 tane T kullanmışım. Gözden kaçmış. Onları kopyaladığım için hepsi öyle olacak tabii. Şurada T harfi fazla. Evet. R measure eximiz oluştur. Şöyle bakacak olursak bakın şurada yeşil renkli olarak biliyorsunuz dönük sistemlerde executable dosyalar yeşil renkle gösteriliyor. Hatta bunu şöyle yapabiliriz. Bakın yanında bunların x işareti var. User için, grup için, word için yani çalıştırılabilir dosya demek. C dosyasında çalıştırılabilir özellik yok. O text bir dosya sadece ret özelliği var. Okey. Şimdi eee şöyle bir row measure'la mesela küçükten bir tane başlayalım. 10a 10'luk bir işlem yapalım. Bakın 0,001 seconds diye yaptı. Bu memory allocation için geçen süre. Row measure'daki compute süresi ise sıfır. Bu makinede. Eee yüzlük dediğimde bakın bunlar hala çok düşük. Makine için son derece eee Kısa zamanlar 10.000'e geldiğimde artık bakın yavaş yavaş eee allocation time 2.30 oldu. Yani 2.3 saniyede memory allocate ettim. 025 saniyede de compute işlemini gerçekleştirdim. Eee 30.000lik eee almaya çalışıyorum. Yani 30.000'e 30.000'lik iki tane eee matrisi dinamik olarak eee oluşturup memoryden yer alıp ardından işte eee toplama işlemini gerçekleştiririz. Henüz şey gerçekleşmedi. Memoralation gerçekleşmedi. Evet 21 saniyede memoral location yaptı. Eee compute kısmı ise 2.8 saniye sürdü. Şimdi bakın bunu tekrardan çalıştıralım. Eee bu 21 saniye çok fazla değişmeyecektir. 2.8 de çok fazla değişmeyecektir. Yani küsuratlarında belki bir miktar oynayabilir. Ama tem olarak eee bu uygulama 30.000'e 30.000'lik işler yaptığında 21 saniyeye 2.8 saniye gibi bir sonuç üretmekte. Evet, 21'e 2.4 oldu. Bakın yani 2 saniye değişmiyor orada. Diğeri de yine 21'lerde. Bir defa daha çalışsak yine aynı bir şey çıkacak. Şimdi eee bu row measure'daki durum. Peki bu kodu ben alsam eee row measure.c bu koddaki şuradaki print kısmını değiştiriyorum ekrana. colon colon measure olacak yeni uygulamada. Bunu da row measure değil de call measure noktac olarak kaydedelim diyoruz. Bu arada call meureun arasına şuraya virgül geldi. Neyse onu şey yaparız, düzeltiriz. Sıkıntı yok. Eee, şimdi burada neyi değiştireceğiz? Bakın burada tek değiştirmek istediğim şey i ile j'nin sırasını değiştirmek. Yani şurayı aldım ve üst satıra yerleştirdim. Hatırlarsanız ilk versiyonda üst döngü i, alt döngü j'ydi. Şimdi üst döngü j, alt döngü i şekline geldi. Ha, bir şey değişir mi? Kare bir matris. Hiçbir şeyin değişmemesi gerek normal şartlarda. Çünkü IJ diye erişiyoruz. IJ diye erişiyoruz. Kare olduğu için bir şey değişmiyor diye düşünebilirsiniz. Bakın bu dosyayı şöyle call major kaydedelim. Noks yes diyelim. Kaydettik. Şimdi tekrardan TCC ile kodumuzu derliyoruz. Eee, call measure. measure.c dedik. Şimdi call measure. Exei 30.000le çağırıyorum arkadaşlar. Bakın çay içmeye bile gidebiliriz sanırım. Çünkü bu tamamıyla yanlış bir programlama. Hani biliyorsunuz şu ana kadarki öğrendiğiniz şeylerde hep önce Ira J'yi yazardık. Şimdi önce Ira J yerine önce J yazdığımızda bakın uygulamanız nasıl davranacak. Yine 21 saniyelik bu memoration kısmına dokunmadığımız için o yaklaşık 21 saniye civarında verecek. Şimdi colum measure işlemine başladı. Bakın normalde 2.4 saniyede biten bir işlemdi değil mi? Bir öncekde çoktan 2.4 saniyeyi geçtik ya da 2.8 saniyeyi. İşlem hala devam ediyor. Bekliyoruz. Çünkü şu an bilgisayarın e keşini kullanma özelliğini neredeyse kaybetti. Şu an eee bilgisayarda işlemci var, memory var, DDR RAM var ama cash her zaman için eee mise düşüyor. Ehşit'lerimiz yok oldu. Yaptığımız tek değişiklik eee oradaki for döngüsünde I ve J'nin yerini değiştirmek oldu. Hala uygulama çalışıyor. Biraz daha bekleyelim. Keşke 10.000 20.000 gibi bir şey yapsaydık. Neyse. Bekliyoruz. Bitti. Bakın 2.4 saniyelik çözüm şu an 71 saniyeye çıkmış durumda. Tek bir satırın değişmesi. Döngünün boyutu değişmedi. Bakın eee I'den J'ye kadar gidecekti. J'den I'ye kadar gittik. Peki bu değişiklik neden bilgisayarı bu kadar yavaşlattı ya da bu işlem ne kadar neden bu şekilde yavaşladı? Cevap cashş yöntemi. Şimdi biz Dedik ki memory tarafında bizim kullanmış olduğumuz eee işte bir block size bahsetmiştik. Hani offsitei vesaire hesaplıyorduk. Direct map d az önce şe belli bir blog size var. Şimdi bu blok içerisinde siz herhangi bir elemanı istediğiniz zaman, herhangi bir elemana erişmek istediğiniz zaman atıyorum ilk blokta işte 4 tane byte var. Siz 3 byte'a erişmek istediğinizde bu 4 byt'ın tamamı biliyorsunuz cas yerleşiyor. Yani siz sadece 3'e erişmek istiyorsunuz ama bütün bir o blok cashl'a yerleşiyor. Dolayısıyla siz bir sonraki elemanı istediğinizde eee aradığınız eleman zaten cash'te yer almış oluyor. Bu bir avantaj. Çünkü özellikle bu tarz işte compute hesaplamalarında zaten bizlere yaşıyorsak muhtemelen sıralı bir şekilde yaşıyoruz. İşte ilk elemanı, ikinci elemanı, 3üncü elemanı. Peki bu konuda bizim işlemimizi bozan ne oldu? Şimdi roll measure değil de romas'ı açalım. İşimizi bu durum şurası arkadaşlar. Bakın bu burada I ve J'nin şurada ben satır sırasını yer değiştirdiğimde biliyorsunuz hani önce önce e burada J 0 oluyor. Ardından for döngüsü şuradaki kısımda eee işte 0'dan R'a kadar artacak. Şimdi 0'dan eee rovo kadar arttığı durumda i değişkeni sürekli artıyor. Yani şuradaki işleme bakacak olursak I indeksi artıyor. J değil. Normalde rol Bizim beklentimiz J'nin artması. Yani satırda biz ilerlemeyi bekliyoruz. Satırda ilerlediğimiz zaman o slaytta göstermiş olduğum hatta tüm slaytı açayım şimdi size. Eee, şöle şimdi, eee, şu slaytta görmüş olduğunuz işte ben burada eee, diyelim ki şurada a bir row. Bizim blogumuz tabii ki 3 byt. Normalde 3 olmaz ama 3 olsun. C'ye erişmek istediğim zaman zaman A ve B de geliyor. Ya da A'ya eriştiğim zaman B ve C değişkenleri de eee buraya geliyor. Dolayısıyla ben D''ye erişmek istediğimde zaten bir cash hit olacak. C'ye erişmek istediğim zaman cashit olacak. Ama diğer duruma bakın. Yerleşime bakın. Eee columwise yerleş row wise yerleşmiş bir sisteme colonwise erişmek ne demek? Önce A00 0'a erişmek sonra A10'a erişmek yani D harfine erişmek istiyoruz. Yani kolum majurdaki yapılmak istenen işlem bu. Önce A A'ya, sonra D''ye sonra G'ye sonra J'ye erişiyor. Şimdi böyle bir erişmede A'ya erişmek istedin. Cashmis. D''ye erişmek istedin cashm. G'ye erişmek istedin cashm. J'ye erişmek istedin cashş. Sonra tekrardan B'ye geldiğinde belki cash line zaten dolduğu için bu da yine bir cashş daha çıkartacak. Yani burada özellikle bu boyut büyütünde zaten cash size'ın boyutunu açtığımız zaman e o yüzden işte bu hani 100 için 1000 için bu etkiyi görmüyor. eee, cash size'ımızın hala içerisinde belki hitler oluşabiliyor ama onu iyice büyüttüğümüzde, matris boyutunu büyüttüğümüzde artık aradığımız şeyi keşte bulma ihtimalimiz son derece düşük. Özellikle bu yerleşimi yanlış yaptığımız zaman bu da bizim eee işte performansımızı son derece kötü bir şekilde eee etkilemiş oldu. Yani şurada eee şimdi bu işin bu arada hani bir boyutu ben bunu biraz hızlandırabilir miyim? İşte eee mesela exzeyi Şurada row measure'ın egzisini oluştururken bir de mesela derleyicilerin işte 3ün derece optimizasyon da yap diyebilirim. Burada row measure'ı şimdi eee şöyle diyelim. Row measure'ı şimdi 30.000le çalıştıralım bir de. Bakın az önce en son row measure 30.000ile çalıştırdığımızda time to memory allocate işte 21 time to compete 2.4'tü. Bakalım yenisini Yani derleyicinin de bizim yazdığımız koda müdahale edip birtım iyileştirmeler yaptığında bakın eee süreyi artık 19 saniyeye çekti. Eee compute zamanında 1.1 şeklinde güncellemiş oldu. Yani bir miktar bizim yazdığımız kodu da daha da iyileştiriyordu. Tabii burada eee ne tarz işlemler var? İşte cash heit ratio'yu artıracak bir takım özellik. Çünkü arka planda derleyici biliyor ki işte bu alette mesela şeyden bakalım. CM'de benim bilgisayarımda My CPU get L2 cash size diyelim. Mesela benim bilgisayarımda 1024 MB'lık bir cash var. Dolayısıyla işte line size belli, row size belli. Eee, buna göre o bütün eee, ayarlamaları yaptığı zaman döngüyü kurarken buna göre arka planda güncellediğinde bu kötü durum değişir. Şimdi mesela şu şeydeki kodumuzta belki bir miktar colum ma'ı da belki eee, optimize etsek Orada da bir miktar iyileşme belki görebiliriz. Yol majör değil de kol majör diyelim. Yani tüm bu iyileştirmeleri yapabilmek için eee kodumuzdaki bu detayları bilmek gerekiyor. İşte matris bu bu arada çok ob şey bir örnek. Çok ekstrem bir örnek. Yani normal uygulamalarımızda böyle hani küçük döngülerde vesaire bu çok fazla bir etkiye sahip olmayacaktır. Cashfitler vesaire. Ama bakın burada da yine memoral location'a bir etkisi oldu. Eee, kolum majör kodunu değiştirecek mi değiştirmeye? Çünkü bazı derleyiciler bunun aynı işlem olduğunu düşünüp eee, rom majö değiştire de biliyorlar. Burası değiştirmedi. Yine de, eee, 71'den belki 71 saniyeden bir tık iyi sonuç da alabiliriz burad yarıya ya da yani bir uygulamayı daha performansı işte bu işte one bottle neck dediğimiz şey eee uygulamanın işte memory sıklıkla erişmesi nedeniyle o bastta meydana gelen trafik. Çünkü biz hem program kodumuzu hem eee işte kullandığımız datayı memoryden çekiyoruz. Dolayısıyla eee memoryden çok fazla veri çekmek istediğimiz zamanımızın büyük bir kısmını memoryden verinin gelmesini beklemekle geçiriyoruz. Tam 71'den 65'e çekti. Çok da fazla yapamadı. Yani olan majörürle yanlışlıkla yazdığınız kodu artık derleyici de çok fazla düzeltememekte. Eee bunu eee dediğim gibi yani küçük e boyutlardaki etkisi e Ras'e şu an bakın eee 2.1 saniye allocation 0,07 saniyede eee compute zamanına sahip. Gold maure aynı ebantla bakacak olursak daha çalıştırmalar Evet bu iki noktalye sahip herhalde anlaşılmıştır diye düşünüyorum burada. Yani neden eee row majörü tercih ettiğimiz, neden kod majörü tercih etmediğimiz bu arada şeyler değişmekte hani eee nasıl diyeyim? Eee programlama dillerinin eee programlama dillerinin eee romör COB majör tercihleri birbirinden farklı. Eee o yüzden eee kullandığınız programlama dilinin eee hangi ordering'i seçtiğine dikkat etmeniz gerekiyor. İşte bunu nasıl anlayabilirsiniz? İşte mesela hatırladığım kadarıylap colum maure ordering kullanmakta. Yani 0 elemanı A iken eee 0a 1 elemanı B'ye mi karşılık geliyor? Eee işte D''ye mi karşılık geliyor? Ona bakmamız lazım. B test ederek bulabilirsiniz. E bazı programlar dediğim gibi hibrit. Yani eee sanırım Java'da da öyleydi. Java da hibrit. Yani row ya da kolumlu kullandığını söyleyemiyoruz objeleri kullandığı için. Eee ama hani temel programlama dillerinde bu ROMW measure ordering olarak eee geçmekte. Şimdi bir aslında ara verelim. Eee sonra bu e association'lar, cash size'lar ve heitre'ler arasındaki bu bağlantıya da bir bakacağız. önümüzdeki derste chat kısmında bir şey hocam end yerine clock fonksiyonunu kullansak olabilir. Yani burada şey eee clock'un da detayına bakmam lazım. Bir saniye. L diyelim. Determine processor time. He şimdi e şey e clock'un tanım. Bir saniye şunu hemen şöyle göstereyim. Eee Şu screen. Şimdi bakın şeye baktım. Manclock dediğim zaman açıklamasında time hta determine processör time şeklinde bir açıklaması var. Bu aslında wall clock time değil. Şimdi prosessör time'ı e kullanmak istemedim burada. Neden? Eee çünkü prosessör time dediğimiz şey bir uygulama eee şeyi ne kadar kullanıyor? Eee işte işlemciyi ne kadar kullanıyor gibi bir yere gidiyor. Benim bahsettiğim get time of day ise wall time gibi bir anlamı var. Yani duvardaki bir saat gibi bir süreci başlatıyorsunuz. Hani bu işte yarışlardaki start stop mekanizmasına daha uygun olan o. Burada ise senin uygulaman işte belki bir saat boyunca eee CPU'da sıra bekleyecek çalışmak için. Eee zaman geçecek. Eee geçtiğinde belki yarım saniyede işlemini tamamlayıp bitirecek. Sana cevap olarak yarım saniye cevabını verecek clock fonksiyonu. Ama gerçekte sen yani dünyada geçirdiğin zaman belki bir saat olacak gibi yani öyle. bir şey öyle bir farka sebebiyet verir ama eee gerçekten compute time'la ilgili bir eee ölçüm yapmak istersek o durumda eee şey olacak. Eee o zaman clock gibi fonksiyonu kullanabiliriz. Onun dışında eee clock fonksiyonu şey yapacak eee sadece eee işlemcinin kullandığı zamanı almış olacak. O da şeyden şeye değişir. Yani her çalışmada eee bizim gerçekte beklediğimiz bir süreyle eee bize verilen süre arasında bir fark oluşturacak olacak. Colum ma uyguladığınızda cash kullanılmamış gibi oluyor dediğinizi için geçerli oldu değil mi? Şimdi kolum majör uyguladığınızda cash kullanılmamış gibi oluyor. Eee belli şartlar altında doğru bir cümle aslında onu da söyleyeyim. Yani atıyorum mesela %1e100'lük iki tane matrisle işlem yaptığımız zaman eee bizim cashl ımız yüzü kapsıyorsa bu durumda bu problem yaratmayacaktır. Bu tamamen eee sizin istemiş olduğunuz bir baytın memoryde bulunmuş olduğu bloğun içerisindeki elemanlara sizin ne kadar erişmeye meyilli olduğunuzla alakalı. Çünkü size eee row measure olarak organize edilmiş bir memoryde o row gelmiş oluyor. Siz programatik olarak da row'a erişmek isterseniz bu durumda her bir row'da ilk eleman bir cash miss olur. Geri kalan bütün elemanlar cash hit olur. Yani burada işte eee 4 byte var diyelim sizin eee bir cash bloğunuzda eee ilk elemana eriştiğinizde bir cash miss'le karşılaşacaksınız. Diğer üç tane elemana eriştiğinizde bir for döngüsünde cash hit karşılaştırın. Bu da sizin için cash hit ratio'yu %75'e çekecek. Yani eee 4 taneden bir tanesini miss yapıyorum. Ondan kaçarımız yok zaten. Geri kalan eee, hit oluyor. Tabii burada e line size'ı artırdığınızda bu tarz yapılarda aslında hani bu performansın ya da he ratio'nun da arttığını düşünebiliriz. Hani bir tanesinin atıyorum sizin 32 byt'ınız varsa bir cashl'da bir tanesi miss olacak, 31 tanesi hit olacak gibi. Yani hit ratioun ne kadar arttığını düşünün. Ama bunu row meure'a uygun bir kod yazdığınızda bund bunun avantajından faydalanabiliyorsunuz. Aksi halde siz ikinci row'dan bir eleman çektiğiniz zaman e keşe bir tane koca 32 byt'lık yer geldi ama siz ikinci isteğinizi oradan yapmadınız. İkinci isteğinizi başka bir bloğun elemanından yaptınız. Yine bir cashşe düştünüz. Yine bir cashm düştünüz gibi. Şimdi bu dedim ya bu örnek çok ekstrem bir örnek. Hani eee bunu gösterebilmek için direkt olarak hani ikinci eee bloğa atlıyor, 3üncü bloğa atlıyor. Bunun aslında şeyini görebilirsiniz. Eğer eee bir şekilde bunu bir otomatize edebilirseniz hiç eee işte cash size vesaire bilmeden eee zaman ölçümleri yaparak eee uygun uygulamanızın hangi noktada eee zaman açısından problem yaşadığını görebilirsiniz. İşte mesela az önce ben birkaç farklı değer denedim ya işte 100 için, 1000 için, işte 10.000, 30.000 için gibi. Eee, bunlar şeyi gösteriyor. Hani belli bir noktada aslında bir kırılma noktası var. Hani o, e, cash hit ratiuz bir noktadan sonra düşmeye başlayacak. İşte o düşmeye başladığı nokta aslında sizin cash line size'ını açtığınız nokta olmuş oluyor. Bunlar genellikten küçük boyutlarda dediğim gibi bunu hissetmiyorsunuz. Çünkü eee, cash hala yüksek ama yani diyelim ki hani sizin eee bir cash line size atıyorum 64 byte. Siz döngünüzü işte 32 byt'lık işte matrisiniz 32 ilk matris. E zaten ilk elemanı istediğinizde ikinci elemanın ilk değeri de orada olacak. Yani o orada roll meure yapsanız, colum mejure da yapsanız bir şekilde keşe yerleşmiş oluyor. Bu daha büyük ebatlarda eee karşımıza çıkan bir problem. İşte bunun çözümü için de kullandığınız bir neyi bil Bir eee kullandığınız programlama dili hangi eee ordering'i kullanıyor? Yani organizasyonel yapı nasıl? Hani yani ders computer organization ya aslında bu computer organization'da ilk derslerde ben size bahsetmiştim. Eee hani siz bir programlama program yazarken int a dediğiniz zaman bu a değişkeni işte 32 bit mi olacak 64 bit mi olacak? Bu computer architecture'ın problemi. Siz bu A değişkenini yarattığınız zaman bu bir DDR5 RAM'de mi tutulacak, SD RAM'de mi tutulacak? Eee, ya da işte bu row majör mü saklanacak, colum majör mü saklanacak? Bu da computer organization meselesi. Yani computer arkitecture computer organization'ı bu iki noktadan çok net bir şekilde ayırıyoruz. int A diye bir değişken yaptık. Bu a arka planda nasıl saklandı? Çünkü bunların hepsini biliyorsunuz bu altyapı işte bilgisayardaki bu abstrakt yapılar bir şekilde eee saklıyorlar bizden. Yani siz int a deyip geçiyorsunuz Java'da. İşte bir integer tanımladınız ya da float da double tanımladınız. Ya onun kaç bitlik olduğuna bakmıyorsunuz. Onu hangi bilgisayarda ya da hangi derleyiciyle derlemişseniz ona göre 32 bitlik ya da 64 bitlik bir obje oluşuyor. Geçiyor gidiyor. Ama bunu bilerek yaparsanız bu durumda işte bu tarz avantajları da kendi lehinize çevirebiliyorsunuz. Bu avantajlar neler? Cash zaten bizim için bir avantaj ama casken de işte row majör, colum majör kullanmak ekstra bir avantaj. Derleyiciyi kullanmak eee standart parametreyle kullanmak bir avantaj. Ama derleyicinin işte optimizasyon flagleriyle oynayıp eee onu eee iyileştirmek daha avanç. Şimdi mesela ben size gösterdim. İşte C kodu yazdık. Eee işte row measure yaptık. Bu bir artı. İşte optimization flaglerini açtık derleyicinin daha bu optimization flag'leri de bu arada hani 1inci 2 3 4 seviye diye gider. Kim kimin de daha büyük siz'lı bir egzozi oluşur ama çalışması eee daha rahattır daha hızlıdır. Kimi zaman eee Exenin size küçültür. Eee Time'a bakmazsa Exen'in boyutuna, file cinsi yani byte cinsinden boyutunu küçültmeye çalışır. Optimizasyon seviyeleri ise her ikisini beraber yapmaya çalışır. Hem size'ı küçültür hem eee compute time'ı küçültmeye çalışır gibi. Yani birçok e şey optimizasyonlar bulunmakta. Kimse heristick kullanıyor biraz daha hani uygulamayı hızlı çalıştırabilmek adına. Eee yani bazı durumlarda kullanılan heristikler işte düzgün uygulamanın düzgün çalışmamasını da sağlayabiliyor. Çünkü çok farklı algoritmalar var ve kimileri Bu kabullenmeleri eee mesela atıyorum işte bir değişken tanım int a dediniz bunu Java'da print yapmaya kalkın ya da işte int a dediniz stem out print eden deyin direkt Java size hatayı yapıştıracaktır orada bunu ilkilendirmediniz işte bunu böyle yapamazsın kim programladı diyecektir ki sen inti dediysen bunun ilk değeri sıfırdır. Hatta kimi zaman aynı programlama dili içerisinde bile farklı eee standartlar farklı versiyonlarda bu tarz davranışlar birbirinden farklı oluyor. Bunların optimizasyona girmelerinde de çok farklı işler olabilir. Mesela az önceki işlemde ben randomu kullandım. Neden randomu kullandım? Çünkü B ve C'ye ben eee 0 0 ya da B'ye 1, C'ye işte 2 gibi bir sabit sayı atamış olsaydım optimizasyon yaptı dediğimde belki derleyici e bütün cevaplar 1 + 2 3 çıkacak. Ben bunu her defasında toplama yapmak zorunda değilim. Skalar 3 değerine direkt assign geçer giderim gibi bir çözüme de gidebilirdi. Anlatabiliyor muyum? Yani bizim yazdığımız program ile derleyicinin eee anladığı ya da iyileştirmeye çalıştığı şey farklı olabiliyor. Bu kimi zaman semantik bir takım şeyleri de bozabiliyor da. Eee ama çoğu zaman avantaj sağlıyor. Ha bunun ötesinde de mesela daha da performans istersek ne yapacak? Daha da performans istersek mesela ben ne kullandım? GCC GNU C compiler'ı kullandım. Onun yerine gidip işte atıyorum şu an bilgisayarımda eğer bir Inın Inıntel işlemci varsa ıntel'in işte IPP kendi C compilerını kullanmam gerekiyor. Yani eee derleyici bakacak bilgisayarda. Evet şu nesil bilmem kaçıncı nesil bilmem kaçıncı familyidenu şöyle model bir işlemci var. Bunun cas şu kadar. L1, L2, L3 cashleri bu kadar. O zaman kodu ben bu şekilde derliyorum diyecek. İşlemciye özel bir egzo oluşturacak. Bunu yaptığı zaman da tabii yani işlemcinin de birtım kullanmış olduğu o kaynakları daha etkin bir şekilde kullanacağı için eee daha hızlı çalışabilen uygulamalar yine geliştirebilmiş olacağız. Yani burada performansı artırmak. Şimdi tabii çok daha farklı yöntemler de var. Şimdi bu ders için çok değil de hani bu yine one'daki bu botle aşabilmek için işte cash bir tane çözümdü işte ya da shared mimarilerinde işte eee multitread uygulamalar çok iplikli de diyoruz Türkçede eee yani çok eee işlevden oluşan uygulamalarla belki bunu yine aşabiliyoruz ya da işte paralel computing tarafında da yine benzer şekilde eee bu e seri çalışmadaki problemleri eee giderebiliyoruz. Ama seri eee seri çalışmayı her zaman için problem olarak da görmemek lazım. Özellikle computer organization dersiniz. Çünkü mesela diyelim ki eee biz şu an günümüzde eee seri kablolar kullanıyoruz. Yani organizational tarafta öyle de bir yapı var. Mesela eee çoğunuzun bilgisayarında kullanmış olduğu işte eee işte diskinizden anakarta işte ya da RAMize vesaire ilgili kısımlara veri aktaran kablonuz SATA kablosudur. Çok büyük ihtimal değil mi? Yani artık IDE kullanan çok fazla kalmadı. Neredeyse hepimiz artık SATA'yı kullanıyoruz. E SATA dediğimiz şey ne mesela? Serial ata yani ata standardının eee seri versiyonu. Şimdi düşündüğünüz zaman niye paralel versiyon yani pata niyi kullanmıyoruz biz bu arada pata diye de bir şey var ama tutulmadı. Eee yani bunun bunların hepsinin arkasında birtım işte şeyler var eee gerekçeler var. İşte şimdi veriyi paralel olarak göndermek varken neden veriyi seri olarak gönderiyoruz günümüzde? Çünkü paralel gönderdiğiniz zaman bunu şey gibi düşünün. İşte bir bas gibi düşünün ya da otoyol gibi düşünün. Ne kadar çok sizin şeritiniz varsa aslında birim zamanda O kadar çok yani trot bootunuz o kadar yüksek olacak. O kadar çok veri gönderebileceğiz. Ama eee şeyde eee şimdi gerçek mimarilere bakıyoruz. Tüm dünyada kullanılan sistem işte desktop computerlerde işte SATA kullanılıyor. İşte server sistemlerde SAS kullanılıyor. Eee her iki SASA SATA da seri bir sistem yani serial eee transmission yapan sistemler. Arka plana baktığınız zaman eee teknik olarak evet patın ya da işte eee para mimarilerin daha hızlı teoride daha hızlı gönderebildiğini görüyoruz ama pratikte gönderemiyorlar. Neden? Çünkü bir paralel kablolar fiziksel olarak daha büyükler. İşte yan yana gerçekten fiziksel kablolama gerekiyor. Ayrıca birbirine paralel giden bu kabloların en büyük dezavantajı ise siz bunlardan elektrik akımı gönderdiğiniz zaman doğal olarak siz bunu bakırdan yaptığınızda ve oradan elektrik akımı gönderdiğiniz zaman yine bir direnç oluşmakta. Yine bir manyetik alan oluşmakta ve gönderdiğiniz veriler artık o laneeki veriler birbirleriyle ilişkiye geçip artık in bozulmasını sağlamakta. Yani patanın en büyük problemi ya da paralel line'ların mesela en büyük problemi bu. Dolayısıyla siz ne kadar veriyi işte şeritleri hızlandırıyoruz deseniz de o şeritteki giden araçlar mıknatıs gibi birbirlerine yapışmaya başladıklarında artık o şerit şerit olmaktan çıkıyor. O yüzden günümüzde mesela seri iletişim o nedenle de kullanılmakta. Bu da sadece eee aklıma geldiği için söyledim. Yani şey eee ya burada şey var arkadaşlar. Yani bir şeyin neden olduğunu, niye olduğunu, nasıl olduğunu bir şekilde araşt bulursanız aslında eee hepsinin böyle mantıklı makul bir takım açıklamaları var. Eee o yüzden size tavsiye ediyorum. Eee bu arada C programlama dilini kesinlikle mutlaka ve mutlaka lütfen öğrenmeye çalışın arkadaşlar. Öğrendiğiniz Java'ya çok yakın bir dil. İleride kullanırsınız, kullanmazsınız o ayrı hikaye. Ama bir bilgisayar mühendisi olarak mutlaka hani bu altyapıyı size kullanabilecek düzeyde eee hem eee ya içerisinde işte atıyorum C++ olarak ilerlemiş olsaydı içerisinde C yeri açabiliyorsunuz. İçerisinde ben SM'ye geçip geri kalan kısmını, kodumun bir kısmını SMly'de devam etmek istiyorum diyebiliyorsunuz ve bunu eee büyük ihtimal yazdığınız kodları da uzun yıllar boyunca eee kullanabilecek durumda olacaksınız. Yani yazdığınız bir kod 3 yıl 5 yıl sonra kullanılmaz hale gelmeyecek. Böyle bir programlama dili mutlaka bence bir bilgisayar mühendisi öğrenmeli. Eee Java'nızı, Python'unızı, diğer işte öğrenmek istediğiniz platformları mutlaka tabii ki öğrenin ama kenardaki Köşede C bilginiz de mutlaka olsun. Mezun olduğunuzda mutlaka eee o kilit kimlikler mezun olun istiyorum. Size zaten eee ödevinizi C üzerinden vereceğim. Eee bu hafta hazırlamış olurum ödevinizi. Bir şekilde siz de C'ye giriş yapmış olursunuz. Eee internette yitirince bununla ilgili kaynak var. Bu arada şey ikinci derse geçmeyeceğim arkadaşlar. Eee 55 dakika olmuş zaten. Şey eee bugünlük burada bitirmiş olalım. Eee Eee, sizden istediğim kendinizi bir şekilde CEDEde geliştirin. İşte Daytel'in, eee, kitabı var. Denis Richin'nin kitabı var. Hani 1980'lerdeki bir kitap ama hala güncel diyebilirim. Eee, o yüzden şey, eee, kendinize bir tutorial vesaire bir şey bulun. Ben size öğretme ile eee, şey zaman eee, kaybetmeyeceğim çünkü çok kısıtlı bir zamanımız oluyor ve C eee, o kısıtlı zamanda size göstermeye çalışırsam eee, dersin geri kalan kısmını tamamlayamayız. Ama siz kendi boş vaktinizde ya da boş zamanlarınızda bir şekilde eee buna biraz zaman ayırabilirseniz. Çok değil yani haftada eee 1 saat 2 saat gibi bir şey ayırsanız aslında siyi öğrenebilirsiniz. Çünkü zaten dediğim gibi Java bilginiz var. Eee Java'dan çok daha basit bir yapısı varin. Eee sadece biraz tecrübe gerekiyor. Tecrübe için de size ben ödev vermeyi düşünüyorum. Eee hem bu R maasure ordering'i kendiniz deneyimlemiş olursunuz. Yani buradaki bu zamanlamalar işte vesaireleri eee hem de eee C'yi bir yumuşak bir giriş yapmış oluruz. Çünkü bu ders içerisinde dersin dönemin sonlarına doğru da biraz Cden işte SM'ye doğru vesaire gideceğiz bir miktar. Gerçi sizin gördüğünüzü de biliyorum SM ile ilgili bir şeyler. Eee ama yine de bir revise gibi bir şey yapmış oluruz. E orada da si ile alakasını belki daha iyi anlamış oluruz diye düşünüyorum. Okey. Burada keselim arkadaşlar yarın eee ne dedik işte associative ve cash size alakalı konuyla eee devam edeceğiz. Görüşmek üzere.
Evet arkadaşlar bugün eee dün raw maajure ordering'ile ilgili bir örnek yapmıştık. Görmüşsünüzdür. Bir tane de ödev verdim size. Eee üzerine giderseniz rahat bir şekilde yapabilirsiniz. Notlandırması bir şey net olabilir de. Eee sadece orada eee kodu Row Mure ordering açısından inceleyeceksiniz ve hatalı olan kısmı eee yani hatalı değil de R majur'e uymayan kısmını düzeltmeniz eee gerekiyor. Eee matris çarpımı algoritmasını hatırlıyorsunuzdur. İşte satırda ve sütunda işlem yapmamız gerekiyor. Eee, neyse onun üzerine biraz düşündüğünüzde belki sonraki derste tekrardan görüşürüz. Şimdi Rom maure'ten sonra eee, associativity'nin cash size'a olan etkisine bakacağız. Şimdi burada asociativity derken işte two way, fourway, 8, 16 way hatta 64'e kadar gidiyor bu. Veyler eee dikkat ederseniz eee heit ratio'ya olan etkisine bakacak olursanız o sütunların eee farklı cash size boyutları için söylüyorum. Eee bu arada eee cash size'ın aynı olduğu durumda two way, 4way, 8 ve 16 blokları var orada. Hani o şekilde figür okursanız işte atıyorum burada 8K için bakacak olursak 8K için eee dikkat ederseniz işte bu 4 way'den sonra 8 ve 16 waye Doğru aynı ebataki eee aynı boyuttaki cashlerde asociativityyi artırmanın eee cash hit ratya etkisinin olumlu olduğunu görüyoruz. Bunu nereden biliriz? Şöyle yapalım. Şuradaki needersiniz? Yani şuralarda her bir blok içerisinde bir artış söz konusu aslında. Bir miktar da olsa artış var. düşüklerde çok fazla olması da bir şekilde tartışmadı. Ama belli bir noktadan sonra yani 64 kanun üzerinde eee asociativitini artırmanın aslında Hitreo'ya eee katkısının artık sınırlı olduğunu ya da olmadığını görüyoruz. Yani eee ya evet cashş teknolojisi önemli ama iyileştirmeyi %90'ın üzerinde yaptıktan sonra zaten daha fazla bir iyileştirme alanı eee kalmıyor. Yani norum diyebiliriz. Hani bu o genç işleyecek bir yer kalmıyor. Dolayısıyla bu teknolojinin bize sağlayacağı eee hızlandırma ya da Hitre eşyaya katkısı bu şekilde diyebiliriz. E düşük olan eee düşük cashş eee miktarlarında asociatilitini artırmanın bir avantajı olduğunu görebiliyoruz bu grafiklerin aslında. Yani eee 32K'ya kadar olan eee cashlerde Hitreyi şöyle artırmak için aslında shability'yi artırmak eee olumlu sonuç vermekte. Şimdi bugün eee eee konusu biraz cash replacement algoritmaları ve cashle ilgili işte eee problemler aslında. Şimdi cash replacement algoritmaları eee daha önce ilk görmüş olduğumuz direct cash mapping yönteminde eee bulunmuyor. Çünkü direct cash mapping yönteminin temeli zaten eee algoritmasının kendi içerisinde barındırması diyelim. Çünkü mapping açısından memorydeki bir bloğun hangi cash line'la yerleşeceği zaten belirli. Eee dolayısıyla placement diye bir kavram yok. Hani 4 numaralı eee blok işte eee 2 numaralı eee line'a yerleşecek diye bir kural var ve siz bunu değiştiremiyorsunuz. 3 ve 4 boş olsa bile 2de veri varsa 2inin üzerine yazılıyor ama yine de oraya yazılıyor. Bu şekilde bir yapı var. Daha geçme hükmünde. Çok da flexible değildi hatırlayacak olursanız. Diğer iki yöntemde ise yani asociative ve set asociative yöntemlerinde ise eee orada durum biraz daha farklı. Eee, şimdi asociative ve set asociative'de eee, bizim eee, bir şekilde algoritmaya ihtiyacımız var. Neden? Çünkü eee, bu yöntemlerde eee, istediğimiz y flexibility vardı hatırlayacaksanız. İstediğimiz yere memory bloğunu yerleştirebiliyoruz. İllaki belli bir noktaya yerleşecek diye bir kural yok bu iki yöntemde. O yüzden, eee, istediğimiz yere yerleştirebilmemiz için de bir şekilde bize bir yer göstericinin olması gerekiyor ya da işte yerler dolduğu zaman eee ne tarz bir kural uygulayacağız işte override işlemini yapacağız ama işte overri işlemini yapmadan önce belki diyelim ki işlemci o cash line'ile ilgili bir update işlemi yaptı. Hızlı bir şekilde bir döngüyü çalıştırıyordu. E değişkenlerimiz o blok içerisindeydi ve orada biz eee şey yaptık diyelim işte yani bu işlemleri gerçekleştirdik. E update işlemi olduğu için de Cash'teki bilgiyle artık eee memorydeki bilgi farklı. olacak. Eee bu da işte bu replacement algoritmalarının eee detaylarını oluşturuyor. Yani bu replacement algoritmaları bu değişiklikleri yaparken neleri göz önüne alacak, neleri göz önüne almayacak eee onlara bakmamız gerekiyor. Tabii bu algoritmaların da tabii en temel özelliği, eee, yazılım üzerinden implement edilmemeleri. Yani bunu artık donanım üzerinde çalışan bir algoritma eee yani hardware code dediğimiz işte eee artık donanımın bu işi çöz mesi. Çünkü eee şimdi cashin asıl kullanım amacı ne? Hızı artırmak. E şimdi hızı artırmak için bir uygulama, bir software çalışmaya çalıştırmaya kalkarsanız bu daha da yavaşlatmaya götürecektir sizi. Bir diğer özelliği de bu case replacement algoritmaları donanımda bile olsa çok hızlı karar verebilme yeteneğine sahip olmaları gerekiyor. Eee şimdi bunlara şöyle bir kısaca bakalım. Aslına bakarsanız ben burada sadece birkaç tanesini belirttim. İşte list for frequently used, most recently used, most frequently used duruma göre yani most frequently use'e kadar gidebiliyor bu işler. Eee hepsinin kendi içerisinde birtım avantajları, dezavantajları var. Eee kiminin implement edilmesi daha basit, kiminin, eee kullanımı daha basit ya da işte çalışma zamanı çok daha kısa. Eee bunlardan en sık kullanılı işte list recently used dediğimiz eee algoritma aslında bu algoritmalar biliyorsunuz hani algoritmanın ismi aslında ne yaptığını az çok anlatır. Adı üzerinde recently ususe bu çok efektif bir algoritma olduğu için sıklıkla kullanılan eee bir yöntem. Burada bir cash içerisinde en uzun süreden beri referans almadan bekleyen eee bir eee cash bloğunu, cash line'ını biz replace ediyoruz. Yani bu ne zaman bu replace işlemi gerçekleşiyor? Associative asociative'de tabii ki de Eee ama burada dikkat etmemiz gereken işte orada bir veri var. Onun üzerine yazma durumu oluştuğunda yani keşimiz dolu olduğunda bu algoritmalar devreye giriyor. Tabii bunu donanım tarafında implement edebilmek için use bit ya da kimi kaynaklar buna age bit de diyorlar. Yaşlandırma biti ya da kullanım biti şeklinde ekstra bir bit'e sah sahip bir yapı var. Bu bit kullanılarak eee tabii bu her zaman eee ya bizim bildiğimiz anlamda bitten de oluşmayabiliyor. Eee yani birkaç tane bitten oluşabiliyor. Öyle söyleyeyim. Eee çünkü kendi içerisinde kimi zaman bir eee counter gibi, incrementin counter gibi bir şey saklaması gerekebiliyor. O yüzden hani sadece tek bitlik 0 1 şeklinde bir yapı değil bu. Eee zaten biliyorsunuz 0 ve 1ile sadece iki tane bloğu kontrol edebilirsiniz. O yüzden hani ismi o şekilde sadece öyle söyleyelim. Eee bu basit implementasyon yöntemi nedeniyle her ne kadar basit Ama yine de karmaşık bir yöntemi var. Yani listent used için bir şekilde list recent olanını keep track yapmanız lazım. Böyle takip etmeniz lazım, bulmanız gerekiyor. Bu yine belli bir zaman gerektiriyor. Bir diğer yöntem first in first out. Burada e cashlerisindeki bloklardan eee cash'te en uzun süre bekleyeni, en uzun süreden beri kalanını seçiyoruz. Burada onun ne kadar referans yapıldığı vesaire yok. List recent usedda eee yine cashşte longest kalan var ama eee herhangi bir referans yapılmamış. Yani orada bekliyor ama kimse ona cashit yapmıyor. Öyle bir durumda list recent kullanılıyor. Bu first first ise yine en uzun süre orada bekleyen eee replace ediliyor. Genellikle işte round robrin ya da circular eee circular buffer tekniğiyle uygulanabiliyor FIFO eee algoritması. Bir diğeri list frequently used adı üzerine yani en az scritler kullanımlarını Eee, bu da yine, eee, diğer üstteki iki algoritmadan farklı olarak bu zamana değil de, eee, kaç defa eee, bu cash line'ı, eee, referans edilmiş ya da buraya hit yapılmış. Dolayısıyla bunun implementasyonunda da bir eee, işte ne diyoruz? Eee, counter, her bir line için bir auto increment counter. Ne zaman oraya bir referans yapılsa o line'ın counterını bir artırıyorsunuz. Eee, tabii tagi ile bir birlikte yani şeyle birlikte eee uyması gerekiyor. Eee bu durumda işte eee en az eee count sayısına sahip olan cash line'ı replace işlemine tabi tutuluyor. Şimdi eee recently used bir de yanında bir de genellikle o most recently usedla karşılaştırılıyor. Yani bunun eee bir örneğini ekledim duruyor. List recently usedda diyelim ki işte 4 tane cashl ınız var sizin. Bu 4 cash line her ikisinde de 4 tane cashl var aslında örnekte. Eee list recently use'a işte bu line'lara A B C D E D F şeklinde bloklar yerleşiyor. Eee memory bloklarımız yerleşecek. A B C D E D F şeklinde. D tane cash line'ımıza bu nasıl yerleşirelim ona bakalım. Şimdi burada az önce demiştik bir e use bit ya da bir ag bitra bir bit bilgisi kullanılmakta. Bu da yine eee aslında eee şeyde gördüğümüz gibi eee list frequent olduğu gibi eee biraz eee auto increment counter gibi davranıyor diyebilir aslında bu 100 bit ya da Hbit özelliğinin. Şimdi basit bir şekilde bakacak olursak eee A geldiğinde şöyle göstereyim. Şimdi A geldiğinde A 0 şeklinde buraya yerleşmiş oluyor. B geldiğinde biliyorsunuz asociativede hani boş olan yerlere yerleşebiliyoruz. B geldiğinde bakın bu B1 olarak gelmişti. E C geldiğinde C2 olarak yerleşti. Hala bir boş yer var cashşte. D geldiğinde de D3 olarak yerleşti. Yani 0 1 2 3 şeklinde yerleşme oldu ve cashimiz artık dolu. Ve list recently use'u kullanacağız. Şimdi E geldiğinde list recentlyly used bilgimiz eee buradaki parantez içerisindeki bilgilerden işte en düşük değere sahip olan yani a çünkü a'nın değeri 0 olarak görüyor. İlk başta oilenmişti. Only dolayısıyla a'yı eee e şeklinde güncelliyoruz. Yani E geldiğinde A'yı güncelliyoruz. Fakat E bu E0 şeklinde bir şey olmuyor. En son 3'te kaldığımız için hatırlarsınız otoant demiştik. 3'ten sonra bu E4 şeklini alıyor. Yani eee A0'ın üzerine E4 şeklinde gelmiş oluyor. Ardından D geldiğinde bakın D artık bir eee cash hit. Daha önceki bunların hiçbiri cash hit değildi. Cashmi. Hepsi D birşit'e sahip. D biliyorsunuz şurada var. Yani şurada da var. Eee D3 şekl götürüyordu. Hit geldiği zaman E4'ten sonra geldiği için eee aynı noktada eee kendi counter değerini D5 olarak güncelliyor. Yani 4'ten sonra 5 geliyor ama D3'tü. O üçünü 5 yapıyor sadece. Orada bir replace işlemi yapılmıyor. Sadece kendi eee use bitini ya da age bitini güncel olanıyla güncellemiş oluyor ki daha sonra bir replace'e tabi tutulduğunda kendisi atılmasın. Çünkü en son kendisi güncellendi biliyorsunuz algoritma present. Dosa en eskiyi atmaya çalışıyoruz biz. Bu şekilde D geldi. F geldiğinde bakın şimdi yine dolu hepsi. Hangisi seçilecek? Aralarında en düşük değere sahip olan B seçilecek. Burada 1 var. Oraya da F6 şeklinde otorite bir artarak gidiyor. Bu least recently used algoritmasının basit bir şekilde uygulanmış hali. Most recently use'e bakacak olursak da most recently use algoritmasına yine A, B, C ve D eee kendi içerisinde bakın 0 1 2 3 değeriyle çok benz yazar bir çok yine auto bir yapıyla geliyor. Yine cash misler oluştu. Eee geldiğinde şimdi bakın E geldiğinde yer kalmadığı için bunlar içerisinde most recently used'u bizim seçmemiz gerekiyor. Most recently used hangisi? D'di. Dolayısıyla D3 yerine E4 gelmiş oldu. En yani en son hangisini kullanmışsak onu güncellemiş olduk. E şeklinde. Şimdi C geldiği zaman burada ne var? Burada bir cash hit oluşacak. Çünkü C daha önce gel vermişti. C2 olarak vardır. Eee bu durumda yine C2 de kendisini eee C5 olarak güncelleyor. Yani güncelleme mantığı şeyle listrouse'la aynı. E4 yerine eee C5 eee pardon E4'ten sonra işte 4 yerine 5 gelecek ama C kendisini mindiş oluyor. Eee keza D'de yine bir casşhetimiz var. Eee D'de cashşetimiz var. Burada hangisini seçeceğiz? Yine bakın en son güncellenmiş olan C5'i seçiyoruz. Burası güncellenmiş oluyor. D6 şeklinde. Bde yine bir eee temiz olacak. Eee dolayısıyla bu B7 formunu alacak. Bu da most recently used algoritmasının basit bir şekilde implement edilmesi. Tabii burada eee yani birçok assumption yapıyoruz. Yani burada belki çok basitmiş gibi görünüyor bu işlem ama arka planda yine bunun bir elektronik eee karmaşası bulunmakta. Neden? Çünkü eee bu cash line'lar içerisindeki eee eee işte list recently used için söylüyorum. List recentlyly used da en düşük use bit değerine sahip olan line'ın biliniyor olması lazım. Yani smallest indin bir şekilde smallest bit değerinin tutan line'ın bir şekilde bir yerde tutulması gerekiyor. Eee başka bir de işte her bir replace işlemi sırasında eee bu en küçük değeri bir şekilde sizin güncellemeniz gerekiyor. Eee bu sayede işte eee hızlı bir şekilde replaced iş gerçekleştirebilir ya most present'da da benzer bir yapı var. Şimdi eee bu cash replacement algoritmaları eee yine asociative ve set asociative için söylüyorum. Eee bir cash line içerisinde yer kalmadığında yani siz artık bir replace işlemine girmeniz gerektiğinde iki eee durum söz konusu olacak. Eee birincisi eee problemin olmadığı durum. Burada yeşil blokla gösterilmiş olan yani bu cash blowu içerisinde herhangi bir alter işlemi ya da update işlemi yapılmamış. Dolayısıyla eee onun üzerine direkt olarak yazabilirsiniz. Kaybedeceğiniz hiçbir şey yok. Çünkü onun bir kopyası zaten memoryde var. Yani memoryden cashşe getirilmiş bir blok var. O cash line'ı üzerinde CPU sadece belki okuma işlemi yapmış. Eee okuma amaçlı kullanmış o bölgeyi. Read only gibi kullanmış. Yani update yapmamış. E ve o bölgeye yeni bir eee cashş yeni bir memory bloğu yazılmak istendiğinde eee üzerine yazılabilir. Çünkü bir kopyası var, güncellenmemiş vesaire. Bu olumlu durum. Eee ama olumsuz durum nedir? Olumsuz durum o cashlada bir right operasyonunun yapılmış olması. Bu kırmızıyla gösterdiğimiz kısım. Eee bu durumda eee write işlemini yapmadan önce cash line'ındaki güncellenmiş bilginin tekrardan memory öncelikle yazılması yani memory'nin e up to date hale getirilmesi gerekiyor. Ardından bu e cash line'ı üzerine verinin yazılması gerekiyor. Tabii burada birtım problemler de ortaya çıkıyor. Onu da ikinci kolonda görüyorsunuz. Eee şuradaki kısımda yani şurada dedik ki biz eee bir problem yok. Hiçbir update yapılmamış. O yüzden direkt e üzerine yazabiliriz. Write edebiliriz o cashl'ın. Ama şurada write etmeden önce önce memory'ye gidip memory update edilmiş cash line'ını memory bloğu olarak yazıyoruz. Ardından replace işlemini gerçekleştiriyoruz. Fakat şimdi buradaki problemler neler? Eee, oraya bakacak olursak eee, birden fazla device main memory erişim eee, sağlıyor olabilir. Eee, hatta bundan daha büyük problem, eee, işte birden fazla işlemciye sahip ya da birden fazla CPU core eee, bu lokal kişi kullanmak istiyor olabilir. Bu durumda sizin yapmış olduğunuz ya da yapmaya çalıştığınız replace işleminin bütün işlemciler tarafından eee tanımlanması gerekiyor ya da tanınması gerekiyor. Eee bunu sağlayacak yapıyı oluşturmak biraz eee problemli. Şimdi burada iki farklı teknik var. Bir tanesi right through tekniği. Bir diğeri de right back tekniği. Cash memoryde cash replacement'da kullandığımız tekniklerden ikisi. Her ikisinde aslında e botl problemi bulunmakta. Eğer tanımlamalara bakacak olursanız yani burada right through'un da eee bir botunları var. Right back bir buttoni, potential bulunmakta. Ama eee işte mesela write true simplest olarak biliniyor. Neden simples technique? Çünkü eee cas yapmış olduğunuz bütün write işlemlerini aynı zamanda memoryde yapıyorsunuz. Yani birini güncellerken diğerini de güncelliyorsunuz. Eee dolayısıyla eee burada bir eee işte eee problemle karşılaşmamış oluyorsunuz teoride ama pratikte bu yöntemin dezavantajı ne? Eğer eee bir döngü değişkeni ise bu mesela 1 milyonluk bir for döngüsünüz var. Forda iyi değişkeniniz var. E şimdi CPU cashte sürekli olarak i değişkeni için cashş hitler oluşturuyor. Eee i işte I4'un i döngüsünde şey eee i değişkeni sürekli işte her iteration'da bir artıyor. Bu cash'te artıyor. Cash'te arttığı için eee right through yönteminde memoryde de iyi değişkenin olduğu yerin increment edilmesi yani increment edilmiş değerin artırılması eee gerekiyor. Yani bu cash blueu aynı zamanda memory yazılıyor. Tabii biliyorsunuz memory yazma işlemi pahalı bir işlem. Memor'an okuma da yazma işlemi de casege göre çok pahalı bir işlem. Dolayısıyla eee potansiyel olarak bir eee memor trafik oluşturma durumu var. Yani özellikle bu döngüsel yapılardaki değişkenlerde sıklıkla eee frekansı yüksek bir şekilde kullanılan değişkenlerde eee bir eee memor trafik oluşturması durumu var. Bu da bir bodlck dediğimiz darboğaza sebebiyet veriliyor. Yani orada işte eee iş eee cash ile eee sizin primary memoryiniz arasındaki işte bu front side b dediğimiz o BAS kısmında bir eee trafik oluşabiliyor through yönteminde. Tabii burada biraz da hani şeyden feragat et diyoruz aslında. Hani güncelleme işlemi yaptığımız zaman cashin o hit eee e işlemiyle aslında eee sağladığımız avantajı WR işlemiyle bir şekilde bir miktarını geri vermiş oluyoruz. Çünkü bir şekilde bunların eee senkron da olması gerekiyor. Yani eee siz işlemci cas'te hızlı bir şekilde eee güncelleme yapabilirsiniz. Cash line'ını update edebilirsiniz. İ değişikliğe anında orada güncellenir ama o güncellemenin memoriye yansıması gecikmeli olacaktır. Dolayısıyla bunun da bir şekilde handle edilmesi gerekiyor. Bir diğer yöntem right back yöntemi ise bir eee 4 bit yine ekstra bir bit kullanarak eee bu memory yazma işlemlerini right through'daki memory yazma işlemlerini eee azaltıyor. Eee update işlemi sadece memoryde gerçekleşiyor ve eee bu update işlemine sahip olan yani update işlemi yapıldığında artık memoryin ilgili eee blogğu invın invalid olarak ilan ediliyor. Yani artık birisi e sistemde memorinin o kısmına, o bloğuna erişmek istediğinde onun eee invalid olduğunu yani geçersiz artık güncellenmiş verisinin cash'te bulunduğunu görmesi gerekiyor ve buna göre bir aksiyon alması gerekiyor. Tabii bunu yapabilmek de şurada görüyorsunuz açıklamasında da var zaten. Eee complex circuit gerektiriyor. Yani eee 4 bitiniz olacak ve siz güncelleme yaptığınız zaman memoryin belli bir bloğunu da artık invalid olarak işaretleyebileceksiniz. Şimdi eee bu noktada cash cocy dediğimiz işte bu problemde işte cash'te bir update yaptık. Bu cash'le memoryyi eee aynı içerikte tutmaya çalışıyoruz. Bunu bu problemi nasıl çözeriz? Hızlı bir şekilde nasıl çözebiliriz? Basswatching yöntemi var. Yani eee o bus'a bağlı olan eee CPU'lar eee O bas üzerinde üretilmiş olan bir WR işlemini dedekt ediyorlar. Yani tespit ediyorlar. Bu durumda eee aslında bu durum right through policy de yani bizim şurada göstermiş olduğumuz ilk policide geçerli. Eee bir right operasyonu şurada bahsetmiştik ya işte eee bir right operasyonu gerçekleştiriyor rightda. Ve bu right operasyonunu bas üzerinden işte kokluyoruz ya da sinif ediyoruz ya da buluyoruz bir şekilde. Eee, bu durumda bütün cash controllerları eee, kendilerini update ediyorlar. Eee, işte bu line'da bir update yapıldı diyerek eee, bu bir yöntem. Yani bası izleme bir yöntem. Hardware transparency başka bir yöntem. Eee, burada ekstra bir eee, hardware kullanılarak bizim primary memorisdeki eee, daha doğrusu cashteki bütün eee, değişikliklerin e main memory yansıması gerçekleştiriliyor. Bu dediğim gibi yine complex circuitry gerektiren bir çözüm. Eee eğer yani bu bu yöntemde eğer bir prosesör kendi keşindeki bir bilgiyi güncellerse eee bu yine bu right through'daki gibi gidip main memoryde güncelleniyor ve benzer yapıdaki diğer cashler de güncelleniyor. Yani bu alını kullanan diğer cashler de güncelleniyor. Şimdi bu şu demek. Memoryaki X noktasını eee 0 nolu CPU coreuz güncelledi. O X noktasını kullanan başka CPU core'ları varsa shared memory bir uygulamadan bahsediyorum. Bu durumda diğer cashler, diğer CPU'nun lokal cashleri de kendilerini güncelliyorlar. Bu bir transparent bir şekilde gerçekleşiyor. Yani bizim bir şey yapmamıza gerek yok. Sistem kendisi bunu gerçekleştirebiliyor ama bunu yapabilmek için de belli bir koordinasyon işte karmaşık bir devre tasarımı vesaire gerekmekte. Daha basit bir çözüm, performansı düşüren bir çözüm ise non casable memory tanımı yapmak. Yani memoryin eee sadece belli bir kısmını paylaşıma açıp eee diğer kısımlarını non casable olarak deklare etmek, eee tanımlamak. Bu durumda, eee CPU core'un eee bu eee sher yapacağı bütün erişimler cashm olarak geri dönecek. Yani eee Eee, siz, eee, belli bir değişkeni arıyorsunuz. Hit mi olacak, miss mi olacak durumu ihtimali vardı. Non casable memory kullanıldığında otomatik olarak cashm'e düşmüş oluyorsunuz. Sadece ve sadece eee, cashş yapılmış kısım, cashş edilebilir kısımda cashleri yakalayabilirsiniz. Onun dışında bunu yapamıyorsunuz. Eee, bu da yani bir şekilde engelleyerek bu problemi ortadan kaldırma yöntemi. Şimdi az önce eee cash sizeı ile alakalı bir eee figür göstermiştim size. Yani cash size'ı ve asociativityinin cash hit ratio'ya eee oluşturmuş olduğu etkiyi görmüştük. Orada e hatırlayacak olursanız asociativity arttıkça aynı boyuttaki cash size da hitre da grup içerisinde artıyordu aslında. Bir de line size etkisi var. Bu değişik yanlış bir etki. Şimdi bu Line size eee biliyorsunuz Cash'teki bir line'ın eee büyüklüğü aslında. Şimdi temel anlamda biz ne dedik? Dünkü derste gördüğünüz hani bir örnek yapmıştık. Denizde de var. İşte eee row measure order kullanıyoruz. Çünkü bu cash line'ı mimik ediyoruz aslında. Çünkü biz eee bir cash line içerisinden bir tane byte'a eriştiğimizde eee memoryden eee işte bu keşe getirilmiş olan line içerisindeki diğer elemanlar Cash hitle erişiyoruz. Cashm olmuyor. Cashm demek RAM'e gideceğiz, okuma yapacağız. Bu külfetli, maliyetli bir işlem. Cashit'te ise bir defa cashşmimiz var. Sonra eee line size kadarlık elemanda biz sürekli keşit eee yapabiliriz. Hatta daha fazla da olabilir. Bir döngüyle belki bu değişkenlere yaşıyor olsa daha fazla da olabilir. Dolayısıyla eee biz burada eee line size'ı artırdığımız zaman yani eee başka bir ifadeyle eee Eee, burada block size'ı artırdığımız zaman heit ratio başlangıçta bir artış gösteriyor. E, bunun ana sebebi de principle of locality dediğimiz, eee, princip. Principle of locality ne der? İşte siz bir erin ilk elemanına eriştiyseniz büyük ihtimal 2inci, 3ünc, 4 elemanlarına da erişeceksiniz. Yani bu veri yapılır. Bu yüzden bir programcı neden tek bir değişken kullanmak yerine bir array kullanıyor? Tek boyutlu bir arayı oraya ekliyor. Çünkü buna sıralı bir şekilde muhtemelen erişim yapacak. Eee, ya da bu şekilde kullanılacak. Yani bunun eee temelinde bu var. Dolayısıyla eee principle of locality'ye göre siz eee block size'ı artırdığınız zaman eee o blok memory casleşmiş oluyor ve bütün erişimlerde bundan sonra artık eee cash hit şeklinde dönüyor. Bu da hit ratio'yu artırıcı bir özellik. Yani biz block size'ı artırdığımız zaman daha kullanışlı daha kullanışlı veriler cash içerisine yerleşmeye başlıyor. Fakat eee block size'ı Optimumun üzerinde artırdığımızda yani çok büyük sayıda bir çok büyük kapasitedeki bir e block size bahs burada block size, line size aynı şeyi biliyorsunuz eee artırdığımız zaman bu durumda artık bu principle of locality'nin eee locality özelliği azalmaya başlıyor. Çünkü işte atıyorum siz oraya 1 MB'lık bir şey getirdiğiniz zaman muhtemelen sizin ereğinizde 30 tane eleman vardı ya da 100 tane 1000 tane eleman vardı. Eee daha fazla değildi. Dolayısıyla Principle of Locality'nin getirmiş olduğu o heristik bilgi artık biraz azalmaya başlıyor. Çünkü sizin memoriden gelen yeni bilginizin tekrardan kullanılma ihtimali daha az. Eee dolayısıyla eee burada bizim eee line size'ile ilgili söyleyeceğimiz şey Evet. Line size'ı artırdığımız zaman belli bir noktaya kadar yani sonsuza kadar değil belli bir noktaya kadar. Bu şeyde de böyleydi hatırlarsanız. Associativity'de de böyleydi. Eee yani cash sizeı bir yere kadar artıyors yani %90'ların üstüne zaten çıkmıyor. Eee öyle bir durum vardı. Burada da eee iki farklı eee etki var. Bir tanesi eee daha büyük bloklar kullandığımız zaman yani larger block size kullandığımız zaman eee cash iç cashşimizin cash sizının sabit olduğunu düşünüyoruz. Bu arada block sizeı artırdığımız zaman cash içerisine yerleşecek blok sayısını biz azaltmış oluyoruz. Bu birinci durum. Eee şimdi blok eee içeriği, blok sizeı daha büyük olduğunda da eee sizin aradığınız bir noktayla yani bu principle of locality'ye de azaltmış oluyoruz. Yani şurada eee söylenenım aslında o iki durum var. Yani iki durum da aslında larger block size'ile alakalı. Biz block size ya da cash line size artık zaman iki durum oluşuyor. Birincisi aynı kapasite için daha az sayıda cash line'a sahip oluyoruz ve cashl'ın içerisinde birbiriyle ilişkili bir veri bulma ihtimalini de azaltmış oluyoruz belli bir noktadan sonra. Çünkü bu kodlamada da programlama da yani siz bir kod yazdığınızı düşünün. Bir fonksiyonun içerisinde lokal birtım değişkenler tanıyorsunuz. O lokal değişkenler birbiriyle ilişkili ama o eee alanı line'ı çok büyük tuttuğunuz zaman başka bir fonksiyonun değişkenleri de onun içerisine giriyor. Halbuki siz o değişkenleri belki kullanmayacaksınız. Dolayısıyla o principle of local'ten uzaklaşmış eee oluyoruz. Şimdi bakın burada hit ratio ile L1 ve L2 cash sels arasındaki eee ilişki var. 8K ve 16K'lık eee L1 cash size için eee işlem yapılmış. Şimdi bakın burada dikey eee sütun bize heit ratio'yu gösteriyor. 078 098 aralarında. Yatay kısım ise L2 cash sizını göster. gösteriyor. Eee bakın L1 cash size 8 yani yeşil çizgiden bahsediyorum. Eee L1 Cash size 8K'ya kadar herhangi bir eee hit ratioda artış bulunmuyor. Eee yani çok az artış var. Benzer şekilde L1 dediğimiz eee pardon benzer şekilde L2'de de öyle bir durum var. Ama eee 32K'ya geldikten sonra bakın 32K'ya geldikten sonra ciddi bir artış söz konusu. Bu Elvan 8K'dan sonra eee bir artış yani 8K ile eee 16K arasındaki eee L1 CAS de ciddi bir artış bize sağlamış oluyor. Günümüz işlemcilerinde de aslında genellikle sunulan eee L1 ve L2 cash size bu civarlarda da gezinmekte günümüzde. L1, L2 daha fazla olanlar tabii var ama eee şurada da göreceğiniz gibi yani daha fazla olması size şuradaki artışa bakacak olursanız eee yani şu kadarlık bir ekstra getirecek. Hitre çok ekstra bir artış görmeyeceksiniz ki bu zaten grafik burada dikkat ederseniz 078'den başlamış. Eee dolayısıyla böyle bir de ilişki bulunmakta. Yani eee L1 biliyorsunuz bunlar hiyerarşik cashler. L1, L2, L3 şeklinde giden Eee, burada heit ratiomuzun daha verimli olduğu bir alan var. Eee, yani L2 cash siz'ınız burada belki en verimli alan TT gördüğümüz nokta belki 3264K gibi bir değer. Eee, L2 cash size için. L1 için de 16K, L2 için de 32 ya da 64K'lık bir değer aslında. Eee, optimum diyebileceğimiz bir noktayı verecek bize. Tabii bu buna sadece heat ratio açısından bakıyorum. Tabii ki de keş daha büyük olması eee yani çok fazla uygulamanın çalıştığı bir ortamda vesaire eee hitreationun en azından yüksek kalmasını sağlayacak yine avantajlı ama dediğim gibi maliyeti de beraberinde getiriyor. CAS bildiğiniz gibi çok ucuz bir donanım değil. Eee şimdi böylelikle cash konusunu aslında bitirmiş oluyoruz arkadaşlar. Şimdi bir eee ara vereceğim. Eee aradan sonra internal memory konusuyla devam edeceğiz. Eee böylelikle yine trak yapmış oluyoruz. Evet.Evet. So we said that the main difference between the computer organization and computer architecture is that computer architecture is more related to the programming and computer organization is more related to the hardware as you can see architectural then we the computer architecture including some programming related or if we talk about some transparent information some abstract information about the hardware I mean the details of hardware like the RAM type for example when you store your documents is it important that you store documents on a traditional hard disk or an SSD it doesn't matter or USB it doesn't matter because it's related to the computer organization computer organization hides these hardware related complexities from the users that's the main feature of good computer organization so all these details are somehow user computergan computer architecture program responsibility deal with the details of the system I mean it's your own responsibility to define 32 bit or 64 bit variable it's your own responsibility to define some assembly instruction that executes a quad word or double word type. So In computer architecture there is almost no abstraction I mean we don't hide those details because as a programmer we should know the technical details of the system but in the computer organization part usually the details of the systems are hidden from the users or it's somehow transparent to the user so shortly a computer architecture refer to attributes a system that's visible to a programmer say these attributes are usually have some direct impact on the logical execution of a program it's the program side so in in this field usually I mean in in this lecture especially in this course we will usually use a specific term called instruction set architecture used interchang to represent the computer architecture and instruction of set architecture simply defines an instruction format how the operation codes how the registers are defined what are their purpose how they used How an instruction and memory is represented and how they are executed in which order step by step execution logic all these details are defined in the ISA instruction set architectures. On the other hand when we come to the computer organization it refers some operational units and their interconnections. I mean to perform some architectural specifications like how connect motherboard which kind of is it PCI express or is it a R slot or is it some other socketbased architecture or slotbased architecture I mean all these details are defined in the computer organization so all these interconnections and their architectural specification is defined in the computer organization. So um one of the oldest systems today is the is known as the IBM 370. It's known as its famous architecture. This architecture initially introduced in 1970s and a number of models that use this architecture. Uh I mean in in the first time of the computers it's important that the price tag for a computer must not be too high because this is a new technology and every new techy is expensive or more expensive. So this architecture simply um performs an improvement on this fact because uh IBM 370 introduced that um instead of upgrading to some new models. We can use the same family of the architecture with some f enhancement and then we can produce a new product simply evolving a product evolving a new product to another product through some technical enhancement uh will introduce us a new computer. So this is first in IBM systems and still nowadays we have still the same um same uh marketing strategy I mean we have the CPUs and some new in in their instruction set maybe some new functionality is added and we have a new CPO new generation say so in these generations the important thing is to share a common family this um how you define a family caned a computer system architecture like others in Intel this is represented by the generations the e generation CPU nth generation CPU 10th generation I think the latest is 12 or 13th I'm not sure about that but somewhere there similarly AMD has the same mentality some Conation of CPUs is that the CPUs has sharing some instruction set architecture they have the same ability to execute the same. It has to be like that today because we have to execute the same application on very different machines. For example when you write an application Again, you don't think about whether this application can run on an Intel CPU or whether it can run on an AMD CP. Um, but at this point um again we have the transparency layers uh for the hardware so that our operating system provides some API functionality and through these API functionality our applications can run on many different hardware. That's related to the operating actually in our textbook we also have um somewhere here um as you can see one chapter is missing there uh chapter one two three f six se and chapter eight is missing and then nine 10 and that part is related to to the as I remember it's related to the operating system part uh I simply exclude the operating system section from the textbook because we have another course after this completely based on the operating systems. So I don't want to make an introduction about that. But the operating system is another aspect here. I mean we have computer organization, we have computer architecture and we have the operating system. Computer organization already provides a level of transparency and operating system also provides a programming level transparency. We say that hardware level transparency is provided by the computer organization. I mean you don't need to think about you don't need to think about the DDR RAM type right because of this hardware level transparency and similarly in in software part uh the operating system provides that kind of transparency. I mean when you write the application the same Java application run on an AMD machine or it can run on an Intel based machine Intel CP based machine or some other machines of course someone who there must be someone that supports this kind of transparencies otherwise uh you can even run the application on a single on the same for example think about the Microsoft products the Microsoft has many different operating systems over the last 13 years starting from the disc operating system 19 Windows 95 Windows 98 Windows XP vis millenniums and versions Windows 7, Windows 8 114 bit 16 bit possible operating system can support such backward compatibility 64 bit computers can support 32 bit backward compatibility but not more and 32 bit computers provide 16 bit backward compatibility but not more so I mean we have some transparency or let's say the backward compatibility abilities in operating systems however uh This is a limited feature. It's not a fully functional. I mean in Windows maybe already tried. When you would like to execute some old application you can ranch its features for the compatibility modes. I mean assume that this system is Windows XP or Windows 7 so that application can be installed properly. So all these uh things uh are based on the transparency levels. The operating provides these transparencies. The computer organization itself provides the hardware level transparency. But when it comes to computer architecture, there is no transparency at all. It's the programmer responsibility to uh select to design an application that runs on some specific platform. I mean as a programmer you should know that on which platform you are going to write your application. For example, when you write a Java application you should know that The first thing you should know is whether you are going to use a 32 with Java compiler or 64 Java compiler because depending on the need you should use some libraries some functionalities depending on either bit or 64 bit of course nowadays measured of the computers are supporting 64 bit and we don't have any more concern about 32 bit however this is still an important topic that you should be aware environ computers create application development platforms you should use compatible libraries I mean in a 64 bit application you can it's not a good idea to load a DLL function which supports just 32 bits I mean these kind of uh behaviors may lead to some undesied effects that's why in architecture part it's very important to know the technical details of these systems ok so um structure and function a computer is usually complex system more complex than you may think there are millions of different electronic circuits inside electronic components inside then how can we clearly describe each of them think that are billions of different microstructure exist and the key point is to recognize the hierarchical nature of the complex systems if if you remember from the digital design course the hierarchical approach was a better approach compared to the mathematic many of the mathematical approach because using math we can solve the problems right you can digital logic we can solve problem but we also need this hierarchical approach so that we can create more scaling applications so in order to create more scalable applications we should perform the hierarchy I mean some some less complex systems when they come together they create elementary system but then bring them together you will have much more complex systems based on these simple elementary and elementary level subsystems. So we have this subsystem architecture. So to create a hierarchical system the designers should constructure and the function. topics when we like to create solution the structure is the way where the how these components relate to each other and the function is simply the operation of these individual components as a part of this structure. So when you define it's it's mainly the logic behind the these system like performs addition as we try to create some transparency because we try to hide some details for the higher levels otherwise it will be very difficult to manage those billions of different microstructures Therefore basic functions that a computer can perform the data processing operations, the data storage operations, data movement operations caring from one location to another and data control operations. In data processing, we perform different uh processing record Here we can see that there are few fundamental methods of data processing. We can perform some arithmetic operations and other parts here. For data storage there are two options the shortterm data storage and the longterm data storage. Even if The computer is processing the data on the fly. I mean when the data came in and we process it immediately and the results go out immediately this is the underfly processing. The computer must even in that case the computer must uh store at least uh some piece of data because later on you will see that every instruction is executed in the CPU and in the CPU registers. So even if processes and on processing perform some storage I mean we should somehow locally store these data in some place some temporary place so in data processing we have this part in the data search we state that um when we store these information We need this short term storage. I mean these are the let's say a temporary variable. You can think that something like temporary variable and also we need some longterm search ability. For example when you write to your application you should store on your hard disk right this is a longterm storch for the short term it's just on the fly execution and storage of some data. We also have some data movements. Technically this is a short name given I input and output is also a function of a computer. You know a computer usually in its environment we have several devices devices directly connected to the computer and when we receive some data or when we deliver some data to these perf components or devices this process is called as the input and output operation. and the device technically called as the peripher. So whenever we talk about a par device it's a device directly connected to the computer. So when when we move the data over long distances or from or to a remote device then this is called as the data communication Technically input output and I mean from this perspective input output and data communication is the same thing the input output in the small scale or in inside the computer when you move some data from one device to another for for example from your hard disk to RAM if you transfer your data then this is the input output or when you give a print out it's then the output system when you print something on screen it's the output when you read something from keyboard etchutation device over a computer network through a computer network then this is known as this is called as the data communication what are the difference technically the measurement is different for example when you when you When you write a file on your hard disk drive, how can you measure the speed? Ok, this is a question for you. When you write a file to your hard disk, how you can measure the speed? What's the measurement unit? In the chat section, you can write if you don't want to talk. disk per second technical technical name megabyte per second ok mb that's correct Normally you should represent the M and B letters in upper case and Ar says that it's MBPS that's another measurement unit and that's related to the data communication ok so when we talk about the input and output the speed is measured I mean if you transfer information from one device to another inside computer then we use the megabyte transfer information computer computer media device then unit is bit per second not byte per second this is the main difference between the input output and data communication for example your internet connection is 100 megabit per second right recently in applications you may see that through the advancements in network connections we know that you can download 5 megab per second that's also possible because I mean previously in the early days of computers you know representing the speed through the bits per second is a lot more attractive than representing the same thing in bites per second still we have computer networks we have 100 megabit or gigabit network still we use the bit representation or when you when you rent when you have an ADSL connection or when you have a fiber connectivity still the companies tend to use the term bits per second because they represent eight times more uh number than usual. I mean for example when they say uh 20 megabit connection it means that in theory you can at 2.5 megb per second and you have to divide the 20 megabit to 8 to find out which is 2.5 megaby so this is just for marketing nowadays it's just a marketing related thing that they want to uh show some more numbers some higher numbers so that you will be attracted by those numbers. Ok. So just don't confused. This is the main difference. If it's inside the computer, you use the term megabyte. If it's over distance then it's the megabit for the data transfer. Ok. Another one is the control. The control unit simply manages the computer resources and it like an orchestrator I mean datab is used by which device who is going to decide this control unit who decide which capacity will be used which frequency will be used all these decision related stuff is handled by the control unit so usually we can represent the top level structure of a computer like that here in a traditional computer we have a control unit then I mean in this control unit the second logic the control unit registers decoders its own memory is here that's the core point but this control unit is part of a CPU and CPU has its um Let me mark in in CPU we have every CPU has its own set of private registers arithmetic logic unit and internal bus and this control unit but this CPU can be part of a computer there can be one or more CPU or some CPU course there is a system bus there is an IO and main This is a computer. This is the top level representation and its subparts is represented as different structures. There are four structural components exist. One of them is the CPU. It performs to all the operations. Sometimes it's called as the processor as well. The main memory it stores the data. The main memory is primary memory and memory primary memory is known as RAM that's more powerful one the secondary memory is your storage device your hard disk and other stuff we also have the IO which we perform a data movement operations from different parts differents of the environment and the system interconnection it's a mechanismation, the main memory input output devices. One good example of system interconnection is the system bus where a number of different wires connected different components so they can communicate through these um wires. Ok so these companies can be included once or more I mean there can be more than one CPU may exist or these companies can be duplicated so especially in the recent years there is a increasing use of multiple processors in a single computer so this is mainly a result of some issues related to the multiprocess comp later on we will we will also have some chapter rel to this topic a control unit simply controls the operation of the CPU and other say it controls the computer itself the arithmeticologic unit as the name says it performs the computers the data processing functions all the arithmetic and logic components are there all the logic related functionality the mat related functionality is proved by and the registers provides the internal storage to the c I mean every it's the I mean you can think that the registers are the variables of the our CPU but these are physical parts physical memory location I mean in your applications you have variables to perform some operations right you define some integers some characters some strings etc to do some um operations. The same thing is valid for the CPU but since CPU is a hardware and its variables are also hardware so registers are those variables and we have some specific sets for that. Every CPU every program is has to be bringed into CPU registers either as a variable or as a data or as an instruction depending on the type of the the CPU can perform operations through these registers and they are really fast by and the CP interconnection it's a kind of mechanism that provides the communication between the control unit arithmetic logic unit and the registers because we need to provide a mechanism between this how the CP works through the registers value in a register must be added or multiplied or some arithmetic or logic operation has to be made. So the al takes place sometimes the result has to be written back to main memory or secondary storage. So the control unit should arrange some control operations and so these are the structural components of a computer Okey. Bugünlük burada keselim arkadaşlar. 30 dakikayı doldurmuşuz. E dediğim gibi yani çok fazla gitmek istemiyorum. Eee siz de sıkılmayın. Çünkü eee dersin ilk başlangıç konuları biraz böyle eee genel. Zaten bu kısım biraz daha eee giriş şeklinde olduğu için eski ve genel bilgilerle biraz eee giriş yapacağız. Bir miktar sıkıcı olabilir ama sonrasında daha eğlenceli konular Özellikle keş memory kısmına geldiğimizde daha eğlenci konular başlamış olacak. Yarın kaldığımızda





NotebookLM yanlış bilgiler gösterebilir. Bu neden Systems eee konusuna geçeceğiz. Şimdi eee dünden bahsetmiş olduğumuz bir IS instruction setimiz vardı hatırlarsanız. İşte burada farklı eee data instructionlarımız vardı. Bu hani eee ilk eee 2. jenerasyon eee komlerde kullanılan bir eee altyapıydı. Şimdi burada eee bu farklı bir kitaptan bir slayt. Bunu da paylaşmak istiyorum. Bu sizin aslında 1. sınıfta Introduction to Computer Science dersinde eee okutulan kitabınızdan alınan bir şey. Öyle söyleyeyim. Eee örneğin çok basit bir uygulama. Dün gerçi size YouTube üzerinden PDP 8'de nasıl programlama yapıldığını göstermiştik ama eee yine de işte bir I computerde bu nasıl yapılır ona kısaca bir bakmış olalım. Şimdi öncelikle eee memorydeki sayıların eklenmesi konusunda birinci işlem step 1 içerisinde eee memorydeki bu değeri alıp bir CPU registerına yerleştirme var. Yani eee from memory eee place itani memoryden al register'a yerleştir ilk aşaması. Ardından eee diğer değer yani other value dediğimiz kısım da yine from memory and place into another register. Başka bir register içerisinde de o yerleştirilmiş oluyor. 3üncü aşamada da activation işlemi yapılacak. Ne activate edilecek? Bu integrated circuitler arasında yer alan al içerisinde yer alan addition circuit hatırlarsanız dijital dizayigndizin eee ee toplama yapan birtım işte halfeter, feder gibi bir takım devrelerimiz vardı. Bunu enable yaptığınız zaman ve input olarak da bu registerları oraya bağladığınız zaman bit bazında eee bu devre additional circuit bize toplama işlemlerini gerçekleştirecek. Eee yani step 1 ve 2'de almış olduğunuz inputları kullanarak başka bir registerı eee başka bir register içerisine sonuç değerini eee hesaplayıp aktaracak. Bu başka register genelde biliyorsunuz aritmetik için içerisinde eee accumulator dediğimiz AC eee olmakta. Eee ardından AC içerisindeki değer de memory tekrardan eee yazdığı ve alt komutuyla stop komutuyla eee programın eee çalışması durduruluyor. Başka bir örnek eee memory'de bulunan birtım sayıların işte birbirine bölme işlemi. Bakın yine ilk işlem. İlk işlem yine memoryden bir load işlemi. Nereye? Bir register içerisine load yapıyoruz. Unutmayın bunu mikro işlemciler dersinde de işte işte dijital dizayignda da işte bu ders içerisinde de belki çok farklı derslerde hep bahsettiğimiz bir konu. Memoride biz işlem yapamıyoruz. İşlem yapmak için mutlaka ve mutlaka eee bilgiyi register'a getirmemiz gerekiyor. Dolayısıyla register'ı bu memory'den gelen bilgiyle veriyle yüklememiz lazım. Sayı memoryden, RAM'den yani register, CPU registerından gitmek zorunda. Çünkü CPU instructionlarının değişkenleri aslında registerlar. Yani memory ile biz işlem yapamıyoruz. Biz hala bu programlama dillerinde eee variabl'ar kullanabiliyoruz. RAM tutulan ama gerçekte alt seviye düşünecek olursanız o değişkenlerin tamamı register'a geldikten sonra instructionlar tarafından kullanılmakta. Şimdi eee başka bir registerda işte eee yine memory'den gelen değerler çünkü sayı bölme yapacağız. Bölen ve bölünen diye iki tane sayımız var. Eee eğer ikinci değer eee 0 ise 0a bölme hatasını engellemek için step'ya jump işlemi yapılıyor. Bakın bu eee bir conditional jump. E hatırlarsanız unconditional ve conditional branch instructionları vardı. Eğer şuraya geri gelecek olursak, eee, unconditional ve conditional branch. Burada conditional brançtan bahsediyoruz. Çünkü, eee, bölen eee, değeri 0sa biliyorsunuz, eee, bölme işlemini gerçekleştiremeyeceğiz. O yüzden eee, burada bir conditional branch işlemi ya da jump işlemi gerçekleştiriliyor. Eğer eee, ikinci değer 0 değilse bu durumda eee, bölme işlemi eee, gerçekleştiriyor ve register gerekli registerlar içerisine değerler aktarılıyor ve bu değer ler de ardından store komutu yardımıyla memory gidip tekrardan yazılıyor ve program sonlanıyor. Şimdi eee bu yapıyı eee şöyle bir şematik olarak gösterecek olursak eee CPU'muz içerisinde bir program counter var. Bu program counter eee bir sonraki çalışacak instruction'ın memorydeki adresini göstermekte. Yani şuradaki değer memory'deki şu adreslerden bir tanesi. Ve bu adreslerden veriyi alırken de bir de ND'inizin dediğiniz bir durumu var. Önce hangi bytını alacağız ve vesaire bunları eee belirtmemiz gerekiyor. Eee bir de struction registerımız var ki o an çalıştırılan instruction'ın eee içeriğini tutmakta. Bunlar da bir register seti. Eee CPU'ya ait registerlar. Burada sadece sayısal olarak ifade edilmişler ama kimi zaman bunlara isimler de veriliyor. İşte AX, BX, CX vesaire gibi ya da EAX, EBX, ECX işte 162 bit ya da RAX, VBX 64 bitte eee farklı isimler veriliyor. Genel yapı bu şekilde. Veri trans veri de bu aradaki eee lane'lerde bast lane eee vasıtasıyla geçiyor. Yani main memory ile CPU arasındaki databas kullanılarak eee bu veri transferi hem load hem storage shelleri için gerçekleştiriliyor. Şimdi makine e kodlarımızın demiştik ki bir operation kodu bir de operandı var. Eee opc dediğimiz şey eee işlemin türü. Hangi işlemin gerçekleştireceği. Operant ise bu işleme ait olan parametreler aslında. Daha eee spesifik bö örnek verecek olursak işte örneğin burada 0011 şeklinde bir op kod verilmiş. Eee burada makinenin instruction setinden bu opcodun ne olduğuna sizin bakmanız gerekiyor. Eee yani işlemci 3 numaralı operation'da ne işlemi yapacak? Mesela I computerda bir tablo vardı. Mesela burada diğer kitapta da böyle bir örnek var. İşte 3 numaralı kod 3 numaralı opcod rxy şeklinde bir işleme karşılık geliyor. Yani description kısmına bakacak olursak da işte store bit pattern found register r E in the memory cell whose address is X Y. Yani burada X Y kısmını adres R'yi de register olarak almakta. Eee bu durumda mesela E 3 5 B1 şeklinde bir instruction'la karşılaştığınız zaman biliyorsunuz bu ilk birincisi operation kodu 3. Yani şuradaki 3'e karşılık geliyor. Eee R geri kalan kısım RXY formatında. Yani R dediğimiz şey yani burada 5'e karşılık gelen kısım. Registerin değeri yani register 5'i kullanacağız. Eee E diğer kısım da B1di. Eee dolayısıyla memorydeki B1 içerisindeki değer register 5'e yani şunun memorynin eee B1'i register 5'e aktarılacak. Yani şuradaki aslında eee şunun şeyini sileyim görünmez olmuş. 35 V1 gibi bir eee komut aslında R5 = MB1 şeklinde. Hani daha sembolik bir gösterimle kullandığım zaman buna karşılık geliyor. Burada eee description kısmında eee söylüyor bir açıklama yapılmış buna ama teknik olarak bunun karşılığı R5. 5 numaralı registerin içerisinde memory'nin B1 adresindeki eee değer kopyalanmış oluyor. Eee anlarını taşıyor. Şimdi dolayısıyla burada bakın eee aslında direkt yine 3 numaralı operation'la ilgili başka bir örnek verilmiş. Eee burada ne diyeceğiz? 3 numaralı eee kısım bir eee bu arada Pardon pardon. Ben şuradaki store'a atlamışım arkadaşlar. Çok ciddi bir hata. Eee hemen şunu silelim. Yanlış bir işlem çünkü. Bir saniye. Hiç uyarmıyorsunuz da beni. 5 nolu registerın içerisindeki değer eee memorynin B1 adresini aktarıyor. Bakın store komutu. Nasıl atladık bilmiyorum. Store komutu yani store Bit pattern found in register R. Yani bu R5 içerisindeki değer. In the memory cell is X Y. Burada X Yde B1'e karşılık geliyor. Tamam. Eee eee dolayısıyla mesela buradaki örnekte de yine store işlemi gerçekleştirilecek. Register 5'in içerisindeki değer artık registerda hangi değer varsa memory'nin A7 hücresi içerisine yerleştirecek. Şimdi eee diğer komutlarda işte mesela bu Buradaki eee komutlara bakalım. İşte load komutu 1 nolu operation'a sahip. RXY formatında yine eee burada load register r yani eee memoryin R registerına eee with the bit pattern font memoryin registerı değil pardon register eee tabii buradaki şeyle R olmuş oluyor. Register set diyelim buna. Register set R'nin içerisine memory'nin X Y'deki elemanını yükle gibi bir anlamı var. Mesela burada 5 numaralı işlem ne? RST formatında e add the bit pats in the register s and t through they were the tool component representation and leave the result in register r yani burada register say ile register register bir array gibi düşünürsek T'nin toplamını eee register R'ye. Tabii oradaki iki tane R sadece biraz kafa karıştırılıyor ama şuradaki RST'den bahsediyorum. Yani içerideki bilgiler şuradaki içerideki bir yer. O RST burada sembolik olarak gösterdiğim R değeri de register set. Yani şuradaki eee şu register seten bahsediyorum. Onun 0, 1inci, 2inci, 3üncü, 3inci vesaire elemandan bahsediyoruz. Dolayısıyla mesela burada eee 5726 gibi bir struction'la işlemci karşılaştığında Bunun 5 numaralı eee opcunu yani add instruction olduğunu anlıyor. 7 numaralı register'ı target olarak belirliyor. Register 2 ve register 6 değerlerini de toplayarak sunucu register yeni de saklamış oluyor. Bunlar da diğer eee operasyonlar. İşte halt kodu 00 vesaire gibi. Şimdi burada mesela 35A7'de aslında bunu zaten açıklamış olduk. Eee bunu geçelim. Eee birkaç farklı Örnek. Şimdi burada eee bir kod var aslında. Yani yukarıdan aşağı şöyle baktığınız zaman en sona hal olduğu için söylüyorum. 1 5 6c hatırlarsanız 1 komutu load komutuydu. Register 5'in içerisine memory'nin 6C adresindeki değeri kopyala. Load register with the bit pattern found in the memory sell at address 6C. Ardından yine load komutu 6 numaralı register içerisine 6D'deki bilgiyi eee eee, yükle load işlemini yap. Ardından 5 numaralı, 5 numaralıyı hatırlayacak olursak şurada yine add komutumuzdu. Eee, 5 numaralı da neydi? Register içerisine register 5 ile register 6'nın toplamını ata. Çünkü register 5 ve register 6'yı dikkat ederseniz burada load ettik zaten. Yani içerisini doldurduk. Ardından toplama işlemini burada gerçekleştirdik. 3 büyük ihtimalle store işlemi olacak. Hemen 3 numaralı işleme bakalım. Az önce storeu hatırlayacak olursanız RX'e formatı var. Register içerisindeki değeri memoryin x'sine eee yani şöyle bir işlem yapıyorduk. Dolayısıyla burada register eee 0 içerisindeki değer kiş burada targetımız dikkat ederseniz 5 ve 6'yı toplayıp 0'a aktarmıştık. Yani R0 = R5 + R6 gibi bir işleme karşılık geliyor burası. Burada da eee memoryin eee 6E adresine register 0 register array şeklinde de gösteri ya da aray 0 da diyebiliriz. Hani sembolik gösterimler çok şey değil. Eee, şu aşamada olmadığı sürece. Eee, dolayısıyla bu kodun amacı işte memory'nin 6C adresindeki bilgi ile memory'nin 6D adresindeki bilgiyi register 5 ve register 6'ya yükleyip ardından register 5 ile register 6'yı topladıktan sonra sonucu register 0'a yazan ardından register 0 içerisindeki bilgiyi de memoryin alt adresine store eden bir program kodu eee bu şekilde yazılmakta. Bu en alt seviye artık makine dili diyebileceğimiz eee formattaki bir program kodu arkadaşlar. Eee bunu anladığınız zaman zaten eee geri kalan eee bu hani uygulamaların nasıl çalıştığını vesaire çalışma mantığını çözmüş oluyorsunuz. Eee bir de demiştik ki e programların çalışması eee patch decode execute cycle'ına eee devamlı. Şimdilik bunu sadece fly code execute diyoruz. Çünkü daha sonra araya iteruplar vesaire de girecek. Eee, bir machine cycle fetch decode executeen oluşmakta. FCH kısmında instruction'ı memoryden ya da bir device'tan, bir perifer device'tan, eee, getiriyoruz. Fetch kısmı. Decode kısmında bu bunun içerisinde yer alan bit paternlerini bulmaya çalışıyoruz. Bu bit paternleri ne? İşte operation code ve bu operation koda karşılık gelen operant ya da operantları bulmaya çalışıyoruz. Ardından execute kısmında artık operation'ın ne olduğunu bildiğimize göre bunun execute kısmını gerçekleştiriyoruz. Belki register içerisine değer aktarılıyor ya da register içerisinde oluşan bir değer memoryye tekrardan store ediliyor. Eee bakın mesela burada B258 diye bir kod var. Hemen tabloya bakalım. B kodu neye karşılık geliyormuş? Instruction setimizde B kodu. Bu arada bu instruction set dediğimiz şey arkadaşlar günümüzde işte X 86 X 64 ya da işte AMD eee 64 ya da X864 olarak undersore var burada bilinen eee setler yani bir işlemcinin tanıdığı, bildiği eee komut grupları. Bu neden önemli? Compatability açısından önemli. Yani yazmış olduğunuz bir program derleyiciler tarafından derlenirken işlemci in anlayabileceği instructionlar kullanılarak referr ediliyor. Yeniden yazılıyor aslında. Yani siz eee high level bir programlama dilinde bir kod yazıyorsunuz ama bu kodun işte atıyorum siz Java'da işte int a dediniz. Eee ardından işte a = 0 dediniz. A + dediniz. Şimdi eee böyle bir kod yazdığınız zaman mesela A'ya 0 atama işlemi için burada loadun o tarz bir versiyonu var mı diyelim. Ha var mesela burada. Eee ne demiş? Vale. Mesela şuradaki 2 numaralı operation'ı kullanmamız gerekecek. Eee burada eee diyelim ki A = 0 gibi bir kod varsa 2 numaralı operation kodu olacak. İşte regist A için register 0'ı o sırada kullanalım. Register 0'a eee 0 0 değerini atar. Ya bunun karşılığı R0 = 0 ama Ardından A'nın değerini 1 artırmak için şöyle ihtimaller var. Şimdi eee bizim burada şu basit instruction setimiz içerisinde hangi komut var ekleme yapabilmek için? İşte şuradaki 5 nolu komutumuz var. Bir de 6 nolu komutumuz var. Şu 5 ile 6 arasındaki farka bakalım. 5'te register 2 ile register 6 içerisindeki değerler toplanıp register 7'ye yazılıyordu. Eee 6 numaralı instruction'a bakacak olursak da hemen example içerisinden bakalım. Eee register 4 ve register E içerisindeki değerler ettikten sonra Evet burada tek fark floating point olması. Yani floating point sayılar için instruction 6 kullanılıyor. Integer sayılar için 5 kullanıyor. Dolayısıyla bizim 5'i kullanmamız lazım. Ama şimdi burada eee bu işlemi gerçekleştirebilmek için yani a + işlemini gerçekleştirm biliyorsunuz a + işlemi a = a + 1'e karşılık geliyor. Yani aslında burada bir işlemi gerçekleştirili. Şimdi eee registerın değerini eee 1 sayısıyla ekleyebilmek için muhtemelen bizim ikinci bir registera ikinci bir komut girmemiz lazım. Eee yine load komutuyla 1 numaralı register içerisine 0 1 değerini ekledik. Bunun karşılığı da eee R1 değişkeninin içerisine 0 1 sayısının eee aktarılması. Yani R0'da 0 var. R1'de 1 var. R0 bu arada A değişkenini temsil ediyor. A + işlemini yapabilmemiz için de 5 numara instruction'ı bizim kullanmamız lazım. Ne yapacağız? Destination'ımızın yine R0 olmasını istiyoruz. O zaman buraya 0 yazdık. Ardından eee yine 0 ile 1 nolu registerları çünkü şurada 0'la 1 nolu registerlarla işlem yaptık. 0' la 1 nolu registerı toplayıp 0 registera aktardığım zaman a + işlemi burada eee gerçekleşmiş olacak. Yani a'nın değerini şuradan 0'dan aldık. Buna 1 ekleme işlemini de register 1'den aldık. Sonuçta Yine register 0'a yazdık. Şimdi bakın bu eee bizim burada a + işlemini yapabilmek için kullandığımız üç ayrı instruction. Tabii bu sadece bu burayla da bitmiyor. Yani bu işlemin gerçek olarak olmasını istiyor. Bir de store işlemini yapmamız lazım. Yani şurada eee 3 numaralı operation cod ile memory'nin ilgili lokasyonuna gidip eee işte 3 numaralı eee operasyonla gidip eee şey yapmamız gerekiyor. Eee, bu arada e a = 0da registerasyon şunu atadık. Şu arada 3 numaralı şeyle eee, memorinin işte A'nın memoride tutulduğu adres X Y adresi ise eee bu X Y adresine eee 0ının içerisindeki değerin atanması gerekiyor. O aşamayı atladık. Aynı şekilde burada hesaplama yaptıktan yani a + 1'i bulduktan sonra da yine 3 ile eee, register 0 içerisinde değeri gidip tekrardan x y'ye yazmamız gerekiyor. Yani xy'yi memoryeki a değişkeninin adresi olarak düşünün burada. Burada gördüğünüz gibi 1 2 3 4 5 tane instructionla ancak bunu yapabilirsin. Ama işte örneğin x86 eee instruction seti içerisinde eee increment şeklinde ink isminde bir tane instruction zaten var. Yani siz şunu load işlemini yaptıktan sonra R1 diye ikinci bir değişken tutmanız gerekmiyor. Eee işte 8 numaralı instruction increment instructionıysa kimi eee işte ilk parametresi eee bir register değeri olacak. İkinci parametresi ve 3üncü parametresi ise bunu ne kadar increment etmek istiyorsun olacak. Bu durumda işte 8001 gibi bir struction kullandığınız zaman 8 burada eee increment eee op koduna karşılık gelecek. 0 increment etmek istediğiniz registerın adresi, registerın eee kendisi eee 01 de bunu eee ne kadarlık increment etmek istiyorsunuz gibi. Bakın dolayısıyla tek bir instruction'la bu işlemi de gerçekleştirebiliyoruz. Yani bu da şu demek. Yani instruction setiniz sizin ne kadar genişse, ne kadar yetenekliyse eee birtım işlemleri alt seviye işlemleri yapmak o kadar eee rahat olacak programcı açısından. Gerçi bunları zaten compiler yapıyor ama eee yine de eee bir işlemin eee tek bir struction'la yapılması demek. Bunun yani CPU cycle yani daha önce bahsetmiştik. Fash Code execute cycle'larımız var. bir program çalışabilmesi için bu instructionların her birinin fetch, decode, execute cycleından geçmesi gerekiyor. Dolayısıyla eee siz 5 tane instruction'ı fod execute'a sokmak yerine sadece bir tek instruction'ı fod execute siteyona soktuğunuz zaman bu işte e cycle'lardan çalmış olacaksınız aslında. Yani gereksiz cycle'ardan başka bir işe kurtulmuş olacaksınız. Bu da eee programın çalışma hızını artırmış olacak. Bu nedenle eee struction setler son derece önemli. Bu arada E bu instruction setlerin de bir hikayesi var. İsterseniz eee hani internetten de bakabilirsiniz. Eee yani dün biraz bahsetmiştik. Eee işte 8086 mimarisi ile birlikte 1978'de eee bu eee işte eee çok uzun yıllar kabul gören struction set piyasaya çıkıyor ve eee ardından işte bu 32 bitti destekleyen eee bir mimari Ardından işte X64 geliyor. Fakat X64'ün gelişi 2000'li yıllar işte 952000'li yıllar arasında ilk 64 bit sistemler işte Pentium Prolarla birlikte ortaya çıkıyor. Fakat burada eee şöyle bir durum var. Örneğin mesela ıntel çok radikal bir karar alarak eee 64 bit sistemleri Pure 64 olarak yani geliştirmeye çalışıyor. Bu da eee işte Etanyum serisi dediğimiz Inıntel'in Itanyum eee serisi olarak adlandırdığı 64 bit işlem eri beraberinde getiriyor. Bu Etherium serisi 64 bit işlemcilerin bir özelliği eee sadece 64 bit uygulamaları desteklemeli. Yani 32 bit dahi çalıştırmayan ya bırakın 16'yı 32 biti dahi çalıştırmayan ve safkan 64 bit işlemcilerd. Tabii eee marketing ve yani pazarlama açısından aslında büyük bir fiyaskoyla sonuçlanıyor bu. Çünkü eee uygulamaların bir anda işletim sistemleri de dahil olmak üzere eee uygulamaların bir anda 64 bit sisteme geçişi o kadar Kolay değil. Yani uygulamayı alıp 64 bit compilerla derlediğimiz çalıştı şeklinde değil bu şeyler. Bu geçişin biraz daha yumuşak olması gerekiyor. Bu kadar sert olmaması gerekiyordu. Eee o dönem AMD firması eee AMD64 adında yani buradaki problemi görerek AMD64 adında bir struction set çıkartıyor. Bu AMD64'ün en önemli özelliği aslında hem 64 biti desteklemesi hem de backward compatibility olarak 32 bit sistemleri yani ilk 86'yı içerisinde desteklemesi. Tabii EL AMD'nin bu başarısı karşısında da eee kendi isimlerine AMD 64 ismini vermek istemiyor. Kendi isimler eee kendi yeni işlemcilerini bu arada Etanyum serisini bir ara sonlandırıyorlar. Şimdi dönem dönem görüyorum işlemcileri ama eee yani hala safkan şeklinde devam ediyor Etherium ama çok fazla da tutmadı. Eee onun yerine günümüzde çok yaygın bir şekilde kullandı. İşte X64'ü Intel getiriyor. Eee teknik açıdan bakacak olursak AMD64 ile X64'ün arasındaki tek fark isim farkı anlıyordu. Bir eee çok büyük bir fark yok. Ya da X8664 benzer bir isim. Sadece isim gösterim farkı diyebiliriz. Arandaki tek fark 64 bit eee desteklemeleri. Eee yani X86'dan farkı. Eee ama X86 eee kendi içerisinde 16 biti de destekliyor. Ama X64'ler eee yani içerisinde 64 bit geçen herhangi bir işlemci 16 bit'i doğrudan desteklemiyor. İsterseniz hani bununla ilgili bir küçük bir sor yap bilirsiniz. Eee, bu instruction setlerle ilgili tabii bu instruction setler içerisinde sub instruction set grupları da var. Mesela bir işlemcinin içerisine instruction setine baktığınız zaman, özelliklerine baktığınız zaman yani X64'in X86 vesaire böyle olması evet onun bir X86 X64 instruction setine sahip olduğunu gösterir. Ama farklı familylerde yani farklı jenerasyonlarda eee bir de ekstra işte atıyorum MMX extensionları var, SSE extensionları var ya da SSE'nin farklı eee versiyonlarının desteklenmeleri var. Bu da eee birtım ekstra işte MMX dediğimiz şey multimedya eee işlemlerinde işte video oynatma, video kayıt etme gibi birtım işlemlerde kullanılabilecek özel eee donanım fonksiyonları. İşte bu örneğin videoların işte eee boyutları standarttır. Birtım standart boyutlandırmalar var. İşte 360p, 240p, 720p, 1080p işte full HD vesaire diye adlandırıyoruz. 4K'dır vesaire birtım standart boyutlar var. Bu boyutlar ile çalış abilecek instruction. Yani burada mesela şu anki çok primitif olarak bakıyoruz bu konuya. Sadece integer ve float sayıların toplanması diye baktık ama işte bir görüntünün toplanması, görüntü üzerinde, matris üzerinde işlemler yapabilme gibi daha karmaşık eee konular bu multimedia extensionları sayesinde gerçekleştirilebiliyor. Eee bu da tabii donanım üzerinde bu işlemin yapılabilmesi yani bu desteğin olması o tarz işlemleri yapan uygulamaların çok daha hızlı bir şekilde çalışabilmesini sağlıyor arkadaşlar. Eee, ne dedik? Ha burada B'ye bakacaktık
hocam.
Evet.
Bazı arkadaşlar derse giremiyormuş da sorun varmış galiba.
Yani dersle alakalı bir şey network bağlantımızı arındığı sıkıntı olabilir diyorum. Kaç kişiyiz? 57 kişiyiz. Bayağmışız. Hocam ders şu an gözükmüyor. Ekipte giremeyen üç arkadaş varmış. H eee kimler giremiyor diye sormakta eee mantıksal bir hata oluralım. Yani hidden normalde channellar oluşturulduğu zaman arkadaşlar hidden oluyor. Belki Teams'ten çıkıp tekrardan girerlerse e kanalı görebilirler. Ya ben auto hide özelliğini kapatıyorum ama yine de e yeni yaratıldığında otomatik olarak hide seçeneğiyle gizleme seçeneğiyle çıkıyor. Belki arkadaşlarınızda öyle bir şey olabilir. Ya da şimdi şey yapalım isterseniz arkadaşlar. Bir ara verelim. Eee aradan sonra devam ederiz. 11.05 eee 11.20 geçe devam edelim.